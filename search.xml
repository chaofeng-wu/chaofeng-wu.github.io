<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UNIX环境高级编程-进程控制</title>
      <link href="/2019/10/09/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-kong-zhi/"/>
      <url>/2019/10/09/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-kong-zhi/</url>
      
        <content type="html"><![CDATA[<p>今天讨论进程控制这一章，也是进程中最终要的一部分，其实主要就是围绕着 fork、exec、wait这三个函数来讨论 Unix 系统是如何管理进程的。</p><h2 id="1-进程标识"><a href="#1-进程标识" class="headerlink" title="1 进程标识"></a>1 进程标识</h2><p>PID 是系统中进程的<strong>唯一标志</strong>，在系统中使用 pid_t 类型表示，它是一个<strong>非负整型</strong>。</p><p>1号 init 进程是所有进程的祖先进程（但不一定是父进程），内核启动后会启动 init 进程，然后内核就会像一个库一样守在后台等待出现异常等情况的时候再出来处理一下，其它的事情都由 init 进程创建子进程来完成。</p><p>进程号是不断向后使用的，当进程号达到最大值的时候，再回到最小一个可用的数值重新使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//getpid, getppid - get process identification</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>pid_t <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//getpid获得当前进程 ID。</span>pid_t <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//getppid获得父进程 ID。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-函数fork"><a href="#2-函数fork" class="headerlink" title="2 函数fork"></a>2 函数fork</h2><p>fork函数的作用就是创建子进程。调用 fork创建子进程的时候，刚开始父子进程是一模一样的，就连代码执行到的位置都是一模一样的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//fork - create a child process</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-1-fork特点"><a href="#2-1-fork特点" class="headerlink" title="2.1 fork特点"></a>2.1 fork特点</h3><p>如何区分父子进程：fork 执行一次，但返回两次。</p><blockquote><ul><li>父进程中的返回值是子进程的 PID</li><li>在子进程中的返回值是 0</li><li>创建失败的返回值为负值。</li></ul></blockquote><p>例如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     pid_t fpid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//fpid表示fork函数返回的值</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    fpid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>fpid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error in fork!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fpid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am the child process, my process id is %d/n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是爹的儿子/n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对某些人来说中文看着更直白。</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am the parent process, my process id is %d/n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是孩子他爹/n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"统计结果是: %d/n"</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-fork之后子进程的创建过程"><a href="#2-2-fork之后子进程的创建过程" class="headerlink" title="2.2 fork之后子进程的创建过程"></a>2.2 fork之后子进程的创建过程</h3><p>从上面，我们知道，调用 fork创建子进程的时候，刚开始父子进程是一模一样的，就连代码执行到的位置都是一模一样的。到底怎么创建子进程的进程空间？</p><ul><li>这里主要经历了两个版本，最初的版本是<strong>完全拷贝父进程的进程空间</strong></li></ul><blockquote><p>拷贝父进程的数据空间、堆和栈，共享父进程的代码段。</p></blockquote><p>如果父进程携带的数据量特别大，那么这种情况创建子进程就会比较耗费资源。这还不是最要命的，万一费了这么大劲创建了一个子进程出来，结果子进程没有使用父进程给它的数据，而只是打印了一句 “Hello World!” 就结束退出了，岂不是白白的浪费了之前的资源开销</p><ul><li>后来又提出了<strong>写时复制技术</strong>。</li></ul><p><strong>写时复制（Copy-On-Write，COW）</strong>就是下图的部分，fork函数刚刚创建子进程的时候父子进程的数据指向同一块物理内存，但是内核将这些内存的访问变为只读的了，当父子进程中的任何一个想要修改数据的时候，内核会为修改区域的那块内存制作一个副本，并将自己的虚拟地址映射到物理地址的指向修改为副本的地址，从此父子进程自己玩自己的，谁也不影响谁，效率也提高了许多。新分配的副本大小通常是虚拟存储系统中的一“页”。</p><p><img src="/2019/10/09/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-kong-zhi/281621483655338.png" alt="fork与写时复制"></p><p>当然，写是复制技术中所谓制作一个副本，这个是在物理地址中制作的，并非是我们在程序中拿到的那个指针所指向的地址，我们的指针所指向的地址其实是虚拟地址，所以这些动作对用户态程序员是透明的，不需要我们自己进行管理，内核会自动为我们打点好一切。</p><h3 id="2-3-父子进程之间的不同"><a href="#2-3-父子进程之间的不同" class="headerlink" title="2.3 父子进程之间的不同"></a>2.3 父子进程之间的不同</h3><p>当然其实父子进程之间是有五点不同的：</p><blockquote><ol><li>fork 的返回值不同；</li><li>父子进程的 PID 不相同；</li><li>父子进程的 PPID 不相同； // PPID 就是父进程 PID</li><li>在子进程中资源的利用量清零，否则如果父进程打开了很多资源，子进程能使用的资源量就很少了；</li><li>未决信号和文件锁不继承。</li></ol></blockquote><p>其次，父进程与子进程谁先运行是不确定的，这个执行顺序是由进程调度器决定的，不过 vfork会保证子进程先运行。进程调度器不是一个工具，是在内核中的一块代码。</p><p>例如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pid_t pid<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] Start!\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> pid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// child</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] Child process.\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// parent</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] Parent process.\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"End!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-shell"><code class="language-shell">>$ make 1forkcc     1fork.c   -o 1fork>$ ./1fork [3713] Start![3714] Child process.[3713] Parent process.[3713] End![3714] End!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新打开一个终端，验证它们的父子进程关系:</p><pre class="line-numbers language-shell"><code class="language-shell"> >$ ps axf3565 pts/1    Ss     0:00  \_ bash3713 pts/1    S+     0:00  |   \_ ./1fork3714 pts/1    S+     0:00  |       \_ ./1fork<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 从 ps命令可以看出来，3713 进程确实产生了一个子进程 3714。</p><p>但是这里面有一个问题，我们重新执行一遍这个程序，这次将输出重定向到文件中。</p><pre class="line-numbers language-shell"><code class="language-shell">>$ ./1fork > result.txt>$ cat result.txt [3807] Start![3807] Parent process.End![3807] Start![3808] Child process.End!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现有什么不同了吗？父进程竟然输出了两次 Start!，这是为什么呢？</p><p>其实第二次 Start! 并不是父进程输出的，而是子进程输出的。但是为什么 PID 却是父进程的呢？</p><p>其实这是因为行缓冲变成了全缓冲导致的，之前我们讲过，标准输出是行缓冲模式，而系统默认的是全缓冲模式。所以当我们将它输出到控制台的时候是可以得到预期结果的，但是一旦重定向到文件的时候就由行缓冲模式变成了全缓冲模式，而子进程产生的时候是会复制父进程的缓冲区的数据的，所以子进程刷新缓冲区的时候子进程也会将从父进程缓冲区中复制到的内容刷新出来。因此，<strong>在使用 fork 产生子进程之前一定要使用 fflush(NULL) 刷新所有缓冲区！</strong></p><p>那么大家再考虑一个问题，当程序运行的时候，为什么子进程的输出结果是在当前 shell 中，而没有打开一个新的 shell 呢？</p><p>这是因为子进程被创建的时候会复制父进程所有打开的文件描述符，所谓的“复制”是指就像执行了 dup函数一样，父子进程每个相同的打开的文件描述符共享一个文件表项。</p><p>而父进程默认开启了 0（stdin）、1（stdout）、2（stderr） 三个文件描述符，所以子进程中也同样存在这三个文件描述符。</p><p>既然子进程会复制父进程的文件描述符，也就是说如果父进程在创建子进程之前关闭了三个标准的文件描述符，那么子进程也就没有这三个文件描述符可以使用了。</p><p>从上面的 ps 命令执行结果可以看出来，我们的父进程是 bash 的子进程，所以我们父进程的三个标准文件描述符是从 bash 中复制过来的。</p><h3 id="2-4-父子进程之间的文件共享"><a href="#2-4-父子进程之间的文件共享" class="headerlink" title="2.4 父子进程之间的文件共享"></a>2.4 父子进程之间的文件共享</h3><p>在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符共享一个文件表项。</p><p><img src="/2019/10/09/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-kong-zhi/1570761510199.png" alt="fork之后父进程和子进程之间对打开文件的共享"></p><h3 id="2-5-僵尸进程"><a href="#2-5-僵尸进程" class="headerlink" title="2.5 僵尸进程"></a>2.5 僵尸进程</h3><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p><p>例如</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pid_t pid<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行</p><pre class="line-numbers language-shell"><code class="language-shell">>$ make 2forkcc     2fork.c   -o 2fork>$ ./2fork pid = 5101pid = 5103pid = 5105pid = 5107pid = 5108pid = 5106pid = 5104pid = 5102pid = 5110pid = 5109# ... 这里父进程处于 sleep 状态，便于我们新打开一个终端查看进程状态>$ ps axf 3565 pts/1    Ss     0:00  \_ bash 5100 pts/1    S+     0:00  |   \_ ./2fork 5101 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5102 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5103 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5104 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5105 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5106 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5107 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5108 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5109 pts/1    Z+     0:00  |       \_ [2fork] <defunct> 5110 pts/1    Z+     0:00  |       \_ [2fork] <defunct>>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从执行结果来看，子进程的状态已经变为 Z+ 了，说明子进程执行完成之后变成了“僵尸进程”。</p><p>那么为什么子进程会变为僵尸进程呢？是因为子进程比父进程先结束了，它们必须得等待父进程为其“收尸”才能彻底释放。</p><p>在现实世界中白发人送黑发人通常会被认为是件不吉利的事情，但是在计算机的世界中，父进程是需要为子进程收尸的。</p><p>如果父进程先结束了，那么这些子进程的父进程会变成 1 号 init 进程，当这些子进程运行结束时会变成僵尸进程，然后 1 号 init 进程就会及时为它们收尸。</p><p>我们修改下上面的栗子，将 sleep（100）这行代码移动到子进程中，让父进程创建完子进程后直接退出，使子进程变成孤儿进程。代码很简单我就不重复贴出来了，直接贴测试的结果。</p><pre class="line-numbers language-shell"><code class="language-shell">>$ make 2forkcc     2fork.c   -o 2fork>$ ./2fork pid = 5245pid = 5247pid = 5251pid = 5254>$ pid = 5252         # 这里会输出一个提示符，是因为父进程退出了，shell 已经为我们的父进程收尸了，所以提示符被输出了。而我们的父进程没有为子进程收尸，所以子进程会继续输出。pid = 5250pid = 5253pid = 5248pid = 5249pid = 5246# 下面我们打开一个新的 shell 查看进程状态>$ ps -axj PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND    1  5296  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5297  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5298  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5299  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5300  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5301  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5302  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5303  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5304  5295  3565 pts/1     3565 S      501   0:00 ./2fork    1  5305  5295  3565 pts/1     3565 S      501   0:00 ./2fork>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面 ps命令的执行结果来看，所有子进程的父进程都变成了 1 号 init 进程。</p><p>很多人会认为僵尸进程不应该出现，它们会占用大量的资源。其实不然，它们在内核中仅仅保留一个结构体，也就是自身的状态信息，其它的资源都释放了。但是它占用了一个重要的系统资源：PID，因为系统中 PID 的数量是有限的，所以及时释放僵尸进程还是很有必要的。</p><p>我们的父进程没有对子进程进行收尸，所以才会出现这样的情况。其实对于这种转瞬即逝的程序而言不会有什么危害，但是假设父进程是一个要不断执行一个月的程序，而它却又不为子进程收尸，那么子进程就会占用这些 PID 一个月之久，那么就可能出现问题了。</p><p>所以在一个完善的程序中，父进程是要为子进程收尸的，至于如何为子进程收尸，下面我们会讲，fork函数就先讨论到这里。</p><h2 id="3-函数vfork"><a href="#3-函数vfork" class="headerlink" title="3 函数vfork"></a>3 函数vfork</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//vfork - create a child process and block parent</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>pid_t <span class="token function">vfork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*Feature Test Macro Requirements for glibc (see feature_test_macros(7)):       vfork():           Since glibc 2.12:               _BSD_SOURCE ||                   (_XOPEN_SOURCE >= 500 ||                       _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED) &amp;&amp;                   !(_POSIX_C_SOURCE >= 200809L || _XOPEN_SOURCE >= 700)           Before glibc 2.12:               _BSD_SOURCE || _XOPEN_SOURCE >= 500 ||               _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED    */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> vfork 函数在上面介绍写时拷贝技术的时候我们就提到了它的工作方式，并且也说了这是一个过时的函数，不推荐大家使用了，简单了解一下就可以了。</p><p>使用 vfork函数创建的子进程除了与父进程共享数据外，vfork还保证子进程先运行，在子进程调用 exec函数族 或 exit（_exit、_Exit） 函数前父进程处于休眠状态。</p><p>另外，<strong>使用 vfork创建的子进程是不允许使用 return 语句返回的，只能使用 exit函数族的函数结束，否则会被信号杀死，父进程则不受这个限制。</strong></p><h2 id="4-函数wait和waitpid"><a href="#4-函数wait和waitpid" class="headerlink" title="4 函数wait和waitpid"></a>4 函数wait和waitpid</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//wait, waitpid, waitid - wait for process to change state</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span>pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>pid_t <span class="token function">waitpid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wait阻塞的等待子进程资源的释放，相当于上面提到的“收尸”。</p><p>每次调用 wait函数会为一个子进程收尸，而 wait函数并没有让我们指定是哪个特定的子进程。如果想要为特定的子进程收尸，需要调用 waitpid 函数。</p><p><strong>收尸这件事只能是父进程对子进程做，而且只能对自己的子进程做。子进程是不能为父进程收尸的，父进程也不能为别人的子进程收尸。</strong></p><p><strong>参数列表：</strong></p><blockquote><ul><li>status：由函数回填，表示子进程的退出状态。如果填 NULL，表示仅回收资源，并不关心子进程的退出状态。status 参数可以使用以下的宏进行解析：</li></ul><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>WIFEXITED</td><td>返回真表示子进程正常终止，返回假表示子进程异常终止。正常与异常终止的8种方式上面讲过。</td></tr><tr><td>WEXITSTATUS</td><td>返回子进程的退出码。只有上一个宏返回正常终止时才能使用，异常终止是不会有返回值的。</td></tr><tr><td>WTERMSIG</td><td>可以获得子进程具体被哪个信号杀死了。</td></tr><tr><td>WIFSTOPPED</td><td>子进程是否被信号 stop 了。stop 和杀死是不同的，stop 的进程可以被恢复（resumed）。</td></tr><tr><td>WSTOPSIG</td><td>如果子进程是被信号 stop 了，可以查看具体是被哪个信号 stop 了。</td></tr><tr><td>WIFCONTINUED</td><td>如果子进程被 stop 了，可以查看它是否被 resumed 了。</td></tr></tbody></table><ul><li>pid：一共分为四种情况</li></ul><table><thead><tr><th>pid参数</th><th>解释</th></tr></thead><tbody><tr><td>&lt; -1</td><td>为归属于进程组 ID 为 pid 参数的绝对值的进程组中的任何一个子进程收尸</td></tr><tr><td>== -1</td><td>为任意一个子进程收尸</td></tr><tr><td>== 0</td><td>为与父进程同一个进程组中的任意一个子进程收尸</td></tr><tr><td>&gt; 0</td><td>为一个 PID 等于参数 pid 的子进程收尸</td></tr></tbody></table><ul><li>options：为特殊要求；这个参数是这个函数的设计精髓。可以通过 WNOHANG 宏要求 waitpid 函数以非阻塞的形式为子进程收尸，这个也是最常用的特殊要求。</li></ul></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pid_t pid<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 为所有的子进程收尸</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家有没有想过为什么要由父进程为子进程收尸呢，为什么不让子进程结束后自动释放所有资源？试想如果没有收尸这步会发生什么。</p><p>假设父进程需要创建一个子进程并且要让它做 3 秒钟的事情，很不巧子进程刚启动就出现了一个异常然后就挂掉了，并且直接释放了自己的资源。<br>而此时系统 PID 资源紧张，很快已死掉的子进程的 PID 被分配给了其它进程，而父进程此时并不知道手里的子进程的 PID 已经不属于它了。</p><p>如果这时候父进程后悔执行子进程了，它要 kill 掉这个子进程。。。。。后果就是系统大乱对吧。</p><p>而使用了收尸技术之后，子进程状态改变时会给父进程发送一个 SIGCHLD 信号，wait函数其实就是阻塞等待被这个信号打断，然后为子进程收尸。</p><p>系统通过收尸这种机制来保证父进程未执行收尸动作之前，手里拿到的子进程 PID 一定是有效的了（即使子进程已死掉，但是这个 PID 依然是属于父进程的子进程的，而不会归属于别人）。</p><h2 id="5-函数exec"><a href="#5-函数exec" class="headerlink" title="5 函数exec"></a>5 函数exec</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//execl, execlp, execle, execv, execvp, execvpe - execute a file</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span>                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*Feature Test Macro Requirements for glibc (see feature_test_macros(7)):       execvpe(): _GNU_SOURCE   */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再来看上面第一个 fork代码的栗子执行时使用 ps -axf 命令查看父子依赖关系的结果：</p><pre class="line-numbers language-shell"><code class="language-shell">>$ ps axf 3565 pts/1    Ss     0:00  \_ bash 3713 pts/1    S+     0:00  |   \_ ./1fork 3714 pts/1    S+     0:00  |       \_ ./1fork>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道 fork 创建出来的子进程是通过复制父进程的形式实现的，但是我们的父进程又是 bash 的子进程，为什么 bash 没有创建出来一个与自己一模一样的子进程呢？</p><p>这就是 exec函数族的功劳了。</p><p>它可以使调用的它进程“外壳”不变，“内容物”改变为新的东西。“外壳”就是父子关系、PID 等东西，“内容物”其实是指一个新的可执行程序。也就是说 exec函数会将调用它的进程完全(整个4GB虚拟内存空间，即代码段、数据段、堆栈等等)变成另一个可执行程序，但父子关系、PID 等东西不会改变。</p><p>在执行了 exec函数族的函数之后，整个进程的地址空间会立即被替换，所以 exec下面的代码全部都不会再执行了，替代的是新程序的代码段。</p><p>缓冲区也会被新的程序所替换，所以<strong>在执行 exec 之前要使用 fflush（NULL）</strong> <strong>刷新所有的缓冲区。</strong>这样父进程才会让它缓冲区中的数据到达它们该去的地方，而不是在数据到达目的地之前缓冲区就被覆盖掉。</p><p>参数列表：</p><blockquote><ul><li>path：要执行的二进制程序路径</li><li>arg：传递给 path 程序的 argv 参数，第一个是 argv[0]，其它参数从第二个开始。</li><li>…：argv 的后续参数，最后一个参数是 NULL，表示变长参数列表的结束。</li></ul></blockquote><p>看上去 execl、execlp像是变参函数，execle像是定参函数，其实正好是反过来的，execl和 execlp是定参的，而 execle函数是变参的。</p><p>下面我们来看一个 fork + exec + wait最经典的用法：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token comment" spellcheck="true">/** * 创建子进程 date，参数是 +%s * 相当于在 shell 中执行 date +%s 命令 */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Begin!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// child</span>    <span class="token punctuation">{</span>        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/date"</span><span class="token punctuation">,</span><span class="token string">"date"</span><span class="token punctuation">,</span><span class="token string">"+%s"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"End!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fork、exec、wait 函数可以让我们创建任何进程来执行任何命令了，如此看来，整个 Linux 世界都是由 fork、exec、wait这三个函数搭建起来的，现在大家可以尝试用这三个函数来执行一些命令了。</p><p>shell 的内部命令与外部命令</p><p>像 cd、exit、|、&gt; 牵涉到环境变量改变等动作这样的命令叫做内部命令，而使用 which命令能查询到的在磁盘上存在的命令就是外部命令。</p><p>学会了 fork、exec、wait函数的使用，大家已经可以尝试编写一个 shell 程序了，基本可以执行所有的外部命令了。</p><p>但是一个 shell 不仅仅支持外部命令，还支持很多内部命令，对内部命令的支持才是 shell 的难点。</p><h2 id="6-更改用户ID和更改组ID"><a href="#6-更改用户ID和更改组ID" class="headerlink" title="6 更改用户ID和更改组ID"></a>6 更改用户ID和更改组ID</h2><p>在 Linux 系统中，特权和访问控制是基于用户 ID 和用户组 ID 的，所以当我们需要使用特权或访问无权访问的文件时需要切换用户 ID 或用户组 ID。</p><p><strong>uid</strong></p><blockquote><ul><li>r（real）用于保存用户权限</li><li>e（effective）定用户权限时使用</li><li>s 与 real 相同，所以有些系统不支持</li></ul></blockquote><p><strong>gid</strong></p><blockquote><ul><li>r（real）用于保存用户组权限</li><li>e（effective）定用户权组限时使用</li><li>s 与 real 相同，所以有些系统不支持</li></ul></blockquote><p>比如普通用户没有查看 /etc/shadow 文件，但是为什么有权限修改自己的密码呢？</p><pre class="line-numbers language-sh"><code class="language-sh">>$ which passwd  /usr/bin/passwd>$ ls -l /usr/bin/passwd  -rwsr-xr-x 1 root root 47032  2月 17  2014 /usr/bin/passwd $ ls -l /etc/shadow ---------- 1 root root 1899 Apr 1 16:25 /etc/shadow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为 passwd命令是具有 U+S 权限的，用户在使用这个程序的时候身份会切换为这个程序文件所有者的身份。</p><p>G+S 与 U+S 类似，只不过执行的瞬间身份会切换为与程序归属用户组相同的组权限。</p><p>改变用户 ID 和组 ID 可以使用 setuid和 setgid函数实现，这两个函数使用起来都比较简单，需要用的童鞋自己查阅 main 手册吧。</p><h2 id="7-解释器文件"><a href="#7-解释器文件" class="headerlink" title="7 解释器文件"></a>7 解释器文件</h2><p>解释器文件其实就是脚本。</p><p>做一个系统级开发工程师需要具备的素质至少精通2门语言，一门面向过程，一门面向对象，还要精通至少一门脚本语言，如 shell、python等，还要具备扎实的网络知识和一点硬件知识。</p><p><strong>解释器</strong>是一个二进制的可执行文件。就是为了用一个可执行的二进制文件解释执行<strong>解释器文件</strong>中的命令。</p><blockquote><p>#! 用于装载解释器</p></blockquote><p>例如：</p><blockquote><p>#!/bin/shell 装载了 /bin/shell 作为解释器</p><p>#!/bin/cat 装载了 /bin/cat 作为解释器</p></blockquote><p>那么装载解释器之后为什么不会递归执行装载解释器这行代码呢？因为根据约定，脚本中的 # 表示注释，所以解释器在解析这个脚本的时候不会看到这行装载解释器的命令。</p><p>装载解释器的步骤由内核 exec 系统调用来完成，如果使用 exec函数来调用解释器文件，实际上 exec 函数并没有执行解释器文件，而是执行了解释器文件中装载的解释器，由它来执行解释器文件中的指令。</p><h2 id="8-函数system"><a href="#8-函数system" class="headerlink" title="8 函数system"></a>8 函数system</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//system - execute a shell command</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数可以执行一条系统命令，是通过调用 /bin/sh -c command 实现的。</p><p>其实我们可以猜测一下 system命令是如何实现的，下面是伪代码：</p><pre class="line-numbers language-c"><code class="language-c">pid_t pid<span class="token punctuation">;</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// child</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// system("date +%s");</span>    <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"date +%s"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-进程会计"><a href="#9-进程会计" class="headerlink" title="9 进程会计"></a>9 进程会计</h2><p>连 POSIX 标准都不支持，是方言中的方言。</p><p>它是典型的事实标准，各个系统的实现都不统一，所以建议少用为妙。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//acct - switch process accounting on or off</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">acct</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNIX环境高级编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解core dump</title>
      <link href="/2019/10/08/xiang-jie-core-dump/"/>
      <url>/2019/10/08/xiang-jie-core-dump/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/tenfyguo/article/details/8159176" target="_blank" rel="noopener">转载自–详解coredump</a></p><h3 id="1-什么是coredump"><a href="#1-什么是coredump" class="headerlink" title="1.什么是coredump"></a>1.什么是coredump</h3><p>​        我们经常听到大家说到程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程中异常退出或者中止，并且在满足一定条件下&#40;这里为什么说需要满足一定的条件呢？下面会分析）会产生一个叫做core的文件。</p><p>​        通常情况下，core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们可以理解为是程序工作当前状态存储生成第一个文件，许多的程序出错的时候都会产生一个core文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决。</p><h3 id="2-coredump文件的存储位置"><a href="#2-coredump文件的存储位置" class="headerlink" title="2.coredump文件的存储位置"></a>2.coredump文件的存储位置</h3><p>core文件默认的存储位置与对应的可执行程序在同一目录下，文件名是core，大家可以通过下面的命令看到core文件的存在位置：</p><blockquote><p>cat  /proc/sys/kernel/core_pattern</p></blockquote><p> 缺省值是core</p><p> <strong>注意：</strong>这里是指在进程当前工作目录的下创建。通常与程序在相同的路径下。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。有好多程序崩溃了，我们却找不到core文件放在什么位置。和chdir函数就有关系。当然程序崩溃了不一定都产生 core文件。</p><p>如下程序代码：则会把生成的core文件存储在/data/coredump/wd，而不是大家认为的跟可执行文件在同一目录。</p> <img src="/2019/10/08/xiang-jie-core-dump/1352287597_1389.jpg" alt="img" style="zoom:50%;"><p>通过下面的命令可以更改coredump文件的存储位置，若你希望把core文件生成到/data/coredump/core目录下：</p><blockquote><p>echo “/data/coredump/core”&gt; /proc/sys/kernel/core_pattern</p></blockquote><p>注意，这里当前用户必须具有对/proc/sys/kernel/core_pattern的写权限。</p><p>缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文件，因此我们有必要对不同程序生成的core文件进行分别命名。</p><p>我们通过修改kernel的参数，可以指定内核所生成的coredump文件的文件名。例如，使用下面的命令使kernel生成名字为core.filename.pid格式的core dump文件：</p><blockquote><p>echo “/data/coredump/core.%e.%p” &gt;/proc/sys/kernel/core_pattern</p></blockquote><p>这样配置后，产生的core文件中将带有崩溃的程序名、以及它的进程ID。上面的%e和%p会被替换成程序文件名以及进程ID。</p><p>如果在上述文件名中包含目录分隔符“/”，那么所生成的core文件将会被放到指定的目录中。 需要说明的是，在内核中还有一个与coredump相关的设置，就是/proc/sys/kernel/core_uses_pid。如果这个文件的内容被配置成1，那么即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。</p><h3 id="3-如何判断一个文件是coredump文件？"><a href="#3-如何判断一个文件是coredump文件？" class="headerlink" title="3.如何判断一个文件是coredump文件？"></a>3.如何判断一个文件是coredump文件？</h3><p>在类unix系统下，coredump文件本身主要的格式也是ELF格式，因此，我们可以通过readelf命令进行判断。</p><img src="/2019/10/08/xiang-jie-core-dump/1352287700_6534.jpg" alt="img" style="zoom:50%;"><p>可以看到ELF文件头的Type字段的类型是：CORE &#40;Core file&#41;</p><p>可以通过简单的file命令进行快速判断：</p><p><img src="https://img-my.csdn.net/uploads/201211/07/1352287746_8191.jpg" alt="img"></p><h3 id="4-产生coredum的一些条件总结"><a href="#4-产生coredum的一些条件总结" class="headerlink" title="4.产生coredum的一些条件总结"></a>4.产生coredum的一些条件总结</h3><p><strong>4.1</strong>产生coredump的条件，首先需要确认当前会话的ulimit –c，若为0，则不会产生对应的coredump，需要进行修改和设置。</p><blockquote><p>ulimit  -c unlimited  &#40;可以产生coredump且不受大小限制&#41;</p></blockquote><ul><li>若想甚至对应的字符大小，则可以指定：</li></ul><blockquote><p>ulimit –c [size]</p></blockquote><img src="/2019/10/08/xiang-jie-core-dump/1352287797_3458.jpg" alt="img" style="zoom:50%;"><p>可以看出，这里的size的单位是blocks,一般1block=512bytes</p><ul><li>但当前设置的ulimit只对当前会话有效，若想系统均有效，则需要进行如下设置：</li></ul><blockquote><p>在/etc/profile中加入以下一行，这将允许生成coredump文件</p><p>ulimit-c unlimited</p><p>在rc.local中加入以下一行，这将使程序崩溃时生成的coredump文件位于/data/coredump/目录下:</p><p>echo /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern </p></blockquote><p><strong>4.2</strong>当前用户，即执行对应程序的用户具有对写入core目录的写权限以及有足够的空间。</p><p><strong>4.3</strong> 几种不会产生core文件的情况说明：</p><blockquote><ol><li>the process was set-user-ID and the current user is not the owner of the program file, or</li><li>the process was set-group-ID and the current user is not the group owner of the file,</li><li>the user does not have permission to write in the current working directory, </li><li>the file already exists and the user does not have permission to write to it, or </li><li>the file is too big &#40;recall the RLIMIT_CORE limit in Section 7.11&#41;. The permissions of the core file &#40;assuming that the file doesn’t already exist&#41; are usually user-read and user-write, although Mac OS X sets only user-read.</li></ol></blockquote><h3 id="5-core-dump产生的几种可能情况"><a href="#5-core-dump产生的几种可能情况" class="headerlink" title="5.core dump产生的几种可能情况"></a>5.core dump产生的几种可能情况</h3><p>造成程序coredump的原因有很多，这里总结一些比较常用的经验吧：</p><h4 id="5-1-内存访问越界"><a href="#5-1-内存访问越界" class="headerlink" title="5.1 内存访问越界"></a>5.1 内存访问越界</h4><blockquote><p>a&#41; 由于使用错误的下标，导致数组访问越界。</p><p>b&#41; 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符。</p><p>c&#41; 使用strcpy, strcat, sprintf, strcmp,strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p></blockquote><h4 id="5-2-多线程程序使用了线程不安全的函数。"><a href="#5-2-多线程程序使用了线程不安全的函数。" class="headerlink" title="5.2 多线程程序使用了线程不安全的函数。"></a>5.2 多线程程序使用了线程不安全的函数。</h4><p>应该使用可重入的函数，它们很容易被用错.</p><h4 id="5-3-多线程读写的数据未加锁保护。"><a href="#5-3-多线程读写的数据未加锁保护。" class="headerlink" title="5.3 多线程读写的数据未加锁保护。"></a>5.3 多线程读写的数据未加锁保护。</h4><p>对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump。</p><h4 id="5-4-非法指针"><a href="#5-4-非法指针" class="headerlink" title="5.4 非法指针"></a>5.4 非法指针</h4><blockquote><p>a&#41; 使用空指针</p><p>b&#41; 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump。</p></blockquote><h4 id="5-6-堆栈溢出"><a href="#5-6-堆栈溢出" class="headerlink" title="5.6 堆栈溢出"></a>5.6 堆栈溢出</h4><p>不要使用大的局部变量 &#40;因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。  </p><h3 id="6-利用gdb进行coredump的定位"><a href="#6-利用gdb进行coredump的定位" class="headerlink" title="6.利用gdb进行coredump的定位"></a>6.利用gdb进行coredump的定位</h3><p>其实分析coredump的工具有很多，现在大部分类unix系统都提供了分析coredump文件的工具，不过，我们经常用到的工具是gdb。这里我们以程序为例子来说明如何进行定位。</p><h4 id="40-1-41-段错误-–-segmentfault"><a href="#40-1-41-段错误-–-segmentfault" class="headerlink" title="&#40;1&#41; 段错误 – segmentfault"></a>&#40;1&#41; 段错误 – segmentfault</h4><ul><li><p>我们写一段代码往受到系统保护的地址写内容。</p><img src="/2019/10/08/xiang-jie-core-dump/1352287869_3119.jpg" alt="img" style="zoom:50%;"></li><li><p>按如下方式进行编译和执行，注意这里需要-g选项编译。</p></li></ul><img src="/2019/10/08/xiang-jie-core-dump/1352287908_9077.jpg" alt="img"><p>可以看到，当输入12的时候，系统提示段错误并且core dumped</p><ul><li>我们进入对应的core文件生成目录，优先确认是否core文件格式并启用gdb进行调试。</li></ul><img src="/2019/10/08/xiang-jie-core-dump/1352287964_7192.jpg" alt="img" style="zoom: 80%;"><blockquote><p>从红色方框截图可以看到，程序中止是因为信号11，且从bt（backtrace）命令（或者where）可以看到函数的调用栈，即程序执行到coremain.cpp的第5行，且里面调用scanf 函数，而该函数其实内部会调用_IO_vfscanf_internal（）函数。</p></blockquote><ul><li>接下来我们继续用gdb，进行调试对应的程序。</li></ul><p>记住几个常用的gdb命令：</p><blockquote><p>l（list），显示源代码，并且可以看到对应的行号；</p><p>b（break）x, x是行号，表示在对应的行号位置设置断点；</p><p>p（print）x, x是变量名，表示打印变量x的值</p><p>r（run）, 表示继续执行到断点的位置</p><p>n（next）,表示执行下一步</p><p>c（continue）,表示继续执行</p><p>q（quit），表示退出gdb</p></blockquote><p> 启动gdb,注意该程序编译需要-g选项进行。</p><p><img src="/2019/10/08/xiang-jie-core-dump/1352288068_8926-1570504739171.jpg" alt="img"></p><p>注：  SIGSEGV     11       Core    Invalid memoryreference</p><h3 id="7-附注："><a href="#7-附注：" class="headerlink" title="7.附注："></a>7.附注：</h3><h4 id="40-1-41-gdb的查看源码"><a href="#40-1-41-gdb的查看源码" class="headerlink" title="&#40;1&#41;gdb的查看源码"></a>&#40;1&#41;gdb的查看源码</h4><p>GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源代码的GDB命令吧。</p><blockquote><p>list&lt;linenum&gt;</p></blockquote><p>显示程序第linenum行的周围的源程序。</p><blockquote><p>list&lt;function&gt;</p></blockquote><p>显示函数名为function的函数的源程序。</p><blockquote><p>list</p></blockquote><p>显示当前行后面的源程序。</p><blockquote><p>list -</p></blockquote><p>显示当前行前面的源程序。</p><p>一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p><blockquote><p>setlistsize &lt;count&gt;</p></blockquote><p>设置一次显示源代码的行数。</p><blockquote><p>showlistsize</p></blockquote><p>查看当前listsize的设置。</p><p>list命令还有下面的用法：</p><blockquote><p>list&lt;first&gt;, &lt;last&gt;</p></blockquote><p>显示从first行到last行之间的源代码。</p><blockquote><p>list ,&lt;last&gt;</p></blockquote><p>显示从当前行到last行之间的源代码。</p><blockquote><p>list +</p></blockquote><p>往后显示源代码。</p><p>一般来说在list后面可以跟以下这些参数：</p><blockquote><p>&lt;linenum&gt;   行号。</p><p>&lt;+offset&gt;   当前行号的正偏移量。</p><p>&lt;-offset&gt;   当前行号的负偏移量。</p><p>&lt;filename linenum&gt;  哪个文件的哪一行。</p><p>&lt;function&gt;函数名。</p><p>&lt;filename: function&gt;哪个文件中的哪个函数。</p><p>&lt;*address&gt;  程序运行时的语句在内存中的地址。</p></blockquote><h4 id="40-2-41-一些常用signal的含义"><a href="#40-2-41-一些常用signal的含义" class="headerlink" title="&#40;2&#41; 一些常用signal的含义"></a>&#40;2&#41; 一些常用signal的含义</h4><ul><li>SIGABRT：调用abort函数时产生此信号。进程异常终止。</li><li>SIGBUS：指示一个实现定义的硬件故障。</li><li>SIGEMT：指示一个实现定义的硬件故障。EMT这一名字来自PDP-11的emulator trap 指令。</li><li>SIGFPE：此信号表示一个算术运算异常，例如除以0，浮点溢出等。</li><li>SIGILL：此信号指示进程已执行一条非法硬件指令。4.3BSD由abort函数产生此信号。SIGABRT现在被用于此。</li><li>SIGIOT：这指示一个实现定义的硬件故障。IOT这个名字来自于PDP-11对于输入／输出TRAP&#40;input/outputTRAP&#41;指令的缩写。系统V的早期版本，由abort函数产生此信号。SIGABRT现在被用于此。</li><li>SIGQUIT：当用户在终端上按退出键&#40;一般采用Ctrl-/）时，产生此信号，并送至前台进程组中的所有进程。此信号不仅终止前台进程组&#40;如SIGINT所做的那样），同时产生一个core文件。</li><li>SIGSEGV：指示进程进行了一次无效的存储访问。名字SEGV表示“段违例&#40;segmentationviolation）”。</li><li>SIGSYS：指示一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的。</li><li>SIGTRAP：指示一个实现定义的硬件故障。此信号名来自于PDP-11的TRAP指令。</li><li>SIGXCPUSVR4和4.3+BSD支持资源限制的概念。如果进程超过了其软C P U时间限制，则产生此信号。</li><li>SIGXFSZ：如果进程超过了其软文件长度限制，则SVR4和4.3+BSD产生此信号。</li></ul><h4 id="40-3-41-Core-pattern的格式"><a href="#40-3-41-Core-pattern的格式" class="headerlink" title="&#40;3&#41;Core_pattern的格式"></a>&#40;3&#41;Core_pattern的格式</h4><p>可以在core_pattern模板中使用变量还很多，见下面的列表：</p><blockquote><ul><li>%% 单个%字符</li><li>%p 所dump进程的进程ID</li><li>%u 所dump进程的实际用户ID</li><li>%g 所dump进程的实际组ID</li><li>%s 导致本次core dump的信号</li><li>%t core dump的时间 &#40;由1970年1月1日计起的秒数&#41;</li><li>%h 主机名</li><li>%e 程序文件名</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> core dump </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程-进程环境</title>
      <link href="/2019/10/07/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-huan-jing/"/>
      <url>/2019/10/07/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="第7章-进程环境"><a href="#第7章-进程环境" class="headerlink" title="第7章 进程环境"></a>第7章 进程环境</h2><img src="/2019/10/07/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-huan-jing/进程环境-1570451566884.png" alt="进程环境主要内容" style="zoom:67%;"><p>本章前半部分讨论进程的开始和结束，后半部分讨论参数列表、环境变量、C 程序虚拟地址空间布局等内容。</p><h3 id="7-1-main函数"><a href="#7-1-main函数" class="headerlink" title="7.1 main函数"></a>7.1 main函数</h3><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组。</p><h3 id="7-2-进程终止"><a href="#7-2-进程终止" class="headerlink" title="7.2 进程终止"></a>7.2 进程终止</h3><p>Linux 系统一共有 8 种进程终止方式，其中 5 种为正常终止方式：</p><blockquote><ol><li>从 main函数返回；</li><li>调用 exit函数；</li><li>调用 _exit或 _Exit函数；</li><li>最后一个线程从其启动例程返回；</li><li>从最后一个线程调用 pthread_exit函数。</li></ol></blockquote><p>剩下的 3 种为异常终止方式：</p><blockquote><ol start="6"><li>调用 abort函数；</li><li>接收到一个信号；</li><li>最后一个线程对取消请求作出响应。</li></ol></blockquote><ul><li><p>第 1 条：在 main函数中执行 return语句，可以将一个 int 值作为程序的返回值返回给调用者，一般是 shell。返回 0 表示程序正常结束，返回 非零值 表示程序异常结束。</p></li><li><p>第 2 条：在 main函数中执行 return 语句相当于调用 exit函数，exit是专门用于结束进程的，它依赖于 _exit或 _Exit系统调用。程序中任何地方调用 exit都会退出，但 return 语句只有在 main函数中才能结束进程，在其它函数中执行 return 语句只能退出当前函数。</p></li><li><p>第 3 条：_exit和 _Exit函数都是系统调用，在程序中的任何地方调用它们程序都会立即结束。</p></li></ul><blockquote><p>上面三条有两点需要大家注意，我先把问题提出来大家思考一下，下面会有讲解：</p><p>(1) return、exit、_exit和 _Exit的返回值取值范围是多少呢？</p><p>(2) exit、_exit和 _Exit之间有什么区别呢？</p></blockquote><ul><li><p>第 4、5 条 等到第 11 章我们讨论线程的时候再说，总之进程就是线程的容器，最后一个线程的退出会导致整个进程的消亡。</p></li><li><p>第 6 条：abort函数一般用在程序中出现了不可预知的错误时，为了避免异常影响范围扩大，直接调用 abort&#40;&#41; 函数自杀。实际上 abort&#40;&#41; 函数也是通过信号实现的。</p></li><li><p>第 7 条：信号有很多种，有些默认动作是被忽略的，有些默认动作则是杀死进程。</p></li></ul><blockquote><p>比如程序接收到 SIGINT（Ctrl+C） 信号就会结束，Ctrl + C 是 SIGINT 的一个快捷方式，而不是 Ctrl + C 触发了 SIGINT 信号。到第 10 章我们会详细的讨论信号。</p></blockquote><ul><li>第 8 条 也要等到第 11 章我们讨论线程的时候再详细说。</li></ul><h4 id="7-2-1-exit"><a href="#7-2-1-exit" class="headerlink" title="7.2.1 exit"></a>7.2.1 exit</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//exit - cause normal process termination</span><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> status 参数的取值范围并非是所有 int 的取值范围，计算方法是 status &amp; 0377，也就相当于一个有符号的 char 型数据，取值范围是 -128～127，最多256种可能。</p><p>所有通过 atexit&#40;&#41; 和 on_exit&#40;&#41; 注册的函数会被以注册的<strong>逆序</strong>来调用。</p><p><strong>它在执行完钩子函数之后再执行IO清理，然后才使进程结束。</strong></p><h4 id="7-2-2-atexit"><a href="#7-2-2-atexit" class="headerlink" title="7.2.2 atexit"></a>7.2.2 atexit</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//atexit - register a function to be called at normal process termination</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span><span class="token keyword">int</span> <span class="token function">atexit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用该函数注册过的函数会在程序<strong>正常终止</strong>之前被调用，被注册的函数称为“<strong>钩子函数</strong>”。</p><p>注册的钩子函数形式必须是这样：void (<em>function)(void)，因为它不会接收任何参数，也没有任何机会返回什么值，所以是一个<em>*无参数无返回值</em></em>的函数。</p><p>当多次调用 atexit(3) 函数注册了多个钩子函数的时候，程序结束时钩子函数是以注册的逆序被调用的。</p><p>比如按照 a&#40;&#41; 、b&#40;&#41; 、c&#40;&#41; 、d&#40;&#41; 的形式注册了 4 个钩子函数，那么程序结束时，它们的调用顺序是：d&#40;&#41; 、c&#40;&#41; 、b&#40;&#41; 、a&#40;&#41; 。</p><p>下面举个栗子来说明这个逆序调用是怎么回事。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdio.h&amp;gt;</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span><span class="token keyword">void</span> <span class="token function">f1</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"f1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f2</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"f2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f3</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"f3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Begin!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">atexit</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只是声明一个函数，相当于把一个函数挂在钩子上，并不调用</span>    <span class="token function">atexit</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">atexit</span><span class="token punctuation">(</span>f3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"End!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并运行测试：</p><pre class="line-numbers language-shell"><code class="language-shell">>$ gcc -Wall atexit.c -o atexit>$ ./atexit Begin!End!f3f2f1>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这回小伙伴们明白逆序调用是怎么回事了吧。</p><p>为什么 “End!” 先输出了，而 “f3” 后输出了呢？因为使用 atexit函数注册钩子函数的时候并不会调用钩子函数，仅仅是注册而已，只有在程序<strong>正常结束</strong>的时候钩子函数才会被调用。</p><p>还记得我们上面提到的什么情况是正常结束吧？注意是只有正常结束才会调用钩子哟，异常结束是不会调用钩子函数的。</p><p>下面写几段伪代码来举栗子说明一下什么场景更适合使用钩子函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * 这段代码要表现的是，当我们的程序需要申请很多资源的时候， * 比如打开文件、申请堆内存等。 * 如果有一个资源申请失败时需要释放之前所有成功申请的资源并退出程序， * 那么就需要在申请每个资源之后都进行错误判断，并手工填写所有的资源释放代码。 * 假如要申请的资源数量很庞大，而恰巧加班又加得老眼昏花 * 结果手一抖，后果。。。 @...@ */</span>fd0 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd0 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(0)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(1)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd2 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(1)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>fd10000 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd10000 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(10000)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd9999<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这种写法是不是太恐怖了，这还只是打开文件而已，如果中间有夹杂着 malloc和 free呢？想都不敢想了。。</p><p>其实想要解决也很简单，钩子函数帮你轻松搞定！下面是改版之后的伪代码：</p><pre class="line-numbers language-c"><code class="language-c">fd0 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd0 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(0)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">atexit</span><span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>fd0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一切都交给钩子函数来处理吧，它会以注册顺序的逆序逐一被调用。</span>fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(1)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">atexit</span><span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>fd1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fd2 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd2 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(1)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">atexit</span><span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>fd10000 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd10000 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open(10000)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">atexit</span><span class="token punctuation">(</span><span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有木有顿时觉得清爽多了，也不容易出现错误了。</p><h4 id="7-2-3-exit、-Exit"><a href="#7-2-3-exit、-Exit" class="headerlink" title="7.2.3 _exit、_Exit"></a>7.2.3 _exit、_Exit</h4><pre class="line-numbers language-c++"><code class="language-c++">//_exit, _Exit - terminate the calling process#include &lt;unistd.h&gt;void _exit(int status);#include &lt;stdlib.h&gt;void _Exit(int status);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在程序的任何地方调用 _exit或 _Exit函数程序都会立即结束，任何钩子函数都不会被调用。</p><p>_exit、_Exit与 exit 的区别就是 _exit 和 _Exit函数<strong>不会调用钩子函数，也不会做 IO 清理</strong>。</p><p>那么什么时候该用 exit，什么时候该用 _exit、_Exit 呢？</p><p>下面我们写一段伪代码来查看 _exit函数的常用场景。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 假定没有任何地方修改过 ret</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">// 出现这种情况的时候一定是上面的代码出现了逻辑问题，或程序中出现了越界等问题，所以不能调用钩子函数执行清理了。为了防止故障扩散，一定要让程序立即结束。</span>            <span class="token comment" spellcheck="true">//exit(1);</span>            <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-命令行参数"><a href="#7-3-命令行参数" class="headerlink" title="7.3 命令行参数"></a>7.3 命令行参数</h3><p>我们在使用 shell 命令的时候经常为传递各种参数来完成不同的工作。这个参数实际上就是传递到程序 main函数的 argc 和 argv 两个参数中去了。 </p><p>我们再来看一下 main函数的原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数列表：</p><blockquote><p>argc：argv 中字符串的数量，也就是传递给程序的命令行参数的数量。</p><p>argv：在 shell 中传递给进程的命令行参数列表，argv[0] 永远是命令本身，第一个参数从 argv[1] 开始。这是一个二维数组，其实就是一个字符串数组而已。很多童鞋不理解它为什么是一个二维数组，说明你的 C 语言基础没有学好。字符串本身就是一个 char 数组，而保存多个字符串的数组自然就是一个 char 型二维素组了。</p></blockquote><p>常见的命令行参数分类：</p><pre class="line-numbers language-sh"><code class="language-sh">>$ cmd [opt] [!opt]>$ ls # 无参数>$ ls -l -a -i  # 仅选项>$ ls /etc/ /tmp  # 非选项传参>$ ls -l /tmp -a /etc>$ ./myplayer -H 500 -W 500 a.avi # 选项带参数>$ ./myplayer -H -W a.avi # 假设 H 和 W 选项必须带参数，这样传惨会报错，因为找不到任何参数修饰 -H 和 -W>$ cmd [opt opt-arg] [!opt]>$ ./myplayer -H 100 px -W 500 cm a.avi # 选项带参数，参数又带参数，这种没有函数能搞定，只能自己写函数解析了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选项分为两种形式，一种是以 - 开头的短格式选项，只能是一个字母或一个数字；</p><p>另一种是长格式选项，以 – 开头，可以由多个字母和数字组成。</p><p>短格式最多支持 26个小写字母+26个大写字母+10个数字，共 62 个选项。这些选项足够一个程序的使用了，为什么还需要长格式的选项呢？</p><p>使用长格式选项是为了便于使用者记忆，辅助短格式参数的使用。如果有一些单词的缩写碰撞了或者不容易记忆，则可以选用长格式的参数。</p><p>这些命令行参数可以随意松散的传给命令，那么命令是如何解析这些参数的呢？别着急，其实已经有优秀的库函数供我们使用了。</p><h3 id="7-4-环境表"><a href="#7-4-环境表" class="headerlink" title="7.4 环境表"></a>7.4 环境表</h3><p>export命令可以查看当前所有的环境变量或设置某个环境变量。</p><p>访问环境变量可以使用 getenv和 putenv函数，下面我们会提到它们。</p><p>环境表就是将环境变量保存在了一个字符指针数组中，很多 Unix 系统都支持三个参数的 main 函数，第三个参数就是环境表。</p><p>环境变量是为了保存常用的数据。以当前 terminal 为例，把 terminal 当作是一个大的程序来跑，就可以将环境变量看作是这个程序的全局变量。</p><p>环境变量相当于在某个位置声明 extern char **environ;</p><p>上面说了，环境表就是一个字符指针数组，所以使用环境变量就相当于 environ[i] - &gt;name=value;</p><h3 id="7-5-程序的存储空间布局"><a href="#7-5-程序的存储空间布局" class="headerlink" title="7.5 程序的存储空间布局"></a>7.5 程序的存储空间布局</h3><p>通常 malloc失败有两种情况，一种是内存真的耗尽了；另一种是不断的申请小的内存，即使堆上全部存放指针也有放满了的情况。</p><p>在 Linux 环境中内存是延时分配的，也就是说当 malloc 分配内存时并没有真正的分配物理内存给你，只是给了你一个非空指针，当你真正使用内存的时候通过引发一个缺页异常，内核才真正分配内存给你。</p><p>好比有人跟你借100块钱，你也承诺了可以借，但是他并不马上要钱，等到当他跟你要的时候你已经花掉了50块钱，这时候你有两个选择：一是把借钱的人杀掉，这样就不用借钱给他了；二是去抢钱，抢够了足够的钱再给他。</p><p>如果让你选择，你会采用哪种方式呢？</p><p>内核采用的是第二种方式，当它发现内存不足够它承诺给你的容量时，它会结束某些不常用的后台进程，再将释放出来的内存分配给你。</p><p><img src="/2019/10/07/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-huan-jing/272239286463516.png" alt="img"></p><h3 id="7-6-共享库"><a href="#7-6-共享库" class="headerlink" title="7.6 共享库"></a>7.6 共享库</h3><p>共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。这减少了每个可行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。</p><h3 id="7-7-存储空间分配"><a href="#7-7-存储空间分配" class="headerlink" title="7.7 存储空间分配"></a>7.7 存储空间分配</h3><p>ISO C说明了3个用于存储空间动态分配的函数。</p><blockquote><ol><li>malloc，分配指定字节数的存储区。此存储区中的初始值不确定。</li><li>calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一位（bit）都初始化为0</li><li>realloc，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。</li></ol></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span><span class="token comment" spellcheck="true">//3个函数返回值:若成功,返回非空指针;若出错,返回NULL</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">calloc</span><span class="token punctuation">(</span>size_t nob size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t newsize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这3个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象。</p><p>其他可能产生的致命性的错误是：</p><blockquote><ul><li>释放一个已经释放了的块；</li><li>调用free时所用的指针不是个alloc函数的返回值等。如若一个进程调用malloc函数，但却忘记调用free函数，那么该进程占用的存储空间就会连续增加，这被称为泄漏（ leakage）。如果不调用free函数释放不再使用的空间，那么进程地址空间长度就会慢慢增加，直至不再有空闲空间。此时，由于过度的换页开销，会造成性能下降</li></ul></blockquote><h3 id="7-8-环境变量"><a href="#7-8-环境变量" class="headerlink" title="7.8 环境变量"></a>7.8 环境变量</h3><p>上面提到了环境表，在这一节我们看看操作环境变量的两个函数如何使用。</p><p>环境变量的作用到底是什么？有很多小伙伴不明白环境变量是个什么东西，一听感觉好深奥啊，惧怕得不行。</p><p>就像我们使用 ls命令的时候是在任何位置都可以使用的，而没有用 /bin/ls 的方式来使用 ls，是因为有 PATH 环境变量的存在，它会保存所有常用的可执行文件的路径。</p><p>其实环境变量无非就是一个字符串而已，它由 key&#40;变量名&#41; 和 value 两部分组成，我们可以通过 key 来读写 value。</p><p>我们通常所说的环境变量就是环境表，也就是由多个环境变量组成的一个字符指针数组，它的存在也就是为了方便我们在程序中获得一些经常使用的变量数据，仅此而已。</p><p>小伙伴们害怕它，一定是因为在 windows 中遇到过太多的程序严重的依赖于它，尤其是系统应用，一旦把环境变量改坏了就玩儿完了，所以才有小伙伴觉得它很深奥很恐怖，今天大家见到了它的庐山真面目了，以后大家都不要害怕它了</p><p><strong>getenv&#40;&#41; ：</strong>这个函数的作用是获取一个环境变量，用法很简单，就是通过 name 获得 value， value 是返回值。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//getenv - get an environment variable</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>setenv&#40;&#41; ：</strong> 这个函数和 getenv函数的作用正好相反，是将 value 赋给 name 环境变量。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//setenv - change or add an environment variable</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span><span class="token keyword">int</span> <span class="token function">setenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span> overwrite<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果 name 不存在，则添加新的环境变量。</li><li>如果 name 存在：如果 overwrite 为真，就用 value 覆盖 name 原来的值；如果 overwrite 为假则保留 name 原来的值。</li></ul><p><strong>putenv&#40;&#41; ：</strong> 用 “name=value” 的形式添加或修改环境变量的值。如果 name 已存在则会用新值覆盖原来的值。</p><pre class="line-numbers language-c"><code class="language-c">putenv <span class="token operator">-</span> change or add an environment variable<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>小伙伴们要注意：<strong>参数不是 const 的，所以某些情况下可能会修改参数的值，所以还是使用 setenv更保险。</strong></p><p>大家思考一个问题：如 图1 所示，环境表是存放在堆与内核空间之间的薄层中的，如果新字符串比原字符串长怎么办，会不会出现越界的情况呢？</p><p>其实不用担心这个问题，因为无论新的值与原来的值谁长谁短，都会先将原来的空间释放，在堆上新申请一块空间来存放新的值。</p><h3 id="7-9-函数setjmp和longjmp"><a href="#7-9-函数setjmp和longjmp" class="headerlink" title="7.9 函数setjmp和longjmp"></a>7.9 函数setjmp和longjmp</h3><p>goto 语句想必大家都很熟悉了吧，但是它们有一个缺点，就是不能跨函数跳转。C 标准给我们提供了两个函数增强了程序跳转的能力，它们可以使程序跨函数跳转。</p><img src="/2019/10/07/unix-huan-jing-gao-ji-bian-cheng-jin-cheng-huan-jing/281052153965159.png" alt="函数调用" style="zoom: 50%;"><p>很多人都忌讳跳转这种东西，认为它会破坏程序的结构。LZ 也反对在程序中随意使用跳转，跳转是把利刃，好钢要用到刀刃上，所以一定要把跳转用在合适的地方，这样能让你的程序写得非常漂亮。</p><p>那么长跳转的好处是什么呢？</p><p>见上图，如果 a&#40;&#41;  b&#40;&#41;  c&#40;&#41;  d&#40;&#41; 是同一个函数，则是递归调用。</p><p>例如当利用递归在一个树状结构中查找一个数据时，查找到最深的层次发现没有找到想要的数据，这时候没有必要再一层一层的返回了，可以直接跳转回递归点。goto是做不到的，需要用 setjmp或longjmp函数安全的返回。</p><p>下面我们来看看这两个函数怎么使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//setjmp - save stack context for nonlocal goto</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;setjmp.h&amp;gt;</span><span class="token keyword">int</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//longjmp, siglongjmp - nonlocal jump to a saved stack context</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;setjmp.h&amp;gt;</span><span class="token keyword">void</span> <span class="token function">longjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要通过 setjmp设置一个跳转点，然后可以通过 longjmp 跳转到 setjmp所在的位置。</p><p>setjmp设置跳转点时返回值为0，被跳转过来时返回值为非零，也就是 longjmp 的 val 参数。所以 setjmp 下面一定跟着一组分支语句来根据不同的返回值做不同的操作。</p><p>longjmp无需返回值，因为执行的时候程序已经跳转了，无法获得返回值了。</p><p>参数列表：</p><blockquote><ul><li>env： 是指定条准到哪</li><li>val：带回去的值，如果值为 0，则 setjmp收到的返回值是 1，避免跳转出现死循环。</li></ul></blockquote><p>下面来看举个栗子：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdio.h&amp;gt;</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;setjmp.h&amp;gt;</span><span class="token keyword">static</span> jmp_buf save<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Begin.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Jump now.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">longjmp</span><span class="token punctuation">(</span>save<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 跳</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():End.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Begin.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Call d().\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():d() returned.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():End.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Begin.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Call c().\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():c() returned.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():End.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Begin.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>save<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 设置跳转点</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Call b().\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():b() returned.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 跳回到这</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Jumped back here with code %d\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():End.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Begin.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():Call a().\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():a() returned.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s():End.\n"</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行：</p><pre class="line-numbers language-shell"><code class="language-shell">>$ gcc jmp.c -Wall -o jmp>$ ./jmpmain():Begin.main():Call a().a():Begin.a():Call b().b():Begin.b():Call c().c():Begin.c():Call d().d():Begin.d():Jump now.a():Jumped back here with code 8a():End.main():a() returned.main():End.>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：setjmp 和 longjmp 函数不能从信号处理函数中跳转，具体原因我们在后面讨论信号的时候会说明。</strong></p><p>13.函数 getrlimit 和 setrlimit</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//getrlimit, setrlimit - get/set resource limits </span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;sys/time.h&amp;gt;</span><span class="token macro property">#<span class="token directive keyword">include</span> &amp;lt;sys/resource.h&amp;gt;</span><span class="token keyword">int</span> <span class="token function">getrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">struct</span> rlimit <span class="token operator">*</span>rlim<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">setrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> rlimit <span class="token operator">*</span>rlim<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个进程都有一组对资源使用的上限，通过这两个函数可以获取或设置这些上限。</p><p>ulimit 命令就是使用这两个函数封装的。</p><p>getrlimit获取 resource 资源，并且把读取结果回填到 rlptr 中。</p><p>setrlimit设置 resource 资源，设置的值由用户填在 rlimit 中。</p><p>rlimit 结构体的内容也很简单，当然这些资源上限也不是随便可以修改的，下面的规则同样适用于 ulimit命令。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rlimit <span class="token punctuation">{</span>    rlim_t rlim_cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 软限制。普通用户能提高和降低软限制，但是不能高过硬限制。超级用户也一样。 */</span>    rlim_t rlim_max<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 硬限制。普通用户只能降低自己的硬限制，不能提高硬限制。超级用户能提高硬限制也能降低硬限制。 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNIX环境高级编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-数据库</title>
      <link href="/2019/10/06/mian-shi-shu-ju-ku/"/>
      <url>/2019/10/06/mian-shi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><blockquote><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p><p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p></blockquote><h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><blockquote><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p></blockquote><h4 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a><strong>3.触发器的作用？</strong></h4><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><blockquote><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p></blockquote><h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><blockquote><p><strong>优点：</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p><strong>缺点：</strong>移植性差</p></blockquote><h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><p><img src="/2019/10/06/mian-shi-shu-ju-ku/ymE9HPJ.png" alt="img"></p><h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p></blockquote><h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><blockquote><p><strong>优点：</strong></p><p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2)用户通过简单的查询可以从复杂查询中得到结果。</p><p>3)维护数据的独立性，试图可从多个表检索数据。</p><p>4)对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong></p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p></blockquote><h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><blockquote><p><strong>最基本：</strong></p><ul><li>drop直接删掉表。 </li><li>truncate删除表中数据，再插入时自增长id又从1开始。 </li><li>delete删除表中数据，可以加where字句。 </li></ul><p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p><p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p><p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p><p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p><p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p><p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p></blockquote><h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><blockquote><p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p><p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong></p><p>如：</p><p>CREATE TEMPORARY TABLE tmp_table (</p><p>NAME VARCHAR (10) NOT NULL,</p><p>time date NOT NULL<br>);</p><p>select * from tmp_table;</p></blockquote><h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 </li><li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 </li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 </li><li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。 </li></ul><p><strong>其他：</strong></p><p><strong>1.</strong>对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p><strong>2.</strong>NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p><p><strong>3.</strong>对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p></blockquote><h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><blockquote><p><strong>第一范式:</strong>(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p><strong>第二范式:</strong>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p><strong>第三范式:</strong>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p><strong>BCNF:</strong>符合3NF，并且，主属性不依赖于主属性。</p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。<br>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。<br>一般，一个数据库设计符合3NF或BCNF就可以了。</p><p><strong>第四范式:</strong>要求把同一表内的多对多关系删除。</p><p><strong>第五范式:</strong>从最终结构重新建立原始结构。</p></blockquote><h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><blockquote><p><strong>内连接:</strong> 只连接匹配的行</p><p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username=b.username</p><p>例如2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</p><p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p><p><strong>注意：</strong></p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p><p><a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">牛客网数据库SQL实战</a></p><p><a href="https://leetcode-cn.com/problemset/database/" target="_blank" rel="noopener">leetcode中文网站数据库练习</a></p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">我的另一篇文章，常用sql练习50题</a></p></blockquote><h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><blockquote><p><strong>1.</strong>char的长度是不可变的，而varchar的长度是可变的。</p><p>定义一个char[10]和varchar[10]。<br>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p><strong>2.</strong>char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。</p><p><strong>3.</strong>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p><p><strong>4.</strong>两者的存储数据都非unicode的字符数据。</p></blockquote><h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><blockquote><p><strong>SQL语言共分为四大类：</strong></p><ul><li>数据查询语言DQL </li><li>数据操纵语言DML </li><li>数据定义语言DDL </li><li>数据控制语言DCL。 </li></ul><p><strong>1. 数据查询语言DQL</strong></p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE </p><p><strong>2 .数据操纵语言DML</strong></p><p>数据操纵语言DML主要有三种形式：</p><p>1) 插入：INSERT</p><p>2) 更新：UPDATE</p><p>3) 删除：DELETE</p><p><strong>3. 数据定义语言DDL</strong></p><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><p><strong>4. 数据控制语言DCL</strong></p><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><p>1) GRANT：授权。</p><p>2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</p><p>3) COMMIT [WORK]：提交。</p><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：<br><a href="https://www.cnblogs.com/study-s/p/5287529.html" target="_blank" rel="noopener">https://www.cnblogs.com/study-s/p/5287529.html</a></p></blockquote><h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><blockquote><p><strong>通配符的分类:</strong></p><p><strong>%百分号通配符:</strong>表示任何字符出现任意次数(可以是0次).</p><p><strong>_下划线通配符:</strong>表示只能匹配单个字符,不能多也不能少,就是一个字符.</p><p><strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p><strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;<br>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p><ul><li>%通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’;匹配包含”yves”的记录(包括记录”yves”) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br>匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’; </li><li><em>通配符使用: SELECT FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.SELECT FROM products WHERE products.prod\</em>name like ‘yves**’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少) </li></ul><p><strong>注意事项:</strong></p><ul><li>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的. </li><li>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的. </li><li>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录. </li></ul><p><strong>技巧与建议:</strong></p><p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。 </li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。 </li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数. </li></ul></blockquote><p>参考博文：<a href="https://blog.csdn.net/u011479200/article/details/78513632" target="_blank" rel="noopener">https://blog.csdn.net/u011479200/article/details/78513632</a></p><h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><blockquote><ul><li>count(*)对行的数目进行计算,包含NULL </li><li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。 </li><li>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。 </li></ul><p><strong>性能问题:</strong></p><p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p><p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;</p><p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p><ul><li>如果表没有主键,那么count(1)比count(*)快。 </li><li>如果有主键,那么count(主键,联合主键)比count(*)快。 </li><li>如果表只有一个字段,count(*)最快。 </li></ul><p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p></blockquote><h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><blockquote><p><strong>多列索引：</strong></p><p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p><p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p><p><strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p></blockquote><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li>一是增加了数据库的存储空间 </li><li>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</li></ul><h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h4><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong></p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p><ul><li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位; </li><li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问; </li></ul><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><ol><li>Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样； </li><li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样； </li><li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用； </li><li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据； </li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。 </li></ol><p><strong>补充：</strong></p><p>1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</p><p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B+树索引和哈希索引的明显区别是：</p><p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p></blockquote><h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><blockquote><ol><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br><img src="/2019/10/06/mian-shi-shu-ju-ku/RbzI0R8.jpg" alt="img"> </li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><img src="/2019/10/06/mian-shi-shu-ju-ku/9VbnDME.jpg" alt="img"> </li></ol></blockquote><h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote><p><strong>1.B+的磁盘读写代价更低</strong></p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>2.B+tree的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><blockquote><p><strong>聚合索引(clustered index):</strong></p><p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引(nonclustered index):</strong></p><p>非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong></p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p></blockquote><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><blockquote><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题</strong></p><p><strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p><strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p><p><strong>事务的隔离级别</strong></p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><p><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p></blockquote><p><strong>特别注意：</strong></p><blockquote><p>MySQL默认的事务隔离级别为repeatable-read</p><p>MySQL 支持 4 中事务隔离级别.</p><p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p><p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p><p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p><strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong></p><p><strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。</p><p><strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。</p><p><strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p></blockquote><h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><blockquote><p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p><strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p><strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p><strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。</p><p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p><strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。</p><p><strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></blockquote><h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><blockquote><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote><p>参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51197560</a></p><h4 id="6-请你介绍一下mysql的MVCC机制"><a href="#6-请你介绍一下mysql的MVCC机制" class="headerlink" title="6.请你介绍一下mysql的MVCC机制"></a><strong>6.请你介绍一下mysql的MVCC机制</strong></h4><blockquote><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p></blockquote><h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><blockquote><p><strong>两种存储引擎的大致区别表现在：</strong></p><p>1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p><p>2.MyISAM适合查询以及插入为主的应用。</p><p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB支持外键，MyISAM不支持。</p><p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p><p>6.InnoDB不支持FULLTEXT类型的索引。</p><p>7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p><p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p><p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。</p></blockquote><h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><blockquote><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p></blockquote><ul><li>1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。 </li><li>2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。 </li></ul><blockquote><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。<br>MEMORY存储引擎</p><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p></blockquote><h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><blockquote><p><strong>事务处理上方面</strong></p></blockquote><ul><li>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li><li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li></ul><blockquote><p><strong>锁级别</strong></p></blockquote><ul><li>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li></ul><blockquote><p><strong>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</strong></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194" target="_blank" rel="noopener">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html" target="_blank" rel="noopener">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p></blockquote><h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><ul><li>1.查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong> </li></ul><blockquote><p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p><p><strong>from:</strong>需要从哪个数据表检索数据</p><p><strong>where:</strong>过滤表中数据的条件</p><p><strong>group by:</strong>如何将上面过滤出的数据分组</p><p><strong>having:</strong>对上面已经分组的数据进行过滤的条件</p><p><strong>select:</strong>查看结果集中的哪个列，或列的计算结果</p><p><strong>order by :</strong>按照什么样的顺序来查看返回的数据</p></blockquote><ul><li>2.<strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong> </li></ul><blockquote><p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：<br><a href="http://www.cnblogs.com/huminxxl/p/3149097.html" target="_blank" rel="noopener">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p></blockquote><h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><blockquote><p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p><p><strong>table：</strong>显示这一行的数据是关于哪张表的</p><p><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p><p><strong>all:</strong>full table scan ;MySQL将遍历全表以找到匹配的行；</p><p><strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引；</p><p><strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p><p><strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p><p><strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p><p><strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p><p><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p><p><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p><strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</p><p><strong>Extra：</strong>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。</p></blockquote><h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><blockquote><ul><li>slow_query_log 慢查询开启状态。 </li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。 </li><li>long_query_time 查询超过多少秒才记录。 </li></ul></blockquote><h4 id="4-请问SQL优化方法有哪些"><a href="#4-请问SQL优化方法有哪些" class="headerlink" title="4.请问SQL优化方法有哪些"></a><strong>4.请问SQL优化方法有哪些</strong></h4><blockquote><p>通过建立索引对查询进行优化</p><p>对查询进行优化，应尽量避免全表扫描</p></blockquote><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><blockquote><p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p><ul><li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 </li><li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 </li><li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br><strong>什么情况下会造成死锁?</strong> </li></ul><p><strong>什么是死锁？</strong></p><p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong>死锁的解决办法?</strong></p><p>1.查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2.设置锁的超时时间<br>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3.指定获取锁的顺序</p></blockquote><h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><p><img src="/2019/10/06/mian-shi-shu-ju-ku/Screenshot1520500121.png" alt="img"></p><blockquote><p><strong>悲观锁（Pessimistic Lock）:</strong></p><p><strong>悲观锁特点:</strong>先获取锁，再进行业务操作。</p><p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br>不同的数据库对select for update的实现和支持都是有所区别的，</p><ul><li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。 </li><li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。 </li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p><strong>1.</strong>乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p><strong>2.**</strong>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.</strong>一般的做法是<strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …; </li><li>根据获取的数据进行业务操作，得到new_data和new_version </li><li>UPDATE SET data = new_data, version = new_version WHERE version = old_version </li></ol><p>if (updated row &gt; 0) {</p><p>// 乐观锁获取成功，操作完成</p><p>} else {</p><p>// 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能 </li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。 </li></ul><p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’ </li><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。 </li><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。 </li></ul></blockquote><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><blockquote><p><strong>主从复制的几种方式:</strong></p><p><strong>同步复制:</strong></p><p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong></p><p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p><strong>半同步复制:</strong></p><p>master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p></blockquote><h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><p><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</p><blockquote><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p></blockquote><p><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</p><blockquote><p><strong>实现数据备份:</strong><br>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p><p><strong>异地容灾:</strong>比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p></blockquote><p><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</p><blockquote><p>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，</p><p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？<br>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。<br>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p><p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p></blockquote><p><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</p><blockquote><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p></blockquote><p><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p><blockquote><p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p></blockquote><p><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</p><blockquote><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p></blockquote><p><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</p><blockquote><p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p></blockquote><h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><blockquote><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p><p><strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。</p><p><strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p><strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。</p><p><strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p></blockquote><h4 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a><strong>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</strong></h4><p>转载：<a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html" target="_blank" rel="noopener">MySQL REDO日志和UNDO日志</a></p><blockquote><p><strong>Undo Log:</strong></p><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p><p>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><p><strong>Redo Log:</strong></p><p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p></blockquote><h2 id="八、Redis"><a href="#八、Redis" class="headerlink" title="八、Redis"></a>八、Redis</h2><h3 id="1-redis-简介"><a href="#1-redis-简介" class="headerlink" title="1. redis 简介"></a>1. redis 简介</h3><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </p><h3 id="2-为什么要用-redis-为什么要用缓存"><a href="#2-为什么要用-redis-为什么要用缓存" class="headerlink" title="2. 为什么要用 redis/为什么要用缓存"></a>2. 为什么要用 redis/为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><img src="/2019/10/06/mian-shi-shu-ju-ku/54316596.jpg" alt></p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p><img src="/2019/10/06/mian-shi-shu-ju-ku/85146760.jpg" alt></p><h3 id="3-为什么要用-redis-而不用-map-guava-做缓存"><a href="#3-为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="3. 为什么要用 redis 而不用 map/guava 做缓存?"></a>3. 为什么要用 redis 而不用 map/guava 做缓存?</h3><blockquote><p>下面的内容来自 segmentfault 一位网友的提问，地址：<a href="https://segmentfault.com/q/1010000009106416" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009106416</a></p></blockquote><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或  memcached服务的高可用，整个程序架构上较为复杂。</p><h3 id="4-redis-的线程模型"><a href="#4-redis-的线程模型" class="headerlink" title="4. redis 的线程模型"></a>4. redis 的线程模型</h3><blockquote><p>参考地址:<a href="https://www.javazhiyin.com/22943.html" target="_blank" rel="noopener">https://www.javazhiyin.com/22943.html</a></p></blockquote><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="5-redis-和-memcached-的区别"><a href="#5-redis-和-memcached-的区别" class="headerlink" title="5. redis 和 memcached 的区别"></a>5. redis 和 memcached 的区别</h3><p>对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！</p><ol><li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li></ol><blockquote><p>来自网络上的一张图，这里分享给大家！</p></blockquote><p><img src="/2019/10/06/mian-shi-shu-ju-ku/61603179.jpg" alt="redis 和 memcached 的区别"></p><h3 id="6-redis-常见数据结构以及使用场景分析"><a href="#6-redis-常见数据结构以及使用场景分析" class="headerlink" title="6. redis 常见数据结构以及使用场景分析"></a>6. redis 常见数据结构以及使用场景分析</h3><h5 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h5><blockquote><p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p><p><strong>底层实现：</strong>整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。<br>常规key-value缓存应用；<br>常规计数：微博数，粉丝数等。</p><h5 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h5><blockquote><p><strong>常用命令：</strong> hget,hset,hgetall 等。</p><p><strong>底层实现：</strong>压缩列表、双端链表</p></blockquote><p>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p><pre><code>key=JavaUser293847value={  “id”: 1,  “name”: “SnailClimb”,  “age”: 22,  “location”: “Wuhan, Hubei”}</code></pre><h5 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h5><blockquote><p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p><p><strong>底层实现：</strong>压缩列表、字典</p></blockquote><p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h5 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h5><blockquote><p><strong>常用命令：</strong>sadd,spop,smembers,sunion 等</p><p><strong>底层实现：</strong>整数集合、字典</p></blockquote><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p><pre><code>sinterstore key1 key2 key3     将交集存在key1内</code></pre><h5 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h5><blockquote><p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p><p><strong>底层实现：</strong> 压缩列表、跳跃表和字典</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p><h3 id="7-redis-设置过期时间"><a href="#7-redis-设置过期时间" class="headerlink" title="7.redis 设置过期时间"></a>7.redis 设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p><p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p><p><strong>定期删除+惰性删除。</strong></p><p>通过名字大概就能猜出这两个删除方式的意思了。</p><ul><li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li></ul><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p><h3 id="8-redis-内存淘汰机制-40-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据-41"><a href="#8-redis-内存淘汰机制-40-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据-41" class="headerlink" title="8.redis 内存淘汰机制&#40;MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?&#41;"></a>8.redis 内存淘汰机制&#40;MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?&#41;</h3><p>redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">http://download.redis.io/redis-stable/redis.conf</a></p><p><strong>redis 提供 6种数据淘汰策略：</strong></p><ol><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0版本后增加以下两种：</p><ol start="7"><li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ol><p><strong>备注： 关于 redis 设置过期时间以及内存淘汰机制，我这里只是简单的总结一下，后面会专门写一篇文章来总结！</strong></p><h3 id="9-redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复"><a href="#9-redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="9.redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)"></a>9.redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p><pre class="line-numbers language-conf"><code class="language-conf">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p><pre class="line-numbers language-conf"><code class="language-conf">appendonly yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p><p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><pre class="line-numbers language-conf"><code class="language-conf">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘appendfsync no        #让操作系统决定何时进行同步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>Redis 4.0 对于持久化机制的优化</strong></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p><strong>补充内容：AOF 重写</strong></p><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p><p><strong>更多内容可以查看我的这篇文章：</strong></p><ul><li><a href="Redis持久化.md">Redis持久化</a></li></ul><h3 id="10-redis-事务"><a href="#10-redis-事务" class="headerlink" title="10.redis 事务"></a>10.redis 事务</h3><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p><h3 id="11-缓存雪崩和缓存穿透问题解决方案"><a href="#11-缓存雪崩和缓存穿透问题解决方案" class="headerlink" title="11.缓存雪崩和缓存穿透问题解决方案"></a>11.缓存雪崩和缓存穿透问题解决方案</h3><p><strong>缓存雪崩</strong> </p><p>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：</p><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><p><img src="/2019/10/06/mian-shi-shu-ju-ku/6078367.jpg" alt></p><p><strong>缓存穿透</strong> </p><p>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></li></ul><h3 id="12-如何解决-Redis-的并发竞争-Key-问题"><a href="#12-如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="12. 如何解决 Redis 的并发竞争 Key 问题"></a>12. 如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/8bddd381de06" target="_blank" rel="noopener">https://www.jianshu.com/p/8bddd381de06</a></li></ul><h3 id="13-如何保证缓存与数据库双写时的数据一致性"><a href="#13-如何保证缓存与数据库双写时的数据一致性" class="headerlink" title="13.如何保证缓存与数据库双写时的数据一致性?"></a>13.如何保证缓存与数据库双写时的数据一致性?</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h3 id="14-请你来说一说Redis是单线程的，但是为什么这么高效呢"><a href="#14-请你来说一说Redis是单线程的，但是为什么这么高效呢" class="headerlink" title="14.请你来说一说Redis是单线程的，但是为什么这么高效呢?"></a>14.请你来说一说Redis是单线程的，但是为什么这么高效呢?</h3><p>虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h3 id="15-请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的"><a href="#15-请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的" class="headerlink" title="15.请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?"></a>15.请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?</h3><p>因为redis是单线程，当K很多时，如果一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：</p><p>1）操作redis时，额外做一步rehash</p><p>对redis做读取、插入、删除等操作时，会把位于table[dict-&gt;rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。</p><p>2）后台定时任务调用rehash</p><p>后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-计算机网络</title>
      <link href="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/"/>
      <url>/2019/10/06/mian-shi-ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h3 id="1-网络模型"><a href="#1-网络模型" class="headerlink" title="1. 网络模型"></a>1. 网络模型</h3><h4 id="1-1-OSI七层模型和TCP-IP四层模型"><a href="#1-1-OSI七层模型和TCP-IP四层模型" class="headerlink" title="1.1 OSI七层模型和TCP/IP四层模型"></a>1.1 OSI七层模型和TCP/IP四层模型</h4><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826496.png" alt="img"></p><h5 id="（1）OSI-七层模型"><a href="#（1）OSI-七层模型" class="headerlink" title="（1）OSI 七层模型"></a>（1）OSI 七层模型</h5><blockquote><ol><li><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范,传输单位为bit。</li><li><strong>数据链路层：</strong>定义了如何让格式化数据以数据帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。（即 封装成帧、透明传输、差错检测）。（将比特组装成帧和点到点的传递）</li><li><strong>网络层：</strong>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet 的发展使得从世界各个站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。即 网络层负责数据包从源到宿的传递和网际互连（主机之间的通信）</li><li><strong>传输层：</strong>定义了一些传输数据的协议和端口(www 端口 80 等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天就是通过这种方式传输的）。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。传输层，提供端到端的可靠报文传递和错误恢复（应用进程之间的通信）</li><li><strong>会话层：</strong>通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接收会话请求。（设备之间需要相互认识可以是 IP 也可以是 MAC 或者是主机名）。即，会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li><li><strong>表示层：</strong>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC 程序员与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。即，<strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li><li><strong>应用层：</strong>是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li></ol></blockquote><h5 id="（2）各层常见协议"><a href="#（2）各层常见协议" class="headerlink" title="（2）各层常见协议"></a>（2）各层常见协议</h5><p><strong>OSI七层协议</strong></p><table><thead><tr><th>层</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>IEE802.3、CLOCK、RJ45</td></tr><tr><td>数据链路层</td><td>MAC、VLAN、PPP</td></tr><tr><td>网络层</td><td>IP、ARP、ICMP</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>会话层</td><td>RPC、NFS</td></tr><tr><td>表示层</td><td>JPE、 ASII</td></tr><tr><td>应用层</td><td>FTP、HTTP、DNS</td></tr></tbody></table><p><strong>TCP/IP四层协议</strong></p><table><thead><tr><th>层</th><th>协议</th></tr></thead><tbody><tr><td>网络接口层</td><td>MAC、VLAN</td></tr><tr><td>网络层</td><td>IP、ARP、ICMP</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>应用层</td><td>HTTP、DNS、SMTP</td></tr></tbody></table><h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E7%89%A9%E7%90%86%E5%B1%82.jpg" alt="物理层"></p><h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.jpg" alt="数据链路层"></p><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E7%BD%91%E7%BB%9C%E5%B1%82.jpg" alt="网络层"></p><h4 id="4-1-IP协议"><a href="#4-1-IP协议" class="headerlink" title="4.1 IP协议"></a>4.1 IP协议</h4><h5 id="（1）IP头部格式"><a href="#（1）IP头部格式" class="headerlink" title="（1）IP头部格式"></a>（1）IP头部格式</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/IP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt="IP头部格式"></p><h5 id="（2）IP-地址的分类和划分子网"><a href="#（2）IP-地址的分类和划分子网" class="headerlink" title="（2）IP 地址的分类和划分子网"></a>（2）IP 地址的分类和划分子网</h5><p>分类的IP地址，是一两级的IP地址（32位），其格式为：<code>IP地址 =  {&lt;网络号&gt;，&lt;主机号&gt;}</code></p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826712.png" alt="img"></p><blockquote><p><strong>A类地址</strong>网络号字段占一个字节，只有7位可用（第一位已固定为0），故A类网络有（2^7 - 2）126个（全0表示本网络，全1（即0111 1111 ）即网络号为127保留为本地软件环回测试本主机进程之间的通信）。每一个A类网络中最大主机数为：2^24 - 2 【1：全0的主机号表示本主机；2：全1的主机号表示<strong>本网络内全部主机】。</strong></p><p><strong>B类地址</strong>网络号字段有2个字节，前两位固定为10，不存在全0或全1，<strong>然而，实际中128.0.0.0是不指派的。</strong>所以B类地址网络号数：2^14-1=16383，同样的主机数2^16-2 =65534。</p><p><strong>C类地址</strong>，前面固定110，同样的实际192.0.0.0是不指派的，2^21-1 = 2097151，主机数2^8-2 =254。</p></blockquote><p><strong>划分子网：</strong></p><blockquote><p>子网的划分就是将两级IP增加到三级IP，它是将IP地址的主机号借用作为子网号，这样增加了网络数，同时也减少了主机数。</p><p>子网掩码是用来和IP地址进行与运算计算得出子网地址。</p><p>如果一个网络不划分子网，那么该网络就使用默认的子网掩码。默认子网掩码中1的位置和IP地址中的网络号对应。划分子网后的子网掩码中1的位置和网络号+子网号的位置对应。</p></blockquote><h4 id="4-2-IPv4与IPv6的区别"><a href="#4-2-IPv4与IPv6的区别" class="headerlink" title="4.2 IPv4与IPv6的区别"></a>4.2 IPv4与IPv6的区别</h4><blockquote><ol><li><strong>更大的地址空间：</strong>IPv4中规定IP地址长度为32，即有2^32-1个地址;而IPv6中IP地址的长度为128，即有2^128-1个地址。</li><li><strong>更小的路由表：</strong>IPv6的地址分配一开始就遵循聚类(Aggregation)的原则，这使得路由器能在路由表中用一条记录(Entry)表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。</li><li><strong>增强的组播支持以及对流的支持：</strong>这使得网络上的多媒体应用有了长足发展的机会，为服务质量(QoS)控制提供了良好的网络平台.</li><li><strong>加入了对自动配置的支持：</strong>这是对DHCP协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷.</li><li><strong>更高的安全性：</strong>在使用IPv6网络中用户可以对网络层的数据进行加密并对IP报文进行校验,这极大的增强了网络安全</li></ol></blockquote><h4 id="4-3-请你说一说IP地址作用，以及MAC地址作用"><a href="#4-3-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="4.3 请你说一说IP地址作用，以及MAC地址作用"></a>4.3 请你说一说IP地址作用，以及MAC地址作用</h4><blockquote><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p></blockquote><h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E4%BC%A0%E8%BE%93%E5%B1%82.jpg" alt="传输层"></p><h4 id="5-1-UDP"><a href="#5-1-UDP" class="headerlink" title="5.1 UDP"></a>5.1 UDP</h4><h5 id="（1）UDP头部"><a href="#（1）UDP头部" class="headerlink" title="（1）UDP头部"></a>（1）UDP头部</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/UDP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt="UDP头部格式"></p><h5 id="（2）UDP特点"><a href="#（2）UDP特点" class="headerlink" title="（2）UDP特点"></a>（2）UDP特点</h5><blockquote><p><strong>UDP</strong> <strong>用户数据报协议</strong>（UserDatagram Protocol）是 OSI 参考模型中一种无连接的传输层协议，提供面向事物的简单不可靠信息传送服务。</p><p>传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p></blockquote><h5 id="（3）应用场景"><a href="#（3）应用场景" class="headerlink" title="（3）应用场景"></a>（3）应用场景</h5><blockquote><p>UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题），NFS(网络文件系统)、SNMP(简单网络管理协议)、DNS(主域名称系统)、TFTP(通用文件传输协议)等等。</p></blockquote><h4 id="5-2-TCP"><a href="#5-2-TCP" class="headerlink" title="5.2 TCP"></a>5.2 TCP</h4><h5 id="（1）TCP头部"><a href="#（1）TCP头部" class="headerlink" title="（1）TCP头部"></a>（1）TCP头部</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/TCP%E5%A4%B4%E9%83%A8.jpg" alt="TCP头部"></p><h5 id="（2）TCP特点"><a href="#（2）TCP特点" class="headerlink" title="（2）TCP特点"></a>（2）TCP特点</h5><blockquote><p><strong>TCP</strong> <strong>传输控制协议</strong>（TransmissionControl Protocol）是一种面向连接的，可靠的，基于字节流的传输层通信协议。</p><p>TCP通过校验和进行差错校验，通过序列号、确认和超时重传机制实现<strong>可靠传输</strong>，通过滑动窗口实现<strong>流量控制</strong>，通过慢开始和拥塞避免、快重传和快恢复实现<strong>拥塞控制</strong>。</p></blockquote><h5 id="（3）应用场景-1"><a href="#（3）应用场景-1" class="headerlink" title="（3）应用场景"></a>（3）应用场景</h5><blockquote><p>一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等。</p></blockquote><h4 id="5-3-TCP连接管理"><a href="#5-3-TCP连接管理" class="headerlink" title="5.3 TCP连接管理"></a>5.3 TCP连接管理</h4><h5 id="（1）TCP连接建立—-三次握手"><a href="#（1）TCP连接建立—-三次握手" class="headerlink" title="（1）TCP连接建立—-三次握手"></a>（1）TCP连接建立—-三次握手</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard.png" alt="img"></p><p><strong>TCP首部的字段：</strong></p><blockquote><p>确认<strong>ACK</strong>：仅当ACK=1时确认号（ack）才有用，当ACK=0时确认号无效。TCP规定，连接建立后的ACK都置为1。</p><p>同步<strong>SYN</strong>：连接建立时用来同步序号。当SYN=1，ACK=0时表明这是一个请求报文段。响应的报文段中SYN=1，ACK=1。SYN=1表明这是一个连接请求或者连接接受阶段。</p><p>终止<strong>FIN</strong>：释放一个连接。当FIN=1时表明此报文段的数据已经发送完毕，要求释放运输连接。</p></blockquote><p><strong>TCP连接建立过程</strong></p><blockquote><p>（1）第一次握手：建立连接时，客户端A发送SYN包[SYN=1,ACK=0,seq=x]（随机选择一个初始序号seq=x）到服务器B（SYN=1的报文段不携带数据，但消耗掉一个序号），并进入SYN_SENT状态（同步已发送），等待服务器B确认。</p><p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN，同时自己也发送一个SYN包，即SYN+ACK包[SYN=1,ACK=1,seq=y,ack=x+1]，此时服务器B进入SYN_RECV状态（同步收到）。</p><p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK[ACK=1,seq=x+1,ack=y+1]，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 </p></blockquote><p>完成三次握手，客户端与服务器开始传送数据。在socket编程中，<strong>客户端执行connect()时，将会触发三次握手</strong>。</p><p><strong>为什么需要三次握手呢？</strong></p><blockquote><p>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p><p>主要是为了防止已经失效的连接请求报文段突然又到达了B，因而产生错误。</p><p>B认为A要建立连接，所以就向A发送确认报文段建立了连接，但是A没有建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，但是B却一直在等待，造成资源的浪费。</p></blockquote><p><strong>为什么不需要四次握手呢？</strong></p><blockquote><p>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：</p><ol><li>客户端发送syn0给服务器</li><li>服务器收到syn0，回复ack(syn0+1)</li><li>服务器发送syn1</li><li>客户端收到syn1，回复ack(syn1+1</li></ol><p>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p></blockquote><h5 id="（2）TCP断开—-四次挥手"><a href="#（2）TCP断开—-四次挥手" class="headerlink" title="（2）TCP断开—-四次挥手"></a>（2）TCP断开—-四次挥手</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826584.png" alt="img"></p><p>客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。TCP要保证在所有可能的情况下使得所有的数据都能够被投递，当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态 ，这能够保证所有的数据都被传输。</p><p><strong>TCP断开过程</strong></p><blockquote><p>（1）首先A B端的TCP进程都处于established状态， 当A的应用程序传送完报文段，就会去主动关闭连接。A会停止发送报文段（但是还会接收），并向B发送[FIN = 1,seq=u]（u等于前面已经发送过的数据的最后一个字节加一）数据，之后进入FIN-WAIT-1状态。</p><p>（2）B接收到A发送的请求之后，会通知应用进程，A已经不再发送数据，同时B会向A发送ACK确认数据[ACK=1,seq=v,ack=u+1 ]，B进入CLOSE-WAIT状态（关闭等待），A接收到B发送的数据之后，A进入FIN-WAIT-2状态；此时A到B方的连接已经关闭了（即半连接状态）。</p><p>（3）当B的应用进程发现自己也没有数据需要传送，B应用进程就会发出被动关闭的请求，B此时向A发送[FIN=1,ACK=1,seq=w,ack=u+1]数据，并且进入LAST-ACK状态（最后确认）。</p><p>（4）A接收到B发送的数据之后，向B发送ACK确认数据[ACK =1,seq=u+1,ack=w+1]，进入TIME-WAIT状态，等待2MSL（Maximum Segment Lifetime，报文最大生存时间）之后正常关闭连接进入CLOSED状态；B接收到A发送的确认之后进入CLOSED状态。B到A方的连接关闭！至此，TCP连接才真正全部关闭！</p></blockquote><p><strong>time_wait 状态存在2MSL的原因</strong></p><blockquote><ol><li>保证最后一次握手报文能到B，能进行超时重传。</li><li>2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</li></ol></blockquote><p><strong>为什么需要四次挥手呢？</strong></p><blockquote><p>1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。</p><p>2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。</p><p>3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。</p><p>4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。</p></blockquote><h4 id="5-4-TCP-可靠传输"><a href="#5-4-TCP-可靠传输" class="headerlink" title="5.4 TCP 可靠传输"></a>5.4 TCP 可靠传输</h4><p>TCP通过<strong>序列号、确认和超时重传机制</strong>实现可靠传输</p><blockquote><p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p></blockquote><h4 id="5-5-TCP-流量控制"><a href="#5-5-TCP-流量控制" class="headerlink" title="5.5 TCP 流量控制"></a>5.5 TCP 流量控制</h4><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826620.png" alt="img"></p><p>TCP 通过<strong>滑动窗口实现</strong>流量控制</p><blockquote><p>在通信过程中，按收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这就是接收窗口rwnd，即调整TCP报文段首部中的”窗口”字段值，来限制发送方向网络注入报文的速率。同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，称为拥塞窗口cwnd，其大小与网络的带宽和时延密切相关。发送窗口的实际大小是取rwnd和cwnd中的最小值。</p><p>流量控制就是让发送方发送速率不要太快，让接收方来得及接收。这是<strong>点对点</strong>的通信量的控制。</p><p>滑动窗口协议，是TCP使用的一种流量控制方法。发送方的发送窗口不能超过接收方给出的接受窗口的大小。</p></blockquote><h4 id="5-6-TCP-拥塞控制"><a href="#5-6-TCP-拥塞控制" class="headerlink" title="5.6 TCP 拥塞控制"></a>5.6 TCP 拥塞控制</h4><p>​        发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><pre><code>     发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</code></pre><p>  <strong>（1）慢开始和拥塞避免</strong></p><p>​      发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><p>​        发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p>​        <strong>慢开始算法</strong>：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后（一个传输轮次），把拥塞窗口增加一倍。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826659.png" alt="img"></p><p>​    为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。慢开始门限ssthresh的用法如下：</p><p>​        当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p><p>​        当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p><p>​        当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p>​    <strong>拥塞避免算法</strong>：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>​        无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826688.png" alt="img"></p><p>​    <strong>（2）快重传和快恢复</strong></p><p>​    <strong>快重传：</strong>算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827065.png" alt="img"></p><p>​    快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复算法</strong>，其过程有以下两个要点：</p><p>​      （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p><p>​       （2） 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827203.png" alt="img"></p><h4 id="5-7-问题"><a href="#5-7-问题" class="headerlink" title="5.7 问题"></a>5.7 问题</h4><h5 id="（1）请你说一说TCP状态转移"><a href="#（1）请你说一说TCP状态转移" class="headerlink" title="（1）请你说一说TCP状态转移"></a>（1）请你说一说TCP状态转移</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/311436_1552471666772_F4FEF3EED170579049D40CE58E343EE4.png" alt="img"></p><h5 id="（2）请你说说TCP-IP数据链路层的交互过程"><a href="#（2）请你说说TCP-IP数据链路层的交互过程" class="headerlink" title="（2）请你说说TCP/IP数据链路层的交互过程"></a>（2）请你说说TCP/IP数据链路层的交互过程</h5><blockquote><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器。</p></blockquote><h5 id="（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"></a>（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h5><blockquote><p>根据端口区分；</p><p>看ip头中的协议标识字段，17是udp，6是tcp</p></blockquote><h5 id="（4）TCP和UDP的区别和各自适用的场景"><a href="#（4）TCP和UDP的区别和各自适用的场景" class="headerlink" title="（4）TCP和UDP的区别和各自适用的场景"></a>（4）TCP和UDP的区别和各自适用的场景</h5><p><strong>TCP和UDP区别</strong></p><blockquote><p>1） 连接</p><ul><li>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</li><li>UDP无连接。</li></ul><p>2） 服务对象</p><ul><li>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</li><li>UDP支持一对一，一对多，多对一，多对多的交互通信。</li></ul><p>3） 可靠性</p><ul><li>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</li><li>UDP是尽最大努力交付，不保证可靠交付。</li></ul><p>4）拥塞控制，流量控制</p><ul><li>TCP有拥塞控制和流量控制保证数据传输的安全性。</li><li>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li></ul><p>5） 报文长度</p><ul><li>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</li><li>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li></ul><p>6)   首部开销</p><ul><li>TCP首部开销大，首部20个字节。</li><li>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li></ul></blockquote><p><strong>应用场景</strong></p><blockquote><p>特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p><p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p></blockquote><h5 id="（5）粘包问题"><a href="#（5）粘包问题" class="headerlink" title="（5）粘包问题"></a>（5）粘包问题</h5><p><strong>出现的原因</strong></p><blockquote><ol><li>发送端需要等缓冲区满才发送出去，造成粘包</li><li>接收方不及时接收缓冲区的包，造成多个包接收</li></ol></blockquote><p>具体点：</p><blockquote><p>（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</p><p>（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p><p>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p></blockquote><p><strong>避免粘包</strong></p><blockquote><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p><p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</p><p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开</p></blockquote><h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h3><h4 id="6-1-HTTP协议"><a href="#6-1-HTTP协议" class="headerlink" title="6.1 HTTP协议"></a>6.1 HTTP协议</h4><h5 id="（1）HTTP协议过程"><a href="#（1）HTTP协议过程" class="headerlink" title="（1）HTTP协议过程"></a>（1）HTTP协议过程</h5><p><strong>HTTP</strong> <strong>超文本传输协议</strong>（HyperText Transfer Protocol）是互联网上应用最为广泛的一种协议。</p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827090.png" alt="img"></p><p>​    HTTP协议永远都是客户端发起请求，服务器回送响应。HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求没有对应关系。一次HTTP操作称为一个事务，其工作过程可分为四步：</p><p>​    1）首先客户机与服务器需要建立连接（建立的是TCP连接，不是HTTP连接，因为HTTP是无连接的）。（只要单击某个超级链接，HTTP的工作开始）具体来说如下：</p><p>​    ① 地址解析</p><p>​         如客户端浏览器请求这个页面：<a href="http://localhost:8080/simple.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a>l</p><p>​         从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p><p>​         协议名：http</p><p>​         主机名：localhost.com</p><p>​         端口：8080</p><p>​         对象路径：/index.htm</p><p>​         在这一步，需要域名解析系统DNS解析域名 localhost.com 得到主机的IP地址。</p><p>​    域名解析的过程：首先搜索浏览器自身的DNS缓存，如果自身的缓存中有对应的条目，而且没有过期，则解析到此结束；如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存；如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件看看这里面有没有该域名对应的IP地址，如果有则解析成功；如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器发起域名解析请求。</p><p>​    ② 封装HTTP请求数据包</p><p>​      把以上部分结合本机自己的信息，封装成一个HTTP请求数据包。</p><p>​    报文的组成：</p><p>​    （1）开始行：在请求报文中叫请求行（包括方法、请求资源的URL、HTTP版本），在响应报文中叫状态行（HTTP版本、状态码、状态码的简单短语）。</p><p>​    其中http版本有：</p><p>​    <strong>http 0.9</strong>：HTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。</p><p>​    <strong>http 1.0</strong>：HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。</p><p>​    <strong>http 1.1</strong> ：HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。（和1.0 的主要区别就是是否是持久连接，1.0一个tcp连接只传输一个Web对象；1.1默认使用持久连接，当然也可以配置成使用非持久连接）</p><p>​    <strong>http 2.0</strong>：HTTP 2.0是下一代 HTTP 协议，目前应用还非常少。</p><p>​    HTTP 2.0最大的特点: 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段这些核心概念没变，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。同时还可以让服务器将响应主动“推送”到客户端缓存中，以此来避免往返的延迟。</p><p>​    HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p><p>​    （2）首部行，说明浏览器，服务器或者报文主体的一些信息。</p><p>​    （3）实体主体，一般不使用。</p><p>​    ③ 封装成TCP包，建立TCP连接（HTTP请求报文作为三次握手的第三个报文的数据发送给服务器）。</p><p>​    2）TCP连接建立后，客户机发送一个http请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p><p>​    3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p><p>​    4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>​    如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h5 id="（2）二进制协议-VS-文本协议"><a href="#（2）二进制协议-VS-文本协议" class="headerlink" title="（2）二进制协议 VS 文本协议"></a>（2）二进制协议 VS 文本协议</h5><p>  二进制协议一般消息头固定和消息体变长 ，每个字段固定了含义 ，其特点如下：</p><blockquote><ol><li>解析效率超高，几乎没有解析代价（优点）；</li><li>没有冗余字段，体积小（优点）；</li><li>可读性差，难于调试（缺点）；</li><li>扩展性不好 ，如果要扩展字段，旧版协议就不兼容了（缺点）；</li></ol></blockquote><p>文本协议（一般是由一串ACSII字符组成的数据）：</p><blockquote><ol><li>可读性好，便于调试；</li><li>扩展性也好，方便兼容旧协议；</li><li>解析效率一般，需要进行字符串比对；</li><li>存在冗余字段，体积大；</li></ol></blockquote><p><strong>http 2.0之前的是文本协议，2.0采用的二进制协议。</strong></p><h5 id="（3）HTTP-1-1-协议中的八种请求方法"><a href="#（3）HTTP-1-1-协议中的八种请求方法" class="headerlink" title="（3）HTTP/1.1 协议中的八种请求方法"></a>（3）HTTP/1.1 协议中的八种请求方法</h5><p>   GET和POST是HTTP协议中的两种发送请求的方法，而HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP。GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>数据位置</td><td>参数通过URL传递</td><td>放在Request body中</td></tr><tr><td>缓存</td><td>请求可被主动缓存</td><td>请求不会被缓存（除非主动设置）</td></tr><tr><td>数据长度</td><td>GET方式提交的数据最多只能是1024字节</td><td>无限制</td></tr><tr><td>可见性/安全性</td><td>数据在 URL 中对所有人都是可见的</td><td>数据不会显示在 URL 中</td></tr><tr><td>数据类型</td><td>只允许 ASCII 字符</td><td>没有限制，也允许二进制数据</td></tr><tr><td>数据包的个数</td><td>GET产生一个TCP数据包（浏览器会把http header和data一并发送出去 ）</td><td>POST产生两个TCP数据包（浏览器先发送header，服务器响应，浏览器再发送data ）</td></tr></tbody></table><p><strong>其他方法</strong></p><blockquote><ol><li><strong>PUT：</strong>向指定资源位置上传其最新内容。</li><li><strong>DELETE：</strong>请求服务器删除 request-url所标识的资源。</li><li><em><em>OPTIONS ： </em></em>返回服务器针对特定资源所支持的HTTP请求方法。</li><li><strong>HEAD：</strong>向服务器索要与get请求相一致的响应，但是响应体将不会被返回。</li><li><strong>TRACE：</strong>回显服务器收到的请求，主要用于测试和诊断。</li><li><strong>CONNECT：</strong>预留给能够将连接改为管道方式的代理服务器。</li></ol></blockquote><h5 id="（4）HTTP返回码"><a href="#（4）HTTP返回码" class="headerlink" title="（4）HTTP返回码"></a>（4）HTTP返回码</h5><p> <strong>1xx——通知信息</strong>，如请求收到了或正在处理。</p><p> <strong>2xx——成功</strong>，成功被服务器接收、理解、并接受。</p><blockquote><p>​    200  服务器成功返回网页</p></blockquote><blockquote><p>​    201 请求成功并且服务器创建了新的资源。</p></blockquote><blockquote><p>​    202 服务器已接受请求，但尚未处理</p></blockquote><p> <strong>3xx——重定向</strong>，客户端需要采取进一步的操作才能完成请求。</p><blockquote><p>​    301状态码：被请求的资源已永久移动到新位置，服务器返回此响应时会自动将请求者转到新位置。</p></blockquote><blockquote><p>​    302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></blockquote><blockquote><p>​    304自从上次请求后，请求的网页未修改过。</p></blockquote><p><strong>4xx——客户端错误</strong>，请求有语法错误或请求无法实现。</p><blockquote><p>​    401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p></blockquote><blockquote><p>​    403状态码：服务器已经理解请求，但是拒绝执行它。</p></blockquote><blockquote><p>​    404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。</p></blockquote><p><strong>5xx——服务器端错误</strong>，服务器未能实现合法的请求。</p><blockquote><p>​    500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</p></blockquote><blockquote><p>​    503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复。</p></blockquote><h5 id="（5）HTTP-特点"><a href="#（5）HTTP-特点" class="headerlink" title="（5）HTTP 特点"></a>（5）HTTP 特点</h5><blockquote><p>1、简单快速：</p><p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：</p><p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3、无连接：</p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>4、无状态：</p><p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>5、支持B/S及C/S模式。</p><p>6、默认端口80</p><p>7、基于TCP协议</p></blockquote><h5 id="（6）HTTP1-0和HTTP1-1的一些区别"><a href="#（6）HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="（6）HTTP1.0和HTTP1.1的一些区别"></a>（6）HTTP1.0和HTTP1.1的一些区别</h5><blockquote><p>（1）长连接</p><p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，一定程度上弥补了HTTP 1.0每次请求都要创建连接的缺点。</p><p>（2）错误通知的管理</p><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p>（3）带宽优化及网络连接的使用</p><p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p>（4）Host头处理在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p>（5）缓存处理</p><p>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></blockquote><h5 id="（7）-HTTP2-0-和-HTTP1-X-相比的新特性"><a href="#（7）-HTTP2-0-和-HTTP1-X-相比的新特性" class="headerlink" title="（7） HTTP2.0 和 HTTP1.X 相比的新特性"></a>（7） HTTP2.0 和 HTTP1.X 相比的新特性</h5><p>​        HTTP 2.0最大的特点: 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段这些核心概念没变，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。</p><blockquote><p><strong>（1）新的二进制格式</strong>（Binary Format）</p></blockquote><blockquote><p>​    而之所以叫2.0，是在于新增的二进制分帧层。HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p></blockquote><blockquote><p><strong>（2）多路复用</strong>（MultiPlexing）</p></blockquote><blockquote><p>​    即连接共享，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></blockquote><blockquote><p><strong>（3）header压缩</strong></p></blockquote><blockquote><p>​    HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></blockquote><blockquote><p><strong>（4）服务端推送</strong>（server push）</p></blockquote><blockquote><p>​    同时还可以让服务器将响应主动“推送”到客户端缓存中，以此来避免往返的延迟。</p></blockquote><h4 id="6-2-HTTPS协议"><a href="#6-2-HTTPS协议" class="headerlink" title="6.2 HTTPS协议"></a>6.2 HTTPS协议</h4><h5 id="（1）过程"><a href="#（1）过程" class="headerlink" title="（1）过程"></a>（1）过程</h5><p> https简单的说就是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，在http的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。</p><p>​    https要使客户端与服务器端的通信过程得到安全保证，必须使用对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密，从而解决了客户端与服务器端之间的通信安全问题。</p><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826891.png" alt="img"></p><p>​    （1）客户端先向服务器发出加密通信的请求（协议版本、random1、加密方法、压缩方法）。</p><p>​    （2）服务器收到请求,然后响应（协议版本、random2、加密方法、服务器证书）。</p><p>​    （3）客户端收到证书之后会首先会进行验证，如果没有验证通过，就会显示不安全的提示。验证通过之后，客户端会生成一个随机数 pre-master secret，然后使用证书中的公钥进行加密，然后传递给服务器端。</p><p>​    （4）服务器收到使用公钥加密的内容，在服务器端使用私钥解密（https中公钥和私钥是互为加密解密的。公钥是大家都知道的，你发送的数据是用公钥加密的，如果公钥能够解密的话，https也就不具备安全性了）之后获得随机数pre-master secret，然后根据radom1、radom2、pre-master secret通过一定的算法得出session Key和MAC算法秘钥，作为后面交互过程中使用对称秘钥。同时客户端也会使用radom1、radom2、pre-master secret，和同样的算法生成session Key和MAC算法的秘钥。</p><p>​    （5）然后在后续的交互中就使用session Key和MAC算法的秘钥对传输的内容进行加密和解密。</p><h5 id="（2）抓包的数据安全性"><a href="#（2）抓包的数据安全性" class="headerlink" title="（2）抓包的数据安全性"></a>（2）抓包的数据安全性</h5><p>​        https抓包的原理就是抓包程序将服务器返回的证书截获，然后给客户端返回一个它自己的证书，客户端发送的数据抓包程序用自己的证书解密，然后再用截获的证书加密，再发给服务器，所以抓包程序看到的是明文。</p><h4 id="6-4-问题"><a href="#6-4-问题" class="headerlink" title="6.4 问题"></a>6.4 问题</h4><h5 id="（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h5><p>HTTP协议和HTTPS协议区别如下：</p><blockquote><p>（1）HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p><p>（2）HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p><p>（3）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>（4）HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p></blockquote><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827253.png" alt="img"></p><p>HTTPS优点：</p><blockquote><ul><li>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</li><li>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</li></ul></blockquote><p>HTTPS缺点：</p><blockquote><ul><li>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</li><li>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</li></ul></blockquote><h5 id="（2）cookie-和-session-的区别和联系"><a href="#（2）cookie-和-session-的区别和联系" class="headerlink" title="（2）cookie 和 session 的区别和联系"></a>（2）cookie 和 session 的区别和联系</h5><p> 理论上一个用户的所有请求操作都应该属于同一个会话，Web应用程序是使用HTTP协议进行传输数据的，HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接，这就意味着服务器无法从连接上跟踪会话，为了弥补HTTP协议无状态的不足，引入了cookie机制进行会话跟踪。</p><p>​    客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</p><p><strong>区别：</strong></p><blockquote><ol><li>cookie在客户端记录信息确定用户身份，session在服务器端记录信息确定用户身份。</li><li>Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。</li><li>Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</li></ol></blockquote><p>​    <strong>联系：</strong></p><blockquote><ol><li>cookie和session都是用来跟踪浏览器用户身份的会话方式。</li><li>session 的运行依赖 session id，而 session id 是存在 cookie 中的，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）。</li><li>Session是保存在服务器端的，每个用户都会产生一个Session。如果并发访问的用户非常多，会产生非常多的Session，消耗大量的内存。 而Cookie保存在客户端，不占用服务器资源。如果并发浏览的用户非常多，Cookie是很好的选择。</li></ol></blockquote><h5 id="（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h5><p>浏览器中输入URL，浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p><p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p><p>其中：</p><p>1、DNS协议，http协议，https协议属于应用层</p><p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p><p>2、TCP/UDP属于传输层</p><p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p><p>3、IP协议，ARP协议属于网络层</p><p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。<br>4、数据链路层</p><p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。<br>5、物理层</p><p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p><h5 id="（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"><a href="#（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）" class="headerlink" title="（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"></a>（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）</h5><blockquote><p>服务端：socket-bind-listen-accept</p><p>客户端：socket-connect</p></blockquote><h5 id="（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h5><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p><h5 id="（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数"><a href="#（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数"></a>（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数</h5><p><strong>基于TCP的socket：</strong></p><blockquote><p><strong>服务器端程序：</strong></p><ul><li>创建一个socket，用函数socket()</li><li>绑定IP地址、端口等信息到socket上，用函数bind()</li><li>设置允许的最大连接数，用函数listen()</li><li>接收客户端上来的连接，用函数accept()</li><li>收发数据，用函数send()和recv()，或者read()和write()</li><li>关闭网络连接</li></ul><p><strong>客户端程序：</strong></p><ul><li>创建一个socket，用函数socket()</li><li>设置要连接的对方的IP地址和端口等属性</li><li>连接服务器，用函数connect()</li><li>收发数据，用函数send()和recv()，或read()和write()</li><li>关闭网络连接</li></ul></blockquote><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/308571_1552654678444_69CF8398BCC9F204991E623723D022E7.png" alt="img"></p><p><strong>基于UDP的socket：</strong></p><blockquote><p><strong>服务器端流程</strong></p><ul><li>建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</li><li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</li><li>绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</li><li>接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</li><li>向客户端发送数据，使用sendto()函数向服务器主机发送数据。</li><li>关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li></ul><p><strong>客户端流程</strong></p><ul><li>建立套接字文件描述符，socket()。</li><li>设置服务器地址和端口，struct sockaddr。</li><li>向服务器发送数据，sendto()。</li><li>接收服务器的数据，recvfrom()。</li><li>关闭套接字，close()。</li></ul></blockquote><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C.png" alt="img"></p><h5 id="（7）请你来说一下数字证书是什么，里面都包含那些内容"><a href="#（7）请你来说一下数字证书是什么，里面都包含那些内容" class="headerlink" title="（7）请你来说一下数字证书是什么，里面都包含那些内容"></a>（7）请你来说一下数字证书是什么，里面都包含那些内容</h5><p><strong>1）概念：</strong></p><p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p><p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p><p><strong>2）数字证书颁发过程：</strong></p><p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p><p><strong>3）内容：</strong></p><p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p><blockquote><ul><li>证书的版本信息；</li><li>证书的序列号，每个证书都有一个唯一的证书序列号；</li><li>证书所使用的签名算法；</li><li>证书的发行机构名称，命名规则一般采用X.500格式；</li><li>证书的有效期，通用的证书一般采用UTC时间格式；</li><li>证书所有人的名称，命名规则一般采用X.500格式；</li><li>证书所有人的公开密钥；</li><li>证书发行者对证书的签名。</li></ul></blockquote><h5 id="（8）请你讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#（8）请你讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="（8）请你讲述一下Socket编程的send() recv() accept() socket()函数？"></a>（8）请你讲述一下Socket编程的send() recv() accept() socket()函数？</h5><p>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p><p>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p><h5 id="（9）请你说一下http协议会话结束标志怎么截出来？"><a href="#（9）请你说一下http协议会话结束标志怎么截出来？" class="headerlink" title="（9）请你说一下http协议会话结束标志怎么截出来？"></a>（9）请你说一下http协议会话结束标志怎么截出来？</h5><p>看tcp连接是否有断开的四部挥手阶段。</p><h5 id="（10）请你来介绍一下udp的connect函数"><a href="#（10）请你来介绍一下udp的connect函数" class="headerlink" title="（10）请你来介绍一下udp的connect函数"></a>（10）请你来介绍一下udp的connect函数</h5><p>除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p><p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p><p>其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p><p>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</p><p>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</p><p>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</p><p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p><p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p><h5 id="（11）请你说一下阻塞，非阻塞，同步，异步"><a href="#（11）请你说一下阻塞，非阻塞，同步，异步" class="headerlink" title="（11）请你说一下阻塞，非阻塞，同步，异步"></a>（11）请你说一下阻塞，非阻塞，同步，异步</h5><blockquote><p><strong>阻塞和非阻塞：</strong>调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p><p><strong>同步和异步：</strong>调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步。</p></blockquote><h5 id="（12）Ping和TraceRoute实现原理"><a href="#（12）Ping和TraceRoute实现原理" class="headerlink" title="（12）Ping和TraceRoute实现原理"></a>（12）Ping和TraceRoute实现原理</h5><blockquote><ol><li>Ping是通过发送ICMP报文回显请求实现。<br>ICMP是（Internet Control Message Protocol）Internet控制报文协议,用于在IP主机、路由器之间传递控制消息。</li><li>Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。</li></ol><ul><li>首先，tracert送出一个TTL是1的IP 数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将TTL减1。此时，TTL变为0，所以该路由器会将此数据包丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），tracert 收到这个消息后，便知道这个路由器存在于这个路径上，接着tracert 再送出另一个TTL是2 的数据包，发现第2 个路由器…… tracert 每次将送出的数据包的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个数据包 抵达目的地。当数据包到达目的地后，该主机则不会送回ICMP time exceeded消息，一旦到达目的地，由于tracert通过UDP数据包向不常见端口(30000以上)发送数据包，因此会收到「ICMP port unreachable」消息，故可判断到达目的地。</li><li>tracert 有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的*号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Tracert给TTL记数器加1，继续进行。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-C++</title>
      <link href="/2019/10/06/mian-shi-c/"/>
      <url>/2019/10/06/mian-shi-c/</url>
      
        <content type="html"><![CDATA[<h2 id="1-编译和链接"><a href="#1-编译和链接" class="headerlink" title="1 编译和链接"></a>1 编译和链接</h2><h3 id="1-1-编译和链接"><a href="#1-1-编译和链接" class="headerlink" title="1.1 编译和链接"></a>1.1 编译和链接</h3><h4 id="1-1-1-请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#1-1-1-请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="1.1.1 请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>1.1.1 请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h4><blockquote><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p><ul><li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</li><li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li><li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li><li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li></ul><blockquote><ol><li><strong>静态链接：</strong>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</li></ol><ul><li><strong>缺点：</strong></li></ul><blockquote><ul><li>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</li><li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li><li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li></ul></blockquote><ul><li><strong>优点：</strong></li></ul><blockquote><ul><li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li></ul></blockquote><ol start="2"><li><strong>动态链接：</strong>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li></ol><ul><li><strong>优点：</strong></li></ul><blockquote><ul><li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</li><li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li></ul></blockquote><ul><li><strong>缺点：</strong></li></ul><blockquote><ul><li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失</li></ul></blockquote></blockquote></blockquote><h4 id="1-1-2-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#1-1-2-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="1.1.2 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>1.1.2 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h4><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</p><p>双引号和尖括号的区别：</p><blockquote><p>编译器预处理阶段查找头文件的路径不一样。</p></blockquote><p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p><blockquote><ul><li>当前头文件目录</li><li>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li><li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li></ul></blockquote><p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p><blockquote><ul><li>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li><li>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li></ul></blockquote><h4 id="1-1-3-请问GDB调试用过吗，什么是条件断点"><a href="#1-1-3-请问GDB调试用过吗，什么是条件断点" class="headerlink" title="1.1.3 请问GDB调试用过吗，什么是条件断点"></a>1.1.3 请问GDB调试用过吗，什么是条件断点</h4><p>1、GDB调试</p><blockquote><ul><li>GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</li><li>GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</li></ul></blockquote><p>2、条件断点</p><blockquote><p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p><p>例如：(gdb)break 666 if testsize==100</p></blockquote><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><h3 id="2-1-关键字"><a href="#2-1-关键字" class="headerlink" title="2.1 关键字"></a>2.1 关键字</h3><h4 id="2-1-1-static"><a href="#2-1-1-static" class="headerlink" title="2.1.1 static"></a>2.1.1 static</h4><p>面向过程程序设计中的static和面向对象程序设计中的static。</p><p>（1）<strong>面向过程设计中的static</strong></p><blockquote><p><strong>静态全局变量：</strong>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。</p><ul><li>该变量在全局数据区分配内存，也就是静态存储区</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</li></ul><p><strong>静态局部变量：</strong> 在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p><ul><li>该变量在全局数据区分配内存，也就是静态存储区</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul><p><strong>静态函数：</strong> 在函数的返回类型前加上static关键字,函数即被定义为静态函数</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突；</li></ul></blockquote><p>（2）<strong>面向对象的static关键字（类中的static关键字）</strong></p><blockquote><p><strong>静态数据成员：</strong> 在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。</li><li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则。</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li><li>静态数据成员初始化与一般数据成员初始化不同。</li></ul><p><strong>静态成员函数：</strong> </p><ul><li>出现在类体外的函数定义不能指定关键字static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li></ul></blockquote><p>（3）<strong>请你回答一下静态变量什么时候初始化</strong></p><blockquote><p>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p></blockquote><h4 id="2-1-2-const"><a href="#2-1-2-const" class="headerlink" title="2.1.2 const"></a>2.1.2 const</h4><p><strong>(1) const修饰基本数据类型</strong></p><blockquote><p><strong>1.const修饰一般常量及数组</strong>  </p><blockquote><p>对于类似这些基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。</p></blockquote><p><strong>2.const修饰指针变量*</strong>  </p><blockquote><p>如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；</p><p>如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量</p></blockquote><p><strong>3. const修饰引用</strong></p><blockquote><p>表示要引用的对象是一个常量。</p></blockquote></blockquote><p><strong>(2)const应用到函数中</strong></p><blockquote><p><strong>1.作为参数的const修饰符</strong></p><blockquote><p>参数在使用过程中，内容不可以被更改</p></blockquote><p><strong>2.作为函数返回值的const修饰符</strong>  </p><blockquote><p>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。</p></blockquote></blockquote><p><strong>(3)const在类中的用法</strong></p><blockquote><p><strong>1.修饰成员变量</strong></p><blockquote><p>不能在类声明中初始化const数据成员，const数据成员的初始化只能在类构造函数的初始化表中进行。 对const成员变量的初始化，不能在变量声明的地方，必须在类的构造函数的初始化列表中完成，即使是在构造函数内部赋值也是不行的。</p></blockquote><p><strong>2.后缀修饰成员函数</strong></p><blockquote><p>const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.</p></blockquote></blockquote><p><strong>(4)const修饰类对象，定义常量对象</strong> </p><blockquote><p>常量对象只能调用常量函数，别的成员函数都不能调用。</p></blockquote><p><font size="4" color="red">const和define的区别：</font></p><p><strong>(1) 编译器处理方式不同</strong></p><blockquote><ul><li>define宏是在预处理阶段展开。</li><li>const常量是编译运行阶段使用。</li></ul></blockquote><p><strong>(2) 类型和安全检查不同</strong></p><blockquote><ul><li>define宏没有类型，不做任何类型检查，仅仅是展开。</li><li>const常量有具体的类型，在编译阶段会执行类型检查</li></ul></blockquote><p><strong>(3) 存储方式不同</strong></p><blockquote><ul><li>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，<strong>变量定义</strong>分配内存。）</li><li>const常量会在内存中分配(可以是堆中也可以是栈中)。</li></ul></blockquote><p><strong>(4)const  可以节省空间，避免不必要的内存分配</strong></p><p><strong>(5)提高了效率</strong></p><blockquote><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p></blockquote><p><font size="4" color="red">常量的存放位置：</font></p><blockquote><ul><li><strong>局部对象：</strong> 存放在栈区</li><li><strong>全局对象：</strong> 存放在全局/静态存储区</li><li><strong>字面值常量：</strong> 存放在常量存储区</li></ul></blockquote><p><font size="4" color="red">const修饰成员函数的目的：</font></p><blockquote><p>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p></blockquote><p><font size="4" color="red">如果同时定义了两个函数，一个带const，一个不带，会有问题吗</font></p><blockquote><p>不会，这相当于函数的重载。</p></blockquote><h4 id="2-1-3-volatile-易变的"><a href="#2-1-3-volatile-易变的" class="headerlink" title="2.1.3 volatile(易变的)"></a>2.1.3 volatile(易变的)</h4><p>​        volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。</p><h4 id="2-1-4-mutable"><a href="#2-1-4-mutable" class="headerlink" title="2.1.4 mutable"></a>2.1.4 mutable</h4><p>在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。</p><h4 id="2-1-5-override和final关键字"><a href="#2-1-5-override和final关键字" class="headerlink" title="2.1.5 override和final关键字"></a>2.1.5 override和final关键字</h4><blockquote><p>override确保在派生类中声明的重载函数跟基类的虚函数有相同的签名</p><p>final阻止类的进一步派生和虚函数的进一步重载</p></blockquote><h3 id="2-2-数组、引用与指针"><a href="#2-2-数组、引用与指针" class="headerlink" title="2.2 数组、引用与指针"></a>2.2 数组、引用与指针</h3><h4 id="2-2-1-数组和指针的区别"><a href="#2-2-1-数组和指针的区别" class="headerlink" title="2.2.1 数组和指针的区别"></a>2.2.1 数组和指针的区别</h4><p><strong>(1)含义上的区别</strong></p><blockquote><p>数组对应着一块内存区域，而指针是指向一块内存区域。其地址和容量在生命期里不会改变，只有数组的内容可以改变；而指针却不同，它指向的内存区域的大小可以随时改变，而且当指针指向常量字符串时，它的内容是不可以被修改的，否则在运行时会报错。</p></blockquote><p><strong>(2)计算内存容量的区别</strong></p><blockquote><p>用运算符sizeof可以计算出数组的容量（字节数），而用sizeof却无法计算指针所指内存的容量，用sizeof(p)得到的结果永远是4或者2（即指针变量所占内存单元的字节数，一般情况下指针变量占2个或4个字节的内存单元）。在进行参数传递时，数组会自动退化为同类型的指针。 </p></blockquote><h4 id="2-2-2-指针和引用的区别"><a href="#2-2-2-指针和引用的区别" class="headerlink" title="2.2.2 指针和引用的区别"></a>2.2.2 指针和引用的区别</h4><p><strong>(1) 相同点</strong></p><blockquote><p>都是地址的概念：指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。</p></blockquote><p><strong>(2)不同点</strong></p><blockquote><ul><li>指针是一个实体，而引用仅是个别名；</li><li>引用使用时无需解引用(*)，指针需要解引用；</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li><li>引用不能为空，指针可以为空；</li><li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；</li><li>指针和引用的自增(++)运算意义不一样；</li></ul></blockquote><h4 id="2-2-3-智能指针"><a href="#2-2-3-智能指针" class="headerlink" title="2.2.3 智能指针"></a>2.2.3 智能指针</h4><p><strong>(1)作用</strong></p><blockquote><p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p></blockquote><p><strong>(2) 分类</strong></p><blockquote><ul><li><strong>auto_ptr</strong>（c++98的方案，cpp11已经抛弃），采用所有权模式。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));auto_ptr<string> p2;p2 = p1; //auto_ptr不会报错.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p><ul><li><strong>unique_ptr</strong>（替换auto_ptr）</li></ul><p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。<strong>只能移动（std::move())，不能复制</strong></p><pre class="line-numbers language-c++"><code class="language-c++">unique_ptr<string> p3 (new string ("auto"));   //#4unique_ptr<string> p4；                       //#5p4 = p3;//此时会报错！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>shared_ptr</strong></li></ul><p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p><p>成员函数：</p><blockquote><ul><li>use_count 返回引用计数的个数</li><li>unique 返回是否是独占所有权( use_count 为 1)</li><li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li><li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li><li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li></ul></blockquote><ul><li><strong>weak_ptr</strong></li></ul><p><strong>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象.</strong>进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是<strong>用来解决shared_ptr相互引用时的死锁问题</strong>,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化,shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p><pre class="line-numbers language-c++"><code class="language-c++">class B;class A{public:    shared_ptr&lt;B&gt pb_;    ~A(){        cout<<"A delete\n";    }};class B{public:    shared_ptr&lt;A&gt; pb_;    ~B(){        cout<<"B delete\n";    }};void fun(){    shared_ptr&lt;B> pb(new B());    shared_ptr&lt;A> pa(new A());    pb->pa_ = pa;    pa->pb_ = pb;    cout&lt;&lt;pb.use_count()&lt;&lt;endl;    cout&lt;&lt;pa.use_count()&lt;&lt;endl;}int main(){    fun();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p><p><strong>注意：</strong>的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p></blockquote><p><strong>(3)智能指针中的内存泄露</strong></p><blockquote><ul><li><strong>原因</strong></li></ul><p>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p><ul><li><strong>解决方法</strong> </li></ul><p>weak_ptr还可以用来返回this指针和解决循环引用的问题。</p></blockquote><h4 id="2-2-4-野指针"><a href="#2-2-4-野指针" class="headerlink" title="2.2.4 野指针"></a>2.2.4 野指针</h4><blockquote><ul><li>野指针指向了一块没有访问权限的内存。（即指针没有初始化）</li><li>野指针指向了一个已经释放的内存</li></ul></blockquote><h4 id="2-2-5-左值引用与右值引用"><a href="#2-2-5-左值引用与右值引用" class="headerlink" title="2.2.5 左值引用与右值引用"></a>2.2.5 左值引用与右值引用</h4><ul><li>左值引用，也就是“常规引用”，不能绑定到要转换的表达式，字面常量，或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</li><li>右值引用就是必须绑定到右值的引用，通过&amp;&amp;获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</li></ul><blockquote><p>返回左值的表达式包括返回左值引用的函数及赋值，下标，解引用和前置递增/递减运算符，返回右值的包括返回非引用类型的函数及算术，关系，位和后置递增/递减运算符。</p><p>可以看到左值的特点是有持久的状态，而右值则是短暂的</p></blockquote><h3 id="2-3-类型转换"><a href="#2-3-类型转换" class="headerlink" title="2.3 类型转换"></a>2.3 类型转换</h3><h4 id="2-3-1-隐式类型转换"><a href="#2-3-1-隐式类型转换" class="headerlink" title="2.3.1 隐式类型转换"></a>2.3.1 隐式类型转换</h4><p>隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换。</p><blockquote><ul><li>对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换</li><li>对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</li></ul></blockquote><h4 id="2-3-2-显式类型转换"><a href="#2-3-2-显式类型转换" class="headerlink" title="2.3.2 显式类型转换"></a>2.3.2 显式类型转换</h4><p>（1）<strong>static_cast</strong> ：最常用的转换，<strong>但是转换的时候不会检查类型来保证转换的安全性</strong>。</p><p>static_cast本质上是传统c语言强制转换的替代品。static_cast不能转换掉expression的const、volitale、或者__unaligned属性。</p><p>（2）<strong>dynamic_cast转换：</strong>操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个0值，如果是转换的是引用，则抛出一个bad_cast异常，所以在使用dynamic_cast转换之间最好使用if语句对其转换成功与否进行测试。</p><blockquote><ul><li>T必须是类的指针、类的引用或者void。</li><li>dynamic_cast转换符只能用于含有虚函数的类。</li><li>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</li><li>在类层次间进行上行转换（子类-&gt;子类/基类）时，dynamic_cast和static_cast的效果是一样的；在进行下行转换（基类-&gt;子类）时，dynamic_cast具有类型检查的功能，比static_cast更安全。</li></ul></blockquote><p>（3）<strong>reinterpret_cast重述转换：</strong>此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。</p><p>（4）<strong>const_cast转换：</strong>主要是用来去掉const属性，当然也可以加上const属性。主要是用前者，后者很少用。</p><h3 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h3><h4 id="2-4-1-i和i-的区别"><a href="#2-4-1-i和i-的区别" class="headerlink" title="2.4.1 ++i和i++的区别"></a>2.4.1 ++i和i++的区别</h4><blockquote><ul><li>i++ 返回原来的值，++i 返回加1后的值。</li><li>i++ 不能作为左值，而++i 可以。</li></ul></blockquote><h4 id="2-4-2-C-存储方案：C-三种，C-11四种"><a href="#2-4-2-C-存储方案：C-三种，C-11四种" class="headerlink" title="2.4.2 C++存储方案：C++三种，C++11四种"></a>2.4.2 C++存储方案：C++三种，C++11四种</h4><p>这些方案的区别就在于数据保留在内存中的时间。</p><blockquote><p><strong>自动存储持续性：</strong>在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。 </p><p><strong>静态存储持续性：</strong>在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。 </p><p><strong>线程存储持续性（C++11）：</strong>当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。</p><p><strong>动态存储持续性：</strong>用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。</p></blockquote><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="3-1-静态函数和虚函数的区别"><a href="#3-1-静态函数和虚函数的区别" class="headerlink" title="3.1 静态函数和虚函数的区别"></a>3.1 静态函数和虚函数的区别</h3><blockquote><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。</p></blockquote><h3 id="3-2-函数的覆盖与重载"><a href="#3-2-函数的覆盖与重载" class="headerlink" title="3.2 函数的覆盖与重载"></a>3.2 函数的覆盖与重载</h3><blockquote><p><strong>重载：</strong>两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br><strong>重写：</strong>子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p></blockquote><h3 id="3-3-写个函数在main函数执行前先运行"><a href="#3-3-写个函数在main函数执行前先运行" class="headerlink" title="3.3 写个函数在main函数执行前先运行"></a>3.3 写个函数在main函数执行前先运行</h3><p>一个C++的程序，要先从main函数执行起，这是基本的编程常识，但是我们却可以在main函数执行之前先来执行一段代码，这是利用全局变量和构造函数的特性，再有全局变量的时候要先创建全局变量，然后在执行main函数.</p><pre class="line-numbers language-c++"><code class="language-c++">#include <Iostream>using namespace std;class TestClass{public:    TestClass();};TestClass::TestClass(){    cout << "TestClass" << endl;}TestClass Ts;//定义个全局变量，让类里面的代码在main之前执行int main(){    cout << "main" << endl;    int a;    cin >> a;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-请你来说一说C-函数栈空间的最大值"><a href="#3-4-请你来说一说C-函数栈空间的最大值" class="headerlink" title="3.4 请你来说一说C++函数栈空间的最大值"></a>3.4 请你来说一说C++函数栈空间的最大值</h3><blockquote><ul><li>在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在Window下，栈的大小是2MB，栈的大小一般小于2GB。</li><li>Linux下，默认栈空间大小为8MB，可通过ulimit -s来设置。</li></ul></blockquote><h3 id="3-5-C语言是怎么进行函数调用的？"><a href="#3-5-C语言是怎么进行函数调用的？" class="headerlink" title="3.5 C语言是怎么进行函数调用的？"></a>3.5 C语言是怎么进行函数调用的？</h3><blockquote><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p></blockquote><h3 id="3-6-请你说说C语言参数压栈顺序？"><a href="#3-6-请你说说C语言参数压栈顺序？" class="headerlink" title="3.6 请你说说C语言参数压栈顺序？"></a>3.6 请你说说C语言参数压栈顺序？</h3><blockquote><p>从右到左</p></blockquote><h3 id="3-7-请你说说C-如何处理返回值"><a href="#3-7-请你说说C-如何处理返回值" class="headerlink" title="3.7 请你说说C++如何处理返回值"></a>3.7 请你说说C++如何处理返回值</h3><blockquote><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p></blockquote><h3 id="3-8-strcpy和strlen"><a href="#3-8-strcpy和strlen" class="headerlink" title="3.8 strcpy和strlen"></a>3.8 strcpy和strlen</h3><blockquote><p>strcpy是字符串拷贝函数，原型：</p><pre class="line-numbers language-c++"><code class="language-c++">char *strcpy(char* dest, const char *src);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li><li>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</li></ul></blockquote><h3 id="3-9-fork、vfork、exec、wait"><a href="#3-9-fork、vfork、exec、wait" class="headerlink" title="3.9 fork、vfork、exec、wait"></a>3.9 fork、vfork、exec、wait</h3><p><strong>（1）fork</strong></p><p>fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p><p>为什么两个进程的fpid不同呢，这与fork函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>    1）在父进程中，fork返回新创建子进程的进程ID；<br>    2）在子进程中，fork返回0；<br>    3）如果出现错误，fork返回一个负值；</p><pre class="line-numbers language-c++"><code class="language-c++">#include <unistd.h>#include <stdio.h> int main () {     pid_t fpid; //fpid表示fork函数返回的值    int count=0;    fpid=fork();     if (fpid < 0)         printf("error in fork!");     else if (fpid == 0) {        printf("i am the child process, my process id is %d/n",getpid());         printf("我是爹的儿子/n");//对某些人来说中文看着更直白。        count++;    }    else {        printf("i am the parent process, my process id is %d/n",getpid());         printf("我是孩子他爹/n");        count++;    }    printf("统计结果是: %d/n",count);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）vfork</strong></p><p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p><p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了<strong>写时复制</strong>，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p><p><strong>注：写时复制</strong></p><p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p><p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。</p><p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p><p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p><p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p><p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p><p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p><p><strong>（3）fork和vfork的区别</strong></p><blockquote><ol><li>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</li><li>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</li><li>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</li><li>当需要改变共享数据段中变量的值，则拷贝父进程。</li></ol></blockquote><p><strong>（4）exec</strong></p><blockquote><ul><li>当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。</li><li>这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回，如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。</li></ul></blockquote><p><strong>（5）wait</strong></p><blockquote><ul><li>调用这两个函数的进程用这两个函数来等待其子进程状态的改变，并获取子进程所改变的信息。这里所指的状态的改变包括：子进程终止；子进程被一个信号终止来；子进程被一个信号恢复。对于一个已经终止的子进程，用wait能够让系统释放与子进程相关的资源；如果不用wait则终止的进程会变为僵尸进程。</li><li>一个进程在终止时会关闭所有文件描述符,释放在用户空间分配的内存,但它的PCB还保留着,内核在其中保存了一些信息:如果是正常终止则保存着退出状态,如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait 或waitpid获取这些信息,然后彻底清除掉这个进程。</li><li>如果子进程状态已经改变，那么wait调用会立即返回。否则调用wait的进程将会阻塞直到有子进程改变状态或者有信号来打断这个调用。</li></ul></blockquote><h3 id="3-10-select、poll、epoll——-IO多路复用技术"><a href="#3-10-select、poll、epoll——-IO多路复用技术" class="headerlink" title="3.10 select、poll、epoll——-IO多路复用技术"></a>3.10 select、poll、epoll——-IO多路复用技术</h3><p><strong>（1）select</strong></p><p><strong>原理</strong></p><blockquote><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p></blockquote><p><strong>优点</strong></p><blockquote><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点</p></blockquote><p><strong>缺点</strong></p><blockquote><ol><li>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</li><li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</li><li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ol></blockquote><p><strong>（2）poll</strong></p><p><strong>原理</strong></p><blockquote><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p></blockquote><p><strong>优点</strong></p><blockquote><p>它没有最大连接数的限制，原因是它是基于链表来存储的</p></blockquote><p><strong>缺点</strong></p><blockquote><ol><li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li><li>poll还有一个特点是“水平触发”`，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li></ol></blockquote><p><strong>（3）epoll</strong></p><p><strong>原理</strong></p><blockquote><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是。epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知.</p><p>调用顺序：</p><pre class="line-numbers language-c++"><code class="language-c++">int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表</p></blockquote><p><strong>优点</strong></p><blockquote><ol><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li></ol></blockquote><p><strong>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p><blockquote><ul><li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li><li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li></ul></blockquote><h3 id="3-11-函数指针"><a href="#3-11-函数指针" class="headerlink" title="3.11 函数指针"></a>3.11 函数指针</h3><p><strong>（1）普通函数指针</strong></p><blockquote><ol><li>typedef 定义可以简化函数指针的定义</li><li>函数指针同样是可以作为参数传递给函数的</li><li>利用函数指针，我们可以构成函数指针数组，更明确点的说法是构成指向函数的指针数组。</li></ol></blockquote><pre class="line-numbers language-c++"><code class="language-c++">int test(int a){    return a;}int main(int argc, const char * argv[]){    int (*fp)(int a);    fp = test;    cout<<fp(2)<<endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2)指向类成员函数的指针</strong></p><p><strong>定义：</strong>类成员函数指针（member function pointer），是 C++ 语言的一类指针数据类型，用于存储一个指定类具有给定的形参列表与返回值类型的成员函数的访问信息。</p><p>基本上要注意的有两点：</p><ul><li>1、函数指针赋值要使用 <strong>&amp;</strong></li><li>2、使用 <strong>.*</strong> (实例对象)或者 <strong>-&gt;*</strong>（实例对象指针）调用类成员函数指针所指向的函数</li></ul><p>1) 类成员函数指针指向类中的非静态成员函数</p><blockquote><ul><li>对于 <strong>nonstatic member function （非静态成员函数）</strong>取地址，获得该函数在内存中的实际地址</li><li>对于 <strong>virtual function（虚函数）</strong>, 其地址在编译时期是未知的，所以对于 virtual member function（虚成员函数）取其地址，所能获得的只是一个索引值，对于虚函数， 返回其在虚函数表的偏移位置</li></ul></blockquote><p>2) 类成员函数指针指向类中的静态成员函数</p><p><strong>总结：</strong></p><blockquote><ul><li>类成员函数指针与普通函数指针不是一码事。前者要用 <strong>.*</strong> 与 -<strong>&gt;*</strong> 运算符来使用，而后者可以用 <em><em>*</em></em> 运算符（称为”解引用”dereference，或称”间址”indirection）。</li><li>普通函数指针实际上保存的是函数体的开始地址，因此也称”代码指针”，以区别于 C/C++ 最常用的数据指针。</li><li>而类成员函数指针就不仅仅是类成员函数的内存起始地址，还需要能解决因为 C++ 的多重继承、虚继承而带来的类实例地址的调整问题，所以类成员函数指针在调用的时候一定要传入类实例对象。</li></ul></blockquote><h3 id="3-12-请你来说一说extern“C”"><a href="#3-12-请你来说一说extern“C”" class="headerlink" title="3.12 请你来说一说extern“C”"></a>3.12 请你来说一说extern“C”</h3><blockquote><ul><li>C++调用C函数需要extern C，因为C语言没有函数重载。</li><li>extern “C”指令中的C，表示的一种编译和连接规约，而不是一种语言。C表示符合C语言的编译和连接规约的任何语言，如Fortran、assembler等。</li><li>extern “C”的真实目的是实现<strong>类C和C++的混合编程</strong></li></ul></blockquote><h2 id="4-类"><a href="#4-类" class="headerlink" title="4 类"></a>4 类</h2><h3 id="4-1-c-和c的区别"><a href="#4-1-c-和c的区别" class="headerlink" title="4.1 c++和c的区别"></a>4.1 c++和c的区别</h3><blockquote><ol><li>兼容 C 语言的部分;</li><li>面向对象的 C++;</li><li>泛型编程，模板；</li><li>STL。</li></ol></blockquote><h3 id="4-2-析构函数的作用"><a href="#4-2-析构函数的作用" class="headerlink" title="4.2 析构函数的作用"></a>4.2 析构函数的作用</h3><blockquote><p>析构函数也是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用。析构函数是对类实例化出来的对象资源进行清理。</p></blockquote><h3 id="4-3-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#4-3-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="4.3 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数?"></a>4.3 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数?</h3><blockquote><ul><li>析构函数不一定必须是虚函数，是否为虚函数取决于该类的使用，一般该类为基类产生继承和多态时，才会是虚函数，单独使用可以不是虚函数。之所以在继承和多态时设计为虚函数是因为当new派生类并且用基类指针指向这个派生类，在销毁基类指针时只会调用基类的析构函数，不会调用派生类的析构函数，因为基类无法操作派生类中非继承的成员，这样就造成派生类只new无法delete造成内存泄露。</li><li>默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数</li></ul></blockquote><h3 id="4-4-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#4-4-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="4.4 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>4.4 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h3><blockquote><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p></blockquote><h3 id="4-5-请你说一说你理解的虚函数和多态"><a href="#4-5-请你说一说你理解的虚函数和多态" class="headerlink" title="4.5 请你说一说你理解的虚函数和多态"></a>4.5 请你说一说你理解的虚函数和多态</h3><blockquote><ul><li>C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。</li><li>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，动态绑定。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。</li></ul></blockquote><h3 id="4-6-虚函数表具体是怎样实现运行时多态的"><a href="#4-6-虚函数表具体是怎样实现运行时多态的" class="headerlink" title="4.6 虚函数表具体是怎样实现运行时多态的?"></a>4.6 虚函数表具体是怎样实现运行时多态的?</h3><blockquote><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p></blockquote><h3 id="4-7-请你说说你了解的RTTI（运行时类型识别）"><a href="#4-7-请你说说你了解的RTTI（运行时类型识别）" class="headerlink" title="4.7 请你说说你了解的RTTI（运行时类型识别）"></a>4.7 请你说说你了解的RTTI（运行时类型识别）</h3><p>通过RTTI，能够通过基类的指针或引用来检索其所指对象的实际类型。c++通过下面两个操作符提供RTTI。</p><p>（1）typeid：返回指针或引用所指对象的实际类型。</p><p>（2）dynamic_cast：将基类类型的指针或引用安全的转换为派生类型的指针或引用。</p><p>对于带虚函数的类，在运行时执行RTTI操作符，返回动态类型信息；对于其他类型，在编译时执行RTTI，返回静态类型信息。</p><blockquote><p>当具有基类的指针或引用，但需要执行派生类操作时，需要动态的强制类型转换（dynamic_cast）。这种机制的使用容易出错，最好以虚函数机制代替之。</p></blockquote><h3 id="4-8-请你来说一下C-中类成员的访问权限"><a href="#4-8-请你来说一下C-中类成员的访问权限" class="headerlink" title="4.8 请你来说一下C++中类成员的访问权限"></a>4.8 请你来说一下<strong>C</strong>++中类成员的访问权限</h3><blockquote><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p></blockquote><h3 id="4-9-请你来说一下C-中struct和class的区别"><a href="#4-9-请你来说一下C-中struct和class的区别" class="headerlink" title="4.9 请你来说一下C++中struct和class的区别"></a>4.9 请你来说一下C++中struct和class的区别</h3><blockquote><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</p></blockquote><h3 id="4-10-请你回答一下C-类内可以定义引用数据成员吗？"><a href="#4-10-请你回答一下C-类内可以定义引用数据成员吗？" class="headerlink" title="4.10 请你回答一下C++类内可以定义引用数据成员吗？"></a>4.10 请你回答一下C++类内可以定义引用数据成员吗？</h3><blockquote><p>可以，必须通过成员函数初始化，经过成员函数初始化和列表初始化是可以的</p></blockquote><h3 id="4-11-c-11-新特性"><a href="#4-11-c-11-新特性" class="headerlink" title="4.11 c++11 新特性"></a>4.11 c++11 新特性</h3><blockquote><ul><li>“语法糖”：<code>nullptr</code>, <code>auto</code>自动类型推导，范围for循环，初始化列表, lambda表达式等</li><li>右值引用和移动语义</li><li>智能指针</li><li>C++11多线程编程：<code>thread</code>库及其相配套的同步原语<code>mutex</code>, <code>lock_guard</code>, <code>condition_variable</code>, 以及异步<code>std::furture</code></li></ul></blockquote><h3 id="4-12-给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#4-12-给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="4.12 给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>4.12 给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h3><p>1、static修饰符</p><p>1）static修饰成员变量</p><blockquote><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</li><li>因为静态数据成员在<strong>全局数据区分配内存</strong>，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</li></ul></blockquote><p>2）static修饰成员函数</p><blockquote><ul><li>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它<strong>不具有this指针</strong>。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</li><li>Static修饰的成员函数，在<strong>代码区分配内存</strong>。</li></ul></blockquote><p>2、C++继承和虚函数</p><p>C++多态分为<strong>静态多态和动态多态</strong>。静态多态是通过<strong>重载和模板技术</strong>实现，在编译的时候确定。动态多态通过<strong>虚函数和继承关系</strong>来实现，执行动态绑定，在运行的时候确定。</p><p>动态多态实现有几个条件：</p><blockquote><p>(1) 虚函数；</p><p>(2) 一个基类的指针或引用指向派生类的对象；</p><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p><p><strong>虚函数表中为什么就能准确查找相应的函数指针呢？</strong></p><p>因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p></blockquote><p>3、virtual修饰符</p><blockquote><ul><li>类是局部变量：则该类数据存储在<strong>栈区</strong></li><li>类是通过new/malloc动态申请：则该类数据存储在<em>*堆区</em>。</li></ul></blockquote><p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</p><p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p><p><img src="/2019/10/06/mian-shi-c/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA.png" alt="img"></p><h3 id="4-13-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#4-13-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="4.13  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>4.13  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h3><blockquote><p>A* a = new A; a-&gt;i = 10：</p><p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p><p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p><p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p><p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p></blockquote><h2 id="5-内存管理"><a href="#5-内存管理" class="headerlink" title="5 内存管理"></a>5 内存管理</h2><h3 id="5-1-内存模型"><a href="#5-1-内存模型" class="headerlink" title="5.1 内存模型"></a>5.1 内存模型</h3><p><img src="/2019/10/06/mian-shi-c/311436_1552467921124_13956548C4BB199139A2744C39350272.png" alt="img"></p><p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p><p><strong>静态区域：</strong></p><blockquote><ul><li>text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li><li>data segment(数据段)：存储程序中已初始化的全局变量和静态变量</li><li>bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</li></ul></blockquote><p><strong>动态区域：</strong></p><blockquote><ul><li>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</li><li>memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</li><li>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</li></ul></blockquote><h3 id="5-2-new-delete与malloc-free的区别"><a href="#5-2-new-delete与malloc-free的区别" class="headerlink" title="5.2 new/delete与malloc/free的区别"></a>5.2 new/delete与malloc/free的区别</h3><blockquote><ul><li>new/delete是C++的关键字，而malloc/free是C语言的库函数</li><li>malloc后者使用必须指明申请内存空间的大小，返回的指针需要强转。</li><li>new会调用构造函数，不用指定内存大小，返回的指针不用强转。</li><li>new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会</li><li>new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</li></ul></blockquote><h3 id="5-3-malloc的原理，另外brk系统调用和mmap系统调用的作用"><a href="#5-3-malloc的原理，另外brk系统调用和mmap系统调用的作用" class="headerlink" title="5.3 malloc的原理，另外brk系统调用和mmap系统调用的作用"></a>5.3 malloc的原理，另外brk系统调用和mmap系统调用的作用</h3><blockquote><ul><li>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</li><li>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</li><li>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</li></ul></blockquote><h3 id="5-4-内存泄露"><a href="#5-4-内存泄露" class="headerlink" title="5.4 内存泄露"></a>5.4 内存泄露</h3><p><strong>（1）含义：</strong></p><blockquote><p>在编写应用程序的时候，程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针），虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用，我们说这块内存泄漏了，被泄漏的内存将在整个程序声明周期内都不可使用。</p></blockquote><p><strong>（2）原因</strong></p><blockquote><ul><li>是在使用new或malloc动态分配堆上的内存空间，而并未使用delete或free及时释放掉内存。</li><li>delete void * 的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露；</li><li>没有将基类的析构函数定义为虚函数，当基类的指针指向子类时，delete该对象时，不会调用子类的析构函数</li></ul></blockquote><p><strong>（3）分类</strong></p><blockquote><ul><li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li><li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li></ul></blockquote><p><strong>（4）检测</strong></p><blockquote><ul><li>思路就是重载 malloc/free，new/delete 在实际申请的每个内存块包一层，然后用一个链表他们链起来，调用一次 free 或者 delete ，就把改节点删除。程序运行结束后遍历链表就是内存泄露的部分。</li><li>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</li></ul></blockquote><h3 id="5-5-内存溢出"><a href="#5-5-内存溢出" class="headerlink" title="5.5 内存溢出"></a>5.5 内存溢出</h3><p><strong>（1）含义</strong></p><blockquote><p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</p></blockquote><p><strong>（2）原因</strong></p><blockquote><ul><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li><li>集合类中有对对象的引用，使用完后未清空，使得不能回收</li><li>代码中存在死循环或循环产生过多重复的对象实体</li><li>使用的第三方软件中的BUG</li><li>启动参数内存值设定的过小</li></ul></blockquote><h3 id="5-6-段错误"><a href="#5-6-段错误" class="headerlink" title="5.6 段错误"></a>5.6 段错误</h3><p><strong>（1）含义</strong></p><blockquote><p>段错误通常发生在访问非法内存地址的时候</p></blockquote><p><strong>（2）原因</strong></p><blockquote><ul><li>使用野指针</li><li>试图修改字符串常量的内容</li></ul></blockquote><h2 id="6-多线程"><a href="#6-多线程" class="headerlink" title="6 多线程"></a>6 多线程</h2><h3 id="6-1-C-的锁你知道几种"><a href="#6-1-C-的锁你知道几种" class="headerlink" title="6.1 C++的锁你知道几种?"></a>6.1 C++的锁你知道几种?</h3><p>线程之间的锁有：<strong>互斥锁、条件锁、自旋锁、读写锁、递归锁</strong>。一般而言，锁的功能越强大，性能就会越低。</p><blockquote><ol><li><strong>互斥锁</strong></li></ol><ul><li>互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。</li><li>在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以<strong>阻塞方式</strong>进行等待。</li></ul><ol start="2"><li><strong>条件锁</strong></li></ol><ul><li>条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于<strong>阻塞状态</strong>。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。</li></ul><ol start="3"><li><strong>自旋锁</strong></li></ol><ul><li>在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，<strong>在加锁时间短暂的环境下会极大的提高效率</strong>。但如果加锁时间过长，则会非常浪费CPU资源。</li></ul><ol start="4"><li><strong>读写锁</strong></li></ol><ul><li>分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。<strong>适用于读取数据的频率远远大于写数据的频率的场合。</strong></li></ul></blockquote><h3 id="6-2-说一说你用到的锁"><a href="#6-2-说一说你用到的锁" class="headerlink" title="6.2 说一说你用到的锁"></a>6.2 说一说你用到的锁</h3><blockquote><p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p></blockquote><h2 id="7-STL"><a href="#7-STL" class="headerlink" title="7 STL"></a>7 STL</h2><h3 id="7-1-STL的基本组成"><a href="#7-1-STL的基本组成" class="headerlink" title="7.1 STL的基本组成"></a>7.1 STL的基本组成</h3><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/SGISTL.PNG" alt></p><blockquote><ul><li><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/container" target="_blank" rel="noopener">Container</a> 通过 <a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/allocator" target="_blank" rel="noopener">Allocator</a> 取得数据储存空间</li><li><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/algorithm" target="_blank" rel="noopener">Algorithm</a> 通过 <a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/iterator" target="_blank" rel="noopener">Iterator</a> 存取 <a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/container" target="_blank" rel="noopener">Container</a> 内容</li><li><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/functor-function%20object" target="_blank" rel="noopener">Functor</a> 可以协助 <a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/algorithm" target="_blank" rel="noopener">Algorithm</a> 完成不同的策略变化</li><li><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/adapter" target="_blank" rel="noopener">Adapter</a> 可以修饰或套接 <a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/functor-function%20object" target="_blank" rel="noopener">Functor</a>、<a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3/iterator" target="_blank" rel="noopener">Iterator</a>。</li></ul></blockquote><h4 id="7-1-1-空间配置器-allocator"><a href="#7-1-1-空间配置器-allocator" class="headerlink" title="7.1.1 空间配置器(allocator)"></a>7.1.1 空间配置器(allocator)</h4><p>配置器：负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。</p><p>空间配置器：整个 STL 的操作对象(所有的数值)都存放在容器之内，而容器一定需要配置空间以存放内容。</p><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/allocator.PNG" alt></p><h5 id="（1）具有次配置力-sub-allocation-的-SGI-空间配置器"><a href="#（1）具有次配置力-sub-allocation-的-SGI-空间配置器" class="headerlink" title="（1）具有次配置力(sub-allocation)的 SGI 空间配置器"></a>（1）具有次配置力(sub-allocation)的 SGI 空间配置器</h5><h6 id="SGI-STL-空间配置器的结构"><a href="#SGI-STL-空间配置器的结构" class="headerlink" title="SGI STL 空间配置器的结构"></a>SGI STL 空间配置器的结构</h6><p>SGI STL 的配置器，其名称是 alloc 而不是 allocator，而且不接受任何参数。</p><p>SGI STL 的每一个容器都已经指定其缺省的空间配置器为 alloc。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 缺省使用 alloc 为配置器</span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>alloc<span class="token operator">></span> iv<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>&lt;defalloc.h&gt;—-SGI 标准的空间配置器，std::allocator</p><p>allocator 只是基层内存配置/释放行为(::operator::new 和 ::operator::delete)的一层薄薄的包装，并没有考虑到任何效率上的强化。</p></li><li><p>SGI 特殊的空间配置器，std::alloc</p><ul><li>&lt;stl_construct.h&gt;：定义了全局函数 construct() 和 destroy()，负责对象的构造和析构。 </li><li>&lt;stl_alloc.h&gt;：定义了一、二级配置器，配置器名为 alloc。</li><li>&lt;stl_uninitialized.h&gt;：定义了全局函数，用来填充(fill)或复制(copy)大块内存数据。</li></ul></li><li><p>构造和析构基本工具</p><p>具体看 &lt;stl_construct.h&gt; 源码，功能是构造和析构操作。</p></li><li><p>空间的配置和释放，std::alloc</p><ul><li>向 system heap 要求空间</li><li>考虑多线程(multi-threads)状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多 “小型区块” 可能造成的内存碎片问题</li></ul><p>对象构造前的空间配置 和 对象析构后的空间释放，具体看 &lt;stl_alloc.h&gt;。</p></li></ul><h6 id="SGI-STL-空间配置器的分析"><a href="#SGI-STL-空间配置器的分析" class="headerlink" title="SGI STL 空间配置器的分析"></a>SGI STL 空间配置器的分析</h6><p>考虑到小型区块可能造成内存碎片问题，SGI 采用两级配置器，第一级配置器直接使用 malloc() 和 free() 实现；第二级配置器使用 memory pool 内存池管理。</p><p>第二级配置器的原理：</p><ul><li>当配置区块超过 128 bytes，就使用第一级配置器</li><li>当配置区块小于 128 bytes，使用内存池管理</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>_ALIGN <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 小型区块的上调边界</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>_MAX_BYTES <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小区区块的上限</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>_NFREELISTS <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// _MAX_BYTES/_ALIGN  free-list 的个数</span><span class="token comment" spellcheck="true">// free-list 的节点结构，降低维护链表 list 带来的额外负担</span><span class="token keyword">union</span> _Obj <span class="token punctuation">{</span>    <span class="token keyword">union</span> _Obj<span class="token operator">*</span> _M_free_list_link<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 利用联合体特点</span>    <span class="token keyword">char</span> _M_client_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* The client sees this. */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> _Obj<span class="token operator">*</span> __STL_VOLATILE _S_free_list<span class="token punctuation">[</span>_NFREELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 注意，它是数组，每个数组元素包含若干相等的小额区块</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 free-list 是指针数组，16 个数组元素，就是 16 个 free-list，各自管理大小分别为 8， 16， 24， 32，…128 bytes(8 的倍数)的小额区块。</p><p>小额区块的结构体 <code>union _Obj</code> 使用链表连接起来。</p><p>配置器负责配置，同时也负责回收。</p><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/allocator_memorypool.PNG" alt></p><h5 id="（2）内存配置与释放过程"><a href="#（2）内存配置与释放过程" class="headerlink" title="（2）内存配置与释放过程"></a>（2）内存配置与释放过程</h5><p>new运算分两个阶段：</p><blockquote><p>(1)调用::operator new配置内存;</p><p>(2)调用对象构造函数构造对象内容</p></blockquote><p>delete运算分两个阶段：</p><blockquote><p>(1)调用对象析构函数；</p><p>(2)调用::operator delete释放内存</p></blockquote><p>为了精密分工，STL allocator将两个阶段操作区分开来：</p><blockquote><ul><li>内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</li></ul></blockquote><h4 id="7-1-2-迭代器-iterator"><a href="#7-1-2-迭代器-iterator" class="headerlink" title="7.1.2 迭代器(iterator)"></a>7.1.2 迭代器(iterator)</h4><p>迭代器：扮演容器与算法之间的桥梁，是所谓的 “泛型指针”，共有五种类型，以及其它衍生变化。从实现的角度来看，迭代器是一种将 <code>operator*</code>，<code>operator-&gt;</code>，<code>operator++</code>，<code>operator--</code> 等指针相关操作予以重载的 class template。 所有 STL 容器都附带有自己专属的迭代器。 native pointer 也是一种迭代器。</p><h5 id="（1）迭代器-iterator-是一种-smart-pointer"><a href="#（1）迭代器-iterator-是一种-smart-pointer" class="headerlink" title="（1）迭代器(iterator) 是一种 smart pointer"></a>（1）迭代器(iterator) 是一种 smart pointer</h5><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见的用途是 dereference 和 member access。迭代器最重要的就是对 <code>operator*</code> 和 <code>operator-&gt;</code>进行重载工作。</p><p>auto_ptr：用来包装原生指针(native pointer)的对象，在头文件 <memory> 中定义。</memory></p><p>为什么每一种 STL 容器都提供有专属迭代器的缘故。</p><p>主要是暴露太多细节，所以把迭代器的开发工作交给容器去完成，这样所有实现细节可以得到封装，不被使用者看到。</p><h5 id="（2）迭代器相应类型-associated-types"><a href="#（2）迭代器相应类型-associated-types" class="headerlink" title="（2）迭代器相应类型(associated types)"></a>（2）迭代器相应类型(associated types)</h5><p>迭代器所指对象的类型。</p><p>利用 function template 的参数推导机制，只能推导出参数的类型，无法推导出函数返回值类型。</p><p>迭代器相应类型有五种：</p><ul><li>value type</li><li>difference type</li><li>pointer</li><li>reference</li><li>iterator category</li></ul><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/iteratortraits.PNG" alt></p><h5 id="（3）Traits-编程技术"><a href="#（3）Traits-编程技术" class="headerlink" title="（3）Traits 编程技术"></a>（3）Traits 编程技术</h5><p>traits 意为 “特性”，扮演 “特性萃取机” 角色，萃取各个迭代器的特性(相应类型)。</p><p>template partial specialization 模板偏特化：针对 template 参数更进一步的条件限制所设计出来的一个特化版本，本身仍然是 template。</p><pre class="line-numbers language-cpp"><code class="language-cpp">tempalte<span class="token operator">&lt;</span><span class="token keyword">typename</span> I<span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>iterator_category  iterator_category<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>value_type  value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>difference_type  difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>pointer  pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>reference  reference<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器相应类型之一：value type</li></ul><p>value type 就是迭代器所指对象的类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>I<span class="token operator">></span><span class="token operator">::</span>value_type <span class="token function">func</span><span class="token punctuation">(</span>I ite<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">*</span>ite<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器相应类型之二：difference type</li></ul><p>difference type 用来表示两个迭代器之间的距离。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>I<span class="token operator">></span><span class="token operator">::</span>difference_type <span class="token function">cout</span><span class="token punctuation">(</span>I first<span class="token punctuation">,</span> I last<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>I<span class="token operator">></span><span class="token operator">::</span>difference_type n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> first <span class="token operator">!=</span> last<span class="token punctuation">;</span> <span class="token operator">++</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器相应类型之三：reference type</li></ul><p>在 c++ 中，函数如果要传回左值，都是以 by reference 的方式进行，所以如果 p 是一个迭代器，它的 value type 是 T ，那么<code>*p</code> 应该是T&amp; (即reference type)</p><ul><li><p>迭代器相应类型之四：pointer type</p></li><li><p>迭代器相应类型之五：iterator_category</p><ul><li>输入迭代器 (InputIterator) 是能从所指向元素读取的迭代器 (Iterator) 。输入迭代器 (InputIterator) 仅保证单趟算法的合法性。</li><li>输出迭代器 (OutputIterator) 是能写入所指元素的迭代器 (Iterator) 。</li><li>向前迭代器 (ForwardIterator) 是一种能从所指向元素读取数据的迭代器 (Iterator) 。</li><li>双向迭代器 (BidirectionalIterator) 是能双向移动（即自增与自减）的向前迭代器 (ForwardIterator) 。</li><li>随机访问迭代器 (RandomAccessIterator) 是能在常数时间内移动到指向任何元素的双向迭代器 (BidirectionalIterator) 。</li></ul></li><li><p>traits 本质是什么？  </p></li></ul><p>多一层间接性，换来灵活性。iterator_traits 负责萃取迭代器的特性，__type_traits 负责萃取类型的特性。</p><h4 id="7-1-3-容器-container"><a href="#7-1-3-容器-container" class="headerlink" title="7.1.3 容器(container)"></a>7.1.3 容器(container)</h4><p>容器：包括序列式容器和关联式容器；即各种数据结构，如 vector，list，deque，set，map 等用来存储数据；从实现的角度来看，STL 容器是一种 class template。</p><p>任何特定的数据结构都是为了实现某种特定的算法。</p><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/container.PNG" alt></p><h5 id="（1）序列式容器-sequence-container"><a href="#（1）序列式容器-sequence-container" class="headerlink" title="（1）序列式容器(sequence container)"></a>（1）序列式容器(sequence container)</h5><ul><li>array (C++ 提供，build-in)</li><li>vector</li><li>heap (内含一个 vector)</li><li>priority-queue (内含一个 heap)</li><li>list</li><li>slist (非标准)</li><li>deque</li><li>stack (内含一个 deque)  (adapter 配接器)</li><li>queue (内含一个 deque)  (adapter 配接器)</li></ul><p>怎么理解序列式容器，其中的元素都可序(ordered), 但未必有序(sorted)？</p><p>ordered 是容器集合被排序，可以使用指定的顺序去遍历集合。 sorted 是一个容器集合根据某些规则确定排序的。</p><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/sequencecontainer.PNG" alt></p><h5 id="（2）关联式容器-associative-container"><a href="#（2）关联式容器-associative-container" class="headerlink" title="（2）关联式容器(associative container)"></a>（2）关联式容器(associative container)</h5><ul><li>RB-tree (非公开)</li><li>set (内含一个 RB-tree)</li><li>map (内含一个 RB-tree)</li><li>multiset (内含一个 RB-tree)</li><li>multimap (内含一个 RB-tree)</li><li>hashtable (非标准)</li><li>hash_set (内含一个 hashtable)  (非标准)</li><li>hash_map (内含一个 hashtable)  (非标准)</li><li>hash_multiset (内含一个 hashtable)  (非标准)</li><li>hash_multimap (内含一个 hashtable)  (非标准)</li></ul><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/associativecontainer.PNG" alt></p><p>熟悉关联式容器，需要有 <a href="https://github.com/steveLauwh/Data-Structures-And-Algorithms/tree/master/Tree/RB-tree" target="_blank" rel="noopener">RB-tree</a>(红黑树原理) 和 <a href="https://github.com/steveLauwh/Data-Structures-And-Algorithms/tree/master/Hash%20Table" target="_blank" rel="noopener">hash table</a>(哈希表原理) 基础。</p><h4 id="7-1-4-算法-algorithm"><a href="#7-1-4-算法-algorithm" class="headerlink" title="7.1.4 算法(algorithm)"></a>7.1.4 算法(algorithm)</h4><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/STLAlgorithm.png" alt></p><p>算法：各种常用算法如 sort，search，copy，erase 等，从实现的角度来看，STL 算法是一种 function template。</p><p>所有泛型算法的前两个参数都是一对迭代器，STL 习惯使用前闭后开的区间，<code>[first, last)</code>。</p><p>最后一个元素的下一位置，称为 end()。</p><p>数值的传递由 pass-by-value 改为 pass-by-reference，好处是，在模板中，参数的类型可以任意，当对象一大，传递成本便会上升，所以用 pass-by-reference 可以节省空间。</p><h5 id="（1）数值算法-lt-stl-numeric-h-gt"><a href="#（1）数值算法-lt-stl-numeric-h-gt" class="headerlink" title="（1）数值算法 &lt;stl_numeric.h&gt;"></a>（1）数值算法 &lt;stl_numeric.h&gt;</h5><p>STL 将数值算法的内部实现放在 &lt;stl_numeric.h&gt; 中，用户调用数值算法的接口，需要包含 <numeric> 头文件。</numeric></p><blockquote><p><strong>元素累加 <code>accumulate</code></strong></p></blockquote><p>算法 <code>accumulate</code> 用来计算 init 和 <code>[first, last)</code> 内所有元素的总和。</p><blockquote><p><strong>相邻元素的差值 <code>adjacent_difference</code></strong></p></blockquote><p>算法 <code>adjacent_difference</code> 用来计算 <code>[first, last)</code> 中相邻元素的差值。</p><blockquote><p><strong>内积 <code>inner_product</code></strong></p></blockquote><p>算法 <code>inner_product</code> 计算 <code>[first1, last1)</code> 和 <code>[first2, first2 + (last1 - first1))</code> 的一般内积。 </p><blockquote><p><strong>局部求和 <code>partial_sum</code></strong></p></blockquote><p>算法 <code>partial_sum</code> 用来计算局部求和。</p><blockquote><p><strong>幂次方 <code>power</code></strong></p></blockquote><p>算法 <code>power</code> 用来计算某数的 n 幂次方。</p><blockquote><p><strong>递增 <code>iota</code></strong></p></blockquote><p>在某区间 <code>[first, last)</code> 填入某指定值 <code>value</code> 的递增序列。</p><h5 id="（2）基本算法-lt-stl-algobase-h-gt"><a href="#（2）基本算法-lt-stl-algobase-h-gt" class="headerlink" title="（2）基本算法 &lt;stl_algobase.h&gt;"></a>（2）基本算法 &lt;stl_algobase.h&gt;</h5><blockquote><p><strong>判断两个区间是否相等 <code>equal</code></strong></p></blockquote><p>如果两个序列在 <code>[first, last)</code> 区间内相等，<code>equal()</code> 返回 true。</p><p>注意，如果第二个序列的元素比较多，多出来的元素不予考虑，只要与第一个序列的元素相等，就返回 true。</p><blockquote><p><strong>改填元素 <code>fill</code></strong></p></blockquote><p>将 <code>[first, last)</code> 内的所有元素改填新值。</p><blockquote><p><strong>改填元素的值 n 次 <code>fill_n</code></strong></p></blockquote><p>将 <code>[first, last)</code> 内的前 n 个元素改填新值，返回的迭代器指向被填入的最后一个元素的下一位置。</p><blockquote><p><strong>元素互换 <code>iter_swap</code></strong></p></blockquote><p>将两个 Forwarditerators 所指的对象对调。</p><blockquote><p><strong>以字典顺序进行比较 <code>lexicographical_compare</code></strong></p></blockquote><p>以 “字典排列方式” 对两个序列 <code>[first1, last1)</code> 和 <code>[first2, last2)</code> 进行比较。</p><blockquote><p><strong>最大值 <code>max</code></strong></p></blockquote><p>取两个对象的较大值。</p><blockquote><p><strong>最小值 <code>min</code></strong></p></blockquote><p>取两个对象的最小值。</p><blockquote><p><strong>找出不匹配的点 <code>mismatch</code></strong></p></blockquote><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。</p><blockquote><p><strong>交换 <code>swap</code></strong></p></blockquote><p>该函数用来交换两个对象的内容。</p><blockquote><p><strong>复制 <code>copy</code></strong></p></blockquote><p><code>copy</code> 算法可将输入区间 <code>[first, last)</code> 内的元素复制到输出区间 <code>[result, result + (last-first))</code> 内。</p><blockquote><p><strong>逆向复制 <code>copy_backward</code></strong></p></blockquote><p>将 <code>[first, last)</code> 区间内的每一个元素，以逆行的方向复制到以 <code>result-1</code> 为起点，方向亦为逆行的区间上。</p><h5 id="（3）set-相关算法"><a href="#（3）set-相关算法" class="headerlink" title="（3）set 相关算法"></a>（3）set 相关算法</h5><ul><li>并集 <code>set_union</code></li></ul><p>算法 <code>set_union</code> 可构造 S1、S2 之并集(S1 U S2)，此集合内含 S1 或 S2 内的每一个元素。其中 S1、S2 及其并集都是以排序区间表示。</p><ul><li>交集 <code>set_intersection</code></li></ul><p>算法 <code>set_intersection</code> 可构造 S1、S2 之交集。</p><ul><li>差集 <code>set_difference</code></li></ul><p>算法 <code>set_difference</code> 可构造 S1、S2 之差集。此集合内含出现于 S1 但不出现于 S2 的每一个元素。</p><ul><li>对称差集 <code>set_symmetric_difference</code></li></ul><p>算法 <code>set_symmetric_difference</code> 可构造 S1、S2 之对称差集。此集合内容<code>出现于 S1 但不出现于 S2</code> 以及 <code>出现于 S2 但不出现 S1</code> 的每一个元素。</p><h5 id="（4）heap-算法"><a href="#（4）heap-算法" class="headerlink" title="（4）heap 算法"></a>（4）heap 算法</h5><p>头文件 &lt;stl_heap.h&gt;</p><ul><li>make_heap() 建堆</li><li>pop_heap() 从堆中取出一个元素</li><li>push_heap() 将一个元素推进堆内</li><li>sort_heap() 对堆排序</li></ul><h5 id="（5）-其它算法-lt-stl-algo-h-gt"><a href="#（5）-其它算法-lt-stl-algo-h-gt" class="headerlink" title="（5） 其它算法 &lt;stl_algo.h&gt;"></a>（5） 其它算法 &lt;stl_algo.h&gt;</h5><p>定义于 SGI &lt;stl_algo.h&gt; 内的所有算法。</p><blockquote><p><strong>查找相邻而重复的元素 <code>adjacent_find</code></strong></p></blockquote><p>对一个序列，查找相邻元素值相等的第一个元素。</p><blockquote><p><strong>计数 <code>count</code></strong> </p></blockquote><p>将 <code>[first, last)</code> 区间内的每一个元素拿来和指定值 <code>value</code> 比较，并返回与 <code>value</code> 相等的元素个数。</p><blockquote><p><strong>在特定条件下计数 <code>count_if</code></strong></p></blockquote><p>将指定操作(一个仿函数) pred 实施于 <code>[first, last)</code> 区间内的每一个元素身上，并将造成 pred 计算结果为 true 的所有元素的个数返回。</p><blockquote><p><strong>循环查找 <code>find</code></strong></p></blockquote><p>循环查找 <code>[first, last)</code> 内的所有元素，找出第一个匹配条件的，返回指向该元素的迭代器。</p><blockquote><p><strong>在特定条件下循环查找 <code>find_if</code></strong></p></blockquote><p>根据指定的 pred 运算条件，循环查找 <code>[first, last)</code> 内的所有元素，找出第一个令 pred 运算结果为 true，返回指向该元素的迭代器。</p><blockquote><p><strong>查找某个子序列的最后一次出现点 <code>find_end</code></strong></p></blockquote><p>在序列一 <code>[first, last)</code> 所涵盖的区间中，查找序列二 <code>[first, last)</code> 的最后一个出现点。</p><blockquote><p><strong>查找某些元素的第一次出现点 <code>find_first_of</code></strong></p></blockquote><p>本算法以 <code>[first2, last2)</code> 区间内的某些元素作为查找目标，寻找在 <code>[first1, last1)</code> 区间内的第一次出现地点。</p><blockquote><p><strong>对区间内的每一个元素进行某操作 <code>for_each</code></strong></p></blockquote><p>将仿函数 f 作用于 <code>[first, last)</code> 区间内的每一个元素上。</p><blockquote><p><strong>以特定操作之运算结果填充特定区间内的元素 <code>generate</code></strong></p></blockquote><p>将仿函数 gen 的运算结果赋值给 <code>[first, last)</code> 区间内的所有元素上。 </p><blockquote><p><strong>以特定操作之运算结果填充 n 个元素内容 <code>generate_n</code></strong></p></blockquote><p>将仿函数 gen 的运算结果填写在从迭代器 first 开发的 n 个元素身上。</p><blockquote><p><strong>应用于有序区间 <code>includes</code></strong></p></blockquote><p>S1 和 S2 必须是有序集合，其中的元素可以重复，判断 S1 是否包含于 S2。includes 算法可供用户选择采用 less 或 greater 进行两元素的大小比较。</p><blockquote><p><strong>最大值所在位置 <code>max_element</code></strong></p></blockquote><p>这个算法返回一个迭代器，指向序列之中数值最大的元素。</p><blockquote><p><strong>应用于有序区间的合并操作 <code>merge</code></strong></p></blockquote><p>将两个经过排序的集合 S1 和 S2，合并起来置于另一段空间。所得结果也是一个有序序列。</p><blockquote><p><strong>最小值所在位置 <code>min_element</code></strong></p></blockquote><p>这个算法返回一个迭代器，指向序列之中数值最小的元素。</p><blockquote><p><strong>分割 <code>partition</code></strong></p></blockquote><p><code>partition</code> 将区间 <code>[first, last)</code> 中的元素重新排列。所有被一元条件运算 <code>pred</code> 判定为 true 的元素，都会被放在区间的前段，被判定为 false 的元素，都会被放在区间的后段。</p><p>如果需要保留原始相对位置，应使用 <code>stable_partition</code>。</p><blockquote><p><strong>移除并不删除 <code>remove</code></strong></p></blockquote><p>移除 <code>[first, last)</code> 之中所有与 value 相等的元素，这一算法并不真正从容器中删除那些元素，而是将每一个不与 value 相等的元素轮番赋值给 first 之后的空间。</p><blockquote><p><strong>移除某类元素并将结果复制到另一容器 <code>remove_copy</code></strong></p></blockquote><p>移除 <code>[first, last)</code> 之中所有与 value 相等的元素。它并不真正从容器中删除那些元素，而是将结果复制到一个以 result 标示起始位置的容器身上。</p><blockquote><p><strong>有条件地删除某类元素 <code>remove_if</code></strong></p></blockquote><p>移除 <code>[first, last)</code> 区间内所有被仿函数 pred 认定为 true 的元素，每一个不符合 pred 条件的元素都会被轮番赋值给 first 之后的空间。</p><blockquote><p><strong>有条件地删除某类元素并将结果复制到另一容器 <code>remove_copy_if</code></strong></p></blockquote><p>移除 <code>[first, last)</code> 区间内所有被仿函数 pred 认定为 true 的元素，它并不真正从容器中删除那些元素，而是将结果复制到一个以 result 标示起始位置的容器身上。</p><blockquote><p><strong>替换某类元素 <code>replace</code></strong></p></blockquote><p>将 <code>[first, last)</code> 区间内的所有 old_value 都以 new_value 取代。</p><blockquote><p><strong>替换某类元素，并将结果复制到另一个容器 <code>repalce_copy</code></strong></p></blockquote><p>唯一不同的是新序列会被复制到 result 所指的容器中。</p><blockquote><p><strong>有条件地替换 <code>replace_if</code></strong></p></blockquote><p>将 <code>[first, last)</code> 区间内的所有被 pred 评估为 true 的元素，都以 new_value 取而代之。</p><blockquote><p><strong>有条件地替换，并将结果复制到另一个容器 <code>replace_copy_if</code></strong></p></blockquote><p>行为与 <code>replace_if()</code> 类似，新序列会被复制到 result 所指的区间内。</p><blockquote><p><strong>反转元素次序 <code>reverse</code></strong></p></blockquote><p>将序列 <code>[first, last)</code> 的元素在原容器中颠倒重排。</p><blockquote><p><strong>反转元素次序并将结果复制到另一个容器 <code>reverse_copy</code></strong></p></blockquote><p>行为与 <code>reverse()</code> 类似，新序列会被复制到 result 所指的容器中。</p><blockquote><p><strong>旋转 <code>rotate</code></strong></p></blockquote><p>将 <code>[first, middle)</code> 内的元素和 <code>[middle, last)</code> 内的元素互换，middle 所指的元素会成为容器的第一个元素。</p><blockquote><p><strong>旋转，并将结果复制到另一个容器 <code>rotate_copy</code></strong></p></blockquote><p>行为与 <code>rotate_copy()</code> 类似，新序列会被复制到 result 所指的容器中。</p><blockquote><p><strong>查找某个子序列 <code>search</code></strong></p></blockquote><p>在序列一 <code>[first1, last1)</code> 所涵盖的区间中，查找序列二 <code>[first2, last2)</code> 的首次出现点。</p><blockquote><p><strong>查找连续发生 n 次的子序列 <code>search_n</code></strong></p></blockquote><p>在序列 <code>[first, last)</code> 所涵盖的区间中，查找连续 count 个符合条件之元素所形成的子序列，并返回一个迭代器指向该子序列起始处。</p><blockquote><p><strong>指定区间交换 <code>swap_ranges</code></strong></p></blockquote><p>将 <code>[first1, last1)</code> 区间内的元素与从 first2 开始、个数相同的元素互相交换。这两个序列可位于同一容器中，也可位于不同的容器中。</p><blockquote><p><strong>以两个序列为基础，交互作用产生第三个序列 <code>transform</code></strong></p></blockquote><p>transform() 两个版本都执行结果放进迭代器 result 所标示的容器中。</p><blockquote><p><strong>将重复的元素删除，只保留一个 <code>unique</code></strong></p></blockquote><p>算法 unique 能够移除重复的元素。每当在 <code>[first, last)</code> 内遇到重复元素群，它便移除该元素群中第一个以后的所有元素。</p><blockquote><p><strong>将重复的元素删除，只保留一个， 并复制 result 中<code>unique_copy</code></strong></p></blockquote><p>算法 unique_copy 可从 <code>[first, last)</code> 中将元素复制到以 result 开头的区间上。</p><blockquote><p><strong>lower_bound (应用于有序区间)</strong></p></blockquote><p>二分查找，在已排序的 <code>[first, last)</code> 中的寻找元素 value，返回位置。</p><blockquote><p><strong>upper_bound (应用于有序空间)</strong></p></blockquote><p>二分查找，在已排序的 <code>[first, last)</code> 中的寻找元素 value，与 <code>lower_bound</code> 区别是返回查找值的位置。</p><blockquote><p><strong>二分查找 <code>binary_search (应用于有序空间)</code></strong></p></blockquote><p>二分查找法，在已排序的 <code>[first, last)</code> 中的寻找元素 value，查找到，返回 true，否则 false。</p><blockquote><p><strong>求下一个排列组合 <code>next_permutation</code></strong></p></blockquote><p><code>next_permutation()</code> 获取 <code>[first, last)</code> 所标示之序列的下一个排列组合。</p><p>实现原理：</p><p>在当前序列中，从尾端往前寻找两个相邻元素，前一个记为 <code>*i</code>，后一个记为 <code>*ii</code>，并且满足 <code>*i &lt; *ii</code>。然后再从尾端寻找另一个元素 <code>*j</code>，如果满足 <code>*i &lt; *j</code>，即将第 i 个元素与第 j 个元素对调，并将第 ii 个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。</p><blockquote><p><strong>求上一个排列组合 <code>prev_permutation</code></strong></p></blockquote><p><code>prev_permutation()</code> 获取 <code>[first, last)</code> 所标示之序列的上一个排列组合。</p><p>实现原理：</p><p>在当前序列中，从尾端往前寻找两个相邻元素，前一个记为 <code>*i</code>，后一个记为 <code>*ii</code>，并且满足 <code>*i &gt; *ii</code>。然后再从尾端寻找另一个元素 <code>*j</code>，如果满足 <code>*i &gt; *j</code>，即将第 i 个元素与第 j 个元素对调，并将第 ii 个元素之后（包括ii）的所有元素颠倒排序，即求出上一个序列了。</p><blockquote><p><strong>随机重排元素 <code>random-shuffle</code></strong></p></blockquote><p>这个算法将 <code>[first, last)</code> 的元素次序随机重排, 在 N！种可能的元素排列顺序中随机选出一种，此处 N 为 last-first。</p><blockquote><p><strong>局部排序 <code>partial_sort/partial_sort_copy</code></strong></p></blockquote><p>本算法接受一个 middle 迭代器(位于序列 <code>[first, last) 之内</code>)，然后重新安排 <code>[first, last)</code>，使序列中的 middle-first 个最小元素以递增顺序排序，置于 <code>[first, middle)</code>内。其余 <code>last-middle</code> 个元素安置于 <code>[middle, last)</code> 中，不保证有任何特定顺序。</p><blockquote><p><strong>排序算法 sort</strong></p></blockquote><p>STL 的 sort 算法，数据量大时采用 Quick Sort，分段递归排序，当数据量小于某个门槛(5-20)，就改用 Insertion Sort。</p><p><strong>Insertion Sort</strong></p><p>插入排序是以双层循环的形式进行。时间复杂度为 O(N^2)。</p><p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p><p><strong>Quick Sort</strong></p><p>平均时间复杂度为 O(NlogN)，最坏情况下将达 O(N^2)。</p><p>STL 早期采用 Quick Sort，现在 SGI STL 改用 IntroSort(极类似 median-of-three QuickSort 的一种排序算法)。</p><p>递归</p><p>Median-of-Three(三点中值) 中间值</p><p>Partitioning 分割</p><p><strong>SGI STL sort</strong></p><p>混合式排序算法，Introspective Sorting，当做 Partitioning 操作，有恶化为二次行为的倾向时，改用 Heap Sort，使其效率维持在 Heap Sort 的 O(NlogN)。</p><p>用 __lg() 控制分割恶化的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 找出 2^k &lt;= n 的最大值 k</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">size</span><span class="token operator">></span><span class="token keyword">inline</span> Size <span class="token function">__lg</span><span class="token punctuation">(</span>Size n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Size k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token operator">++</span>k<span class="token punctuation">;</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最多允许分割 2k 层；</p><p>混合式排序思想：</p><ul><li>先判断序列大小，当大于阈值 <code>__stl_threshold(16)</code>，再检查分割层次，如果分割层次超过指定值 0，就改用 Heap Sort完成；</li><li>在大于阈值 <code>__stl_threshold(16)</code>，分割层次不为 0，就继续使用 Quick Sort；</li><li>如果小于阈值，则用插入排序；</li></ul><blockquote><p><strong>equal_range(应用于有序区间)</strong></p></blockquote><p>算法 <code>equal_range</code> 是二分查找法的一个版本，试图在已排序的 <code>[first, last)</code> 中寻找 value。</p><p>返回一个上下区间。</p><blockquote><p><strong>inplace_merge(应用于有序区间)</strong></p></blockquote><p>合并 并且 就地排序</p><blockquote><p><strong>nth_element</strong></p></blockquote><p>使第 n 大元素处于第 n 位置（从0开始,其位置是下标为 n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的。</p><blockquote><p><strong>归并排序 merge sort</strong></p></blockquote><p>Merge Sort 的复杂度为 O(NlogN)。需要借用额外的内存。底层是调用 <code>inplace_merge</code> 实现。</p><h4 id="7-1-5-仿函数-函数对象-functor-function-object"><a href="#7-1-5-仿函数-函数对象-functor-function-object" class="headerlink" title="7.1.5 仿函数/函数对象(functor/function object)"></a>7.1.5 仿函数/函数对象(functor/function object)</h4><p>仿函数/函数对象：行为类似函数，可作为算法的某种策略，从实现的角度来看，仿函数是一种重载了 operator() 的 class 或 class template。</p><p>STL 仿函数应该有能力被函数配接器(function adapter)修饰，为了拥有配接能力，每一个仿函数必须定义自己的相应类型。</p><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/functionobject.png" alt></p><h5 id="（1）以操作数的个数划分，可分为一元和二元仿函数"><a href="#（1）以操作数的个数划分，可分为一元和二元仿函数" class="headerlink" title="（1）以操作数的个数划分，可分为一元和二元仿函数"></a>（1）以操作数的个数划分，可分为一元和二元仿函数</h5><ul><li><code>unary_function</code></li></ul><p><code>unary_function</code> 用来呈现一元函数的参数类型和返回值类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 一元函数的参数类型和返回值类型</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Arg</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Result</span><span class="token operator">></span><span class="token keyword">struct</span> unary_function <span class="token punctuation">{</span>  <span class="token keyword">typedef</span> _Arg argument_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Result result_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>binary_function</code></li></ul><p><code>binary_function</code> 用来呈现二元函数的第一参数类型、第二参数类型，以及返回值类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 二元函数的第一个参数类型和第二个参数类型，以及返回值类型</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Arg1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Arg2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Result</span><span class="token operator">></span><span class="token keyword">struct</span> binary_function <span class="token punctuation">{</span>  <span class="token keyword">typedef</span> _Arg1 first_argument_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Arg2 second_argument_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Result result_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="（2）功能划分"><a href="#（2）功能划分" class="headerlink" title="（2）功能划分"></a>（2）功能划分</h5><blockquote><p>算法类(Arithmetic)仿函数</p></blockquote><p>STL 内建的 “算术类仿函数”，支持加法、减法、乘法、除法、模数和求反运算符。</p><blockquote><p>关系运算类(Relational)仿函数</p></blockquote><p>STL 内建的 “关系运算类仿函数” 支持等于、不等于、大于、大于等于、小于、小于等于六种运算。</p><blockquote><p>逻辑运算类(Logical)仿函数</p></blockquote><p>STL 内建的 “逻辑运算类仿函数” 支持了逻辑运算种的 And、Or、Not 三种运算。</p><blockquote><p>identity、select、project</p></blockquote><p>将其参数原封不动地传回。为了间接性——间接性是抽象化的重要工具。</p><h4 id="7-1-6-适配器-adapter"><a href="#7-1-6-适配器-adapter" class="headerlink" title="7.1.6 适配器(adapter)"></a>7.1.6 适配器(adapter)</h4><p>适配器：一种用来修饰容器、仿函数或迭代器接口的东西。例如，STL 提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器适配器，因为它们的底部完全借助 deque，所有操作都由底层的 deque 供应。改变 functor 接口者，称为 function adapter等。</p><p>适配器(adapter) 在 STL 组件的灵活组合运用功能上，扮演者转换器的角色。</p><p><img src="https://github.com/steveLauwh/SGI-STL/raw/master/The%20Annotated%20STL%20Sources%20V3.3/Other/adapter.PNG" alt></p><h5 id="（1）应用于容器，container-adapter"><a href="#（1）应用于容器，container-adapter" class="headerlink" title="（1）应用于容器，container adapter"></a>（1）应用于容器，container adapter</h5><p>STL 提供的两个容器 queue 和 stack，它们修饰 deque 的接口而形成的。</p><h5 id="（2）应用于迭代器，iterator-adapter"><a href="#（2）应用于迭代器，iterator-adapter" class="headerlink" title="（2）应用于迭代器，iterator adapter"></a>（2）应用于迭代器，iterator adapter</h5><p>STL 提供了许多应用于迭代器的适配器。</p><blockquote><p>insert iterator</p></blockquote><p>插入迭代器内部都维护有一个容器，容器当然有自己的迭代器，当客户端对插入迭代器做赋值操作时，就在插入迭代器中被转为对该容器的迭代器做插入操作。</p><p><code>back_insert_iterator</code></p><p>用于在容器尾部插入的迭代器适配器。</p><p><code>front_insert_iterator</code></p><p>用于在容器头部插入的迭代器适配器。</p><blockquote><p>reverse iterator</p></blockquote><p>将迭代器的移动行为倒转。以尾到头的方向来处理序列中的元素。</p><blockquote><p>stream iterator</p></blockquote><p>将迭代器绑定到一个 stream 对象身上，绑定到 istream 对象为 istream_iterator，拥有输入能力。</p><p>绑定到 ostream 对象为 ostream_iterator，拥有输出能力。</p><h5 id="（3）应用于仿函数，function-adapter"><a href="#（3）应用于仿函数，function-adapter" class="headerlink" title="（3）应用于仿函数，function adapter"></a>（3）应用于仿函数，function adapter</h5><blockquote><p>对返回值进行逻辑否定：not1, not2</p></blockquote><blockquote><p>对参数进行绑定：bind1st, bind2nd</p></blockquote><blockquote><p>用于函数合成：compose1, compose2</p></blockquote><blockquote><p>用于函数指针：ptr_fun</p></blockquote><blockquote><p>用于成员函数指针：mem_fun, mem_fun_ref</p></blockquote><h3 id="7-2-问题"><a href="#7-2-问题" class="headerlink" title="7.2 问题"></a>7.2 问题</h3><h4 id="7-2-1-请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#7-2-1-请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="7.2.1 请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>7.2.1 请你来说一下map和set有什么区别，分别又是怎么实现的？</h4><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p><p>map和set区别在于：</p><p>（1）<strong>map中的元素是key-value（关键字—值）对</strong>：关键字起到索引的作用，值则表示与索引相关联的数据；<strong>Set与之相对就是关键字的简单集合</strong>，set中每个元素只包含一个关键字。</p><p>（2）<strong>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。</strong>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p><p>（3）<strong>map支持下标操作，set不支持下标操作。</strong>map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p><h4 id="7-2-2-请你来说一说STL迭代器删除元素"><a href="#7-2-2-请你来说一说STL迭代器删除元素" class="headerlink" title="7.2.2 请你来说一说STL迭代器删除元素"></a>7.2.2 请你来说一说STL迭代器删除元素</h4><blockquote><p>（1）对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入，删除一个结点不会对其他结点造成影响。使用方式如下例子：</p><pre class="line-numbers language-c++"><code class="language-c++">set<int> valset = { 1,2,3,4,5,6 };set<int>::iterator iter;for (iter = valset.begin(); iter != valset.end(); ){  if (3 == *iter)       valset.erase(iter++);  else       ++iter;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为传给erase的是iter的一个副本，iter++是下一个有效的迭代器。</p><p>（2）对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator。使用方式如下,例如：</p><pre class="line-numbers language-c++"><code class="language-c++">vector<int> val = { 1,2,3,4,5,6 };vector<int>::iterator iter;for (iter = val.begin(); iter != val.end(); ){  if (3 == *iter)       iter = val.erase(iter);     //返回下一个有效的迭代器，无需+1  else       ++iter;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</p></blockquote><h4 id="7-2-3-请你讲讲STL有什么基本组成"><a href="#7-2-3-请你讲讲STL有什么基本组成" class="headerlink" title="7.2.3 请你讲讲STL有什么基本组成"></a>7.2.3 请你讲讲STL有什么基本组成</h4><blockquote><p>容器、迭代器、仿函数、算法、分配器、配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p></blockquote><h4 id="7-2-4-请你说说STL中map与unordered-map"><a href="#7-2-4-请你说说STL中map与unordered-map" class="headerlink" title="7.2.4 请你说说STL中map与unordered_map"></a>7.2.4 请你说说STL中map与unordered_map</h4><p>（1）map</p><blockquote><p>Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p><p>底层实现：红黑树</p><p>适用场景：有序键值对不重复映射</p></blockquote><p>（2）Multimap</p><blockquote><p>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p><p>底层实现：红黑树</p><p>适用场景：有序键值对可重复映射</p></blockquote><h4 id="7-2-5-请你说一说vector和list的区别，应用，越详细越好"><a href="#7-2-5-请你说一说vector和list的区别，应用，越详细越好" class="headerlink" title="7.2.5 请你说一说vector和list的区别，应用，越详细越好"></a>7.2.5 请你说一说vector和list的区别，应用，越详细越好</h4><p>1、概念：</p><blockquote><p>1）Vector</p><ul><li>连续存储的容器，动态数组，在堆上分配空间</li><li>底层实现：数组</li><li>两倍容量增长：vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</li><li>性能：</li><li>访问：O(1)</li><li>插入：在最后插入（空间够）：很快</li><li>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</li><li>在中间插入（空间够）：内存拷贝</li><li>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</li><li>删除：在最后删除：很快</li><li>在中间删除：内存拷贝</li><li>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</li></ul></blockquote><blockquote><p>2) List</p><ul><li>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</li><li>底层：双向链表</li><li>性能：</li><li>访问：随机访问性能很差，只能快速访问头尾节点。</li><li>插入：很快，一般是常数开销</li><li>删除：很快，一般是常数开销</li><li>适用场景：经常插入删除大量数据</li></ul></blockquote><p>2、区别：</p><blockquote><ul><li>vector底层实现是数组；list是双向 链表。</li><li>vector支持随机访问，list不支持。</li><li>vector是顺序内存，list不是。</li><li>vector在中间节点进行插入删除会导致内存拷贝，list不会。</li><li>vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</li><li>vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</li></ul></blockquote><p>3、应用</p><blockquote><ul><li>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</li><li>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</li></ul></blockquote><h4 id="7-2-6-请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#7-2-6-请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="7.2.6 请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>7.2.6 请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h4><p>1、迭代器</p><blockquote><p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p><p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p></blockquote><p>2、迭代器和指针的区别</p><blockquote><p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、<em>、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</em></p><p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p></blockquote><p>3、迭代器产生原因</p><blockquote><p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p></blockquote><h4 id="7-2-7-请你回答一下STL里resize和reserve的区别"><a href="#7-2-7-请你回答一下STL里resize和reserve的区别" class="headerlink" title="7.2.7 请你回答一下STL里resize和reserve的区别"></a>7.2.7 请你回答一下STL里resize和reserve的区别</h4><blockquote><ul><li>resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1</int></li><li>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</li></ul></blockquote><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <vector>using namespace std;int main() {    vector<int> a;    a.reserve(100);    a.resize(50);    cout<<a.size()<<"  "<<a.capacity()<<endl;        //50  100    a.resize(150);    cout<<a.size()<<"  "<<a.capacity()<<endl;        //150  200    a.reserve(50);    cout<<a.size()<<"  "<<a.capacity()<<endl;        //150  200    a.resize(50);    cout<<a.size()<<"  "<<a.capacity()<<endl;        //50  200    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-8-请你说一说C-STL-的内存优化"><a href="#7-2-8-请你说一说C-STL-的内存优化" class="headerlink" title="7.2.8 请你说一说C++ STL 的内存优化"></a>7.2.8 请你说一说C++ STL 的内存优化</h4><p>二级分配机制 第一级，大于128bytes时，直接调用malloc申请内存； 第二级，小于128bytes时，维护一个大小为16的链表数组组成的内存池，内存大小分别为8、16….128bytes。根据输入大小，向上取8的整数倍，在相应链表元素中寻找，若元素为空（说明被占用），则调用refill函数，申请最多20个内存块。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-操作系统</title>
      <link href="/2019/10/06/mian-shi-cao-zuo-xi-tong/"/>
      <url>/2019/10/06/mian-shi-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h3><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.jpg" alt="进程管理"></p><h4 id="1-1-进程与线程"><a href="#1-1-进程与线程" class="headerlink" title="1.1 进程与线程"></a>1.1 进程与线程</h4><h5 id="（1）进程与线程的概念"><a href="#（1）进程与线程的概念" class="headerlink" title="（1）进程与线程的概念"></a>（1）进程与线程的概念</h5><blockquote><ul><li><strong>进程</strong>是对运行时程序的封装，是系统进行<strong>资源调度和分配的的基本单位</strong>，实现了操作系统的并发；</li><li><strong>线程</strong>是进程的子任务，是<strong>CPU调度和分派的基本单位</strong>，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li></ul></blockquote><h5 id="（2）进程与线程的区别"><a href="#（2）进程与线程的区别" class="headerlink" title="（2）进程与线程的区别"></a>（2）进程与线程的区别</h5><blockquote><ol><li><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位；</strong></li><li><strong>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</strong></li><li><strong>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</strong>（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</li><li>系统开销： <strong>进程切换的开销也远大于线程切换的开销。</strong>由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。</li><li>通信：<strong>由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。</strong></li><li><strong>进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</strong></li><li><strong>进程适应于多核、多机分布；线程适用于多核</strong></li></ol></blockquote><h5 id="（3）进程与线程的通信方式："><a href="#（3）进程与线程的通信方式：" class="headerlink" title="（3）进程与线程的通信方式："></a>（3）进程与线程的通信方式：</h5><p><strong>进程通信方式：管道、消息队列、信号量、信号、共享内存、socket</strong></p><blockquote><ol><li><strong>管道：</strong> 管道主要包括无名管道和命名管道</li></ol><ul><li>普通管道PIPE：管道可用于具有亲缘关系的父子进程间的通信</li></ul><blockquote><p>1) 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>2) 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></blockquote><ul><li>命名管道FIFO：有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</li></ul><blockquote><p>1)FIFO可以在无关的进程之间交换数据</p><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></blockquote><ol start="2"><li><strong>消息队列：</strong> 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息</li><li><strong>信号量：</strong> 信号量（semaphore）是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li><li><strong>信号signal：</strong>  信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li><strong>共享内存（Shared Memory）：</strong> 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</li><li><strong>套接字SOCKET：</strong> socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</li></ol></blockquote><p><strong>线程间的通信方式：临界区、互斥量、信号量、事件</strong> </p><blockquote><ol><li><strong>临界区：</strong>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</li><li><strong>互斥量Synchronized/Lock：</strong>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li><li><strong>信号量Semphare：</strong>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</li><li><strong>事件(信号)，Wait/Notify：</strong>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ol></blockquote><h5 id="（4）多线程和多进程的不同"><a href="#（4）多线程和多进程的不同" class="headerlink" title="（4）多线程和多进程的不同"></a>（4）多线程和多进程的不同</h5><blockquote><ul><li>进程是资源分配的最小单位，而线程时CPU调度的最小单位。</li><li>多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，多线程模型主要优势为线程间切换代价较小，因此适用于<strong>I/O密集型的工作场景</strong>，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于<strong>单机多核分布式场景</strong>。但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。</li><li>而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于<strong>多核、多机分布</strong>，多进程模型，适用于<strong>CPU密集型</strong>。同时，多进程模型也适用于多机<strong>分布式场景中</strong>，易于多机扩展。。</li></ul></blockquote><h5 id="（5）线程的实现"><a href="#（5）线程的实现" class="headerlink" title="（5）线程的实现"></a>（5）线程的实现</h5><p>线程的实现可以分为两类：<strong>用户级线程(User-LevelThread, ULT)</strong>和<strong>内核级线程(Kemel-LevelThread, KLT)</strong>。内核级线程又称为内核支持的线程。</p><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/2016-02-16_56c29fbf62c70.jpg" alt="img"></p><p>1）用户级线程</p><blockquote><ul><li><strong>概念：</strong>有关线程管理的所有工作都由应用程序完成，内核意识不到多线程的存在。用户级线程仅存在于用户空间中，此类线程的创建、撤销、线程之间的同步与通信功能，都无法利用系统调用来实现。</li><li><strong>优点：</strong></li></ul><blockquote><ol><li>可以在不支持线程的操作系统中实现。</li><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少, 因为保存线程状态的过程和调用程序都只是本进程空间的操作</li><li>允许每个进程定制自己的调度算法，线程管理比较灵活。</li><li>线程能够利用的表空间和堆栈空间比内核级线程多</li><li>不需要trap，不需要上下文切换（context switch），也不需要对内存高速缓存进行刷新，使得线程调用非常快捷</li><li>线程的调度不需要内核直接参与，控制简单。</li></ol></blockquote><ul><li><strong>缺点：</strong></li></ul><blockquote><ul><li>同一进程中只能同时有一个线程在运行</li><li>页面失效也会产生类似的问题。</li><li>一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程。</li></ul></blockquote></blockquote><p>2）内核级线程</p><blockquote><ul><li><strong>概念：</strong> 内核线程建立和销毁都是在内核的支持下运行，由操作系统负责管理，通过系统调用完成的。</li><li><strong>优点：</strong></li></ul><blockquote><ul><li>多处理器系统中，内核能够并行执行同一进程内的多个线程。</li><li>如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）。</li><li>所有能够阻塞线程的调用都以系统调用的形式实现，代价较大。</li><li>当一个线程阻塞时，内核根据选择可以运行另一个进程的线程。</li><li>信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“订阅”它们感兴趣的信号（订阅发布模型）。</li></ul></blockquote></blockquote><p>3）组合方式</p><blockquote><p>在一些系统中，使用组合方式的多线程实现, 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</p></blockquote><h5 id="（8）多线程模型"><a href="#（8）多线程模型" class="headerlink" title="（8）多线程模型"></a>（8）多线程模型</h5><p>1）多对一模型：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明）。</p><blockquote><p>优点：线程管理是在用户空间进行的，因而效率比较高。</p><p>缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</p></blockquote><p>2） 一对一模型：将每个用户级线程映射到一个内核级线程。</p><blockquote><p>优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</p><p>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p></blockquote><p>3）多对多模型：将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><blockquote><p>特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</p></blockquote><h4 id="1-2-进程的转换"><a href="#1-2-进程的转换" class="headerlink" title="1.2 进程的转换"></a>1.2 进程的转换</h4><h5 id="（1）进程的状态"><a href="#（1）进程的状态" class="headerlink" title="（1）进程的状态"></a>（1）进程的状态</h5><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F.png" alt="img"></p><blockquote><ul><li>创建状态：进程正在被创建</li><li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li><li>执行状态：进程正在被运行</li><li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</li><li>终止状态：进程运行完毕</li></ul></blockquote><h5 id="（2）交换技术"><a href="#（2）交换技术" class="headerlink" title="（2）交换技术"></a>（2）交换技术</h5><p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。针对以上问题，提出了两种解决方法：</p><blockquote><ol><li>交换技术：换出一部分进程到外存，腾出内存空间。</li><li>虚拟存储技术：每个进程只能装入一部分程序和数据。</li></ol></blockquote><p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了<strong>挂起状态</strong>。</p><h5 id="（3）-活动阻塞，静止阻塞，活动就绪，静止就绪"><a href="#（3）-活动阻塞，静止阻塞，活动就绪，静止就绪" class="headerlink" title="（3） 活动阻塞，静止阻塞，活动就绪，静止就绪"></a>（3） 活动阻塞，静止阻塞，活动就绪，静止就绪</h5><blockquote><ul><li>活动阻塞：进程在内存，但是由于某种原因被阻塞了。</li><li>静止阻塞：进程在外存，同时被某种原因阻塞了。</li><li>活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</li><li>静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</li></ul></blockquote><p>从而出现了：</p><blockquote><ul><li>活动就绪 ——  静止就绪        （内存不够，调到外存）</li><li>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</li><li>执行     ——  静止就绪         （时间片用完）</li></ul></blockquote><blockquote></blockquote><h4 id="1-3-进程调度算法"><a href="#1-3-进程调度算法" class="headerlink" title="1.3 进程调度算法"></a>1.3 进程调度算法</h4><h5 id="（1）调度的层次"><a href="#（1）调度的层次" class="headerlink" title="（1）调度的层次"></a>（1）调度的层次</h5><ul><li><strong>作业调度</strong></li></ul><blockquote><ul><li>作业调度。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入瀚输出设备等必要的资源，并建立相应的进程，以使它（们）获得竟争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。</li><li>频率较低</li></ul></blockquote><ul><li><strong>中级调度</strong></li></ul><blockquote><p>2）中级调度。又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程。</p></blockquote><ul><li><strong>进程调度</strong></li></ul><blockquote><p>3）进程调度。又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p></blockquote><h5 id="（2）进程调度的方式"><a href="#（2）进程调度的方式" class="headerlink" title="（2）进程调度的方式"></a>（2）进程调度的方式</h5><ul><li><strong>非抢占式</strong></li></ul><blockquote><p>是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。</p></blockquote><ul><li><strong>抢占式</strong></li></ul><blockquote><p>是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p></blockquote><h5 id="（3）进程调度算法"><a href="#（3）进程调度算法" class="headerlink" title="（3）进程调度算法"></a>（3）进程调度算法</h5><ul><li><strong>先来先服务（FCFS）调度算法</strong></li></ul><blockquote><ul><li>概念</li></ul><blockquote><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p></blockquote><ul><li>缺点</li></ul><blockquote><ul><li>FCFS调度算法的特点是算法简单，但效率低；</li><li>对长作业比较有利，但对短作业不利（相对SJF和高响应比）</li><li>有利于CPU繁忙型作业，而不利于IO繁忙型作业</li></ul></blockquote></blockquote><ul><li><strong>短作业优先（SJF）调度算法</strong></li></ul><blockquote><ul><li>概念</li></ul><blockquote><p>短作业优先（SJF）调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p></blockquote><ul><li>缺点</li></ul><blockquote><ul><li>对长作业不利，由于调度程序总是优先调度那些（即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象）。</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理</li><li>SF调度算法的平均等待时间、平均周转时间最少。</li></ul></blockquote></blockquote><ul><li><strong>优先级调度算法</strong></li></ul><blockquote><ul><li>概念</li></ul><blockquote><p>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。<strong>还可以分为抢占式和非抢占式，静态优先级和动态优先级</strong></p></blockquote></blockquote><ul><li><strong>时间片轮转调度算法</strong></li></ul><blockquote><ul><li>概念</li></ul><blockquote><ul><li>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如10ms。在使用完一个时间片后，即使进程并未完成其运行它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</li><li>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就<strong>退化为先来先服务调度算法</strong>。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于行用户进程的时间将减少。因此时间片的大小应选择适当。</li></ul></blockquote></blockquote><ul><li><strong>多级反馈队列调度算法（集合了前几种算法的优点）</strong></li></ul><blockquote><ul><li>概念</li></ul><blockquote><p>1）应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</p><p>2）赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。</p><p>3）当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该完成，便可准备撤离系统：如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列如此下去，当一个长进程从第1级队列依次降到第n级队列后，在第n级队列中便采用时间片轮转的方式运行</p><p>4）仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1-(i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第1~（n-1）中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p></blockquote><ul><li>优点</li></ul><blockquote><p>1）终端型作业用户：短作业优先。</p><p>2）短批处理作业用户；周转时间较短</p><p>3）长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理</p></blockquote></blockquote><h4 id="1-4-协程"><a href="#1-4-协程" class="headerlink" title="1.4 协程"></a>1.4 协程</h4><h5 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h5><blockquote><p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p></blockquote><h5 id="（2）协程与线程的区别"><a href="#（2）协程与线程的区别" class="headerlink" title="（2）协程与线程的区别"></a>（2）协程与线程的区别</h5><blockquote><ul><li>和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由<strong>程序自身控制</strong>，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul></blockquote><h5 id="（3）其他"><a href="#（3）其他" class="headerlink" title="（3）其他"></a>（3）其他</h5><blockquote><p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p></blockquote><h4 id="1-5-并发与并行"><a href="#1-5-并发与并行" class="headerlink" title="1.5 并发与并行"></a>1.5 并发与并行</h4><blockquote><p><strong>并发（concurrency）：</strong>指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p><p><strong>并行（parallelism）：</strong>指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p></blockquote><h4 id="1-6-僵尸进程与孤儿进程"><a href="#1-6-僵尸进程与孤儿进程" class="headerlink" title="1.6 僵尸进程与孤儿进程"></a>1.6 僵尸进程与孤儿进程</h4><h5 id="（1）正常进程"><a href="#（1）正常进程" class="headerlink" title="（1）正常进程"></a>（1）正常进程</h5><blockquote><ul><li><p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p></li><li><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p><blockquote><ol><li>进程号the process ID</li><li>退出状态the termination status of the process</li><li>运行时间the amount of CPU time taken by the process等</li></ol></blockquote></li></ul></blockquote><h5 id="（2）孤儿进程"><a href="#（2）孤儿进程" class="headerlink" title="（2）孤儿进程"></a>（2）孤儿进程</h5><blockquote><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p></blockquote><h5 id="（3）僵尸进程"><a href="#（3）僵尸进程" class="headerlink" title="（3）僵尸进程"></a>（3）僵尸进程</h5><blockquote><ul><li>概念</li></ul><blockquote><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p></blockquote><ul><li>产生原因</li></ul><blockquote><p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p><p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p></blockquote><ul><li>危害</li></ul><blockquote><p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p></blockquote><ul><li>解决</li></ul><blockquote><ul><li>外部消灭</li></ul><blockquote><p>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p></blockquote><ul><li>内部解决</li></ul><blockquote><ol><li>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</li><li>fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</li></ol></blockquote></blockquote></blockquote><h4 id="1-7-问题"><a href="#1-7-问题" class="headerlink" title="1.7 问题"></a>1.7 问题</h4><h5 id="（1）有了进程，为什么还要有线程？"><a href="#（1）有了进程，为什么还要有线程？" class="headerlink" title="（1）有了进程，为什么还要有线程？"></a>（1）有了进程，为什么还要有线程？</h5><p><strong>原因</strong></p><blockquote><ol><li>进程在同一时间只能干一件事</li><li>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</li><li>进程在创建、撤销、切换操作中需要较大的时空开销，限制了并发程度的进一步提高。</li></ol></blockquote><p><strong>线程的优势</strong></p><blockquote><ul><li><strong>资源上：</strong> 线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</li><li><strong>切换效率：</strong> 运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。</li><li><strong>通信方式：</strong> 线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</li><li>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点</li></ul><blockquote><ul><li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li><li>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</li></ul></blockquote></blockquote><h5 id="（2）游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#（2）游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="（2）游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>（2）游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h5><blockquote><p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程。</p></blockquote><h5 id="（3）怎么实现线程池"><a href="#（3）怎么实现线程池" class="headerlink" title="（3）怎么实现线程池"></a>（3）怎么实现线程池</h5><blockquote><ol><li>设置一个生产者消费者队列，作为临界资源</li><li>初始化n个线程，并让其运行起来，加锁去队列取任务运行</li><li>当任务队列为空的时候，所有线程阻塞</li><li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li></ol></blockquote><h5 id="（4）请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#（4）请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="（4）请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>（4）请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h5><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p><blockquote><ul><li>SP:堆栈指针，指向当前栈的栈顶地址</li><li>PC:程序计数器，存储下一条将要执行的指令</li><li>EAX:累加寄存器，用于加法乘法的缺省寄存器</li></ul></blockquote><h5 id="（5）怎么唤醒被阻塞的socket线程？"><a href="#（5）怎么唤醒被阻塞的socket线程？" class="headerlink" title="（5）怎么唤醒被阻塞的socket线程？"></a>（5）怎么唤醒被阻塞的socket线程？</h5><blockquote><p>给阻塞时候缺少的资源</p></blockquote><h5 id="（6）请问就绪状态的进程在等待什么？"><a href="#（6）请问就绪状态的进程在等待什么？" class="headerlink" title="（6）请问就绪状态的进程在等待什么？"></a>（6）请问就绪状态的进程在等待什么？</h5><blockquote><p>被调度使用cpu的运行权</p></blockquote><h5 id="（7）怎样确定当前线程是繁忙还是阻塞？"><a href="#（7）怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="（7）怎样确定当前线程是繁忙还是阻塞？"></a>（7）怎样确定当前线程是繁忙还是阻塞？</h5><blockquote><p>使用ps命令查看</p></blockquote><h5 id="（8）-请自己设计一下如何采用单线程的方式处理高并发"><a href="#（8）-请自己设计一下如何采用单线程的方式处理高并发" class="headerlink" title="（8） 请自己设计一下如何采用单线程的方式处理高并发"></a>（8） 请自己设计一下如何采用单线程的方式处理高并发</h5><blockquote><p>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</p></blockquote><h5 id="（9）请问如何设计server，使得能够接收多个客户端的请求"><a href="#（9）请问如何设计server，使得能够接收多个客户端的请求" class="headerlink" title="（9）请问如何设计server，使得能够接收多个客户端的请求"></a>（9）请问如何设计server，使得能够接收多个客户端的请求</h5><blockquote><p>多线程，线程池，io复用</p></blockquote><h5 id="（10）-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#（10）-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="（10） 死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>（10） 死循环+来连接时新建线程的方法效率有点低，怎么改进？</h5><blockquote><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p></blockquote><h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2 锁"></a>2 锁</h3><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/%E9%94%81.jpg" alt="锁"></p><h4 id="2-1-死锁的定义"><a href="#2-1-死锁的定义" class="headerlink" title="2.1 死锁的定义"></a>2.1 死锁的定义</h4><blockquote><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。</p></blockquote><h4 id="2-2-死锁产生的原因"><a href="#2-2-死锁产生的原因" class="headerlink" title="2.2 死锁产生的原因"></a>2.2 死锁产生的原因</h4><blockquote><ul><li><strong>系统资源的竞争：</strong>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</li><li><strong>进程推进顺序非法：</strong>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。</li></ul></blockquote><h4 id="2-3-死锁产生的必要条件"><a href="#2-3-死锁产生的必要条件" class="headerlink" title="2.3 死锁产生的必要条件"></a>2.3 死锁产生的必要条件</h4><blockquote><ul><li><strong>互斥条件：</strong>进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</li><li><strong>请求和保持条件：</strong>进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</li><li><strong>不可剥夺条件：</strong>进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</li><li><strong>环路等待条件：</strong>进程发生死锁后，必然存在一个进程-资源之间的环形链</li></ul></blockquote><h4 id="2-4-死锁的预防"><a href="#2-4-死锁的预防" class="headerlink" title="2.4 死锁的预防"></a>2.4 死锁的预防</h4><p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p><blockquote><p>资源一次性分配，从而剥夺请求和保持条件</p><p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p><p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p></blockquote><h4 id="2-5-死锁的避免：银行家算法"><a href="#2-5-死锁的避免：银行家算法" class="headerlink" title="2.5 死锁的避免：银行家算法"></a>2.5 死锁的避免：银行家算法</h4><blockquote><p>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</p></blockquote><h4 id="2-6-死锁的检测：资源分配图"><a href="#2-6-死锁的检测：资源分配图" class="headerlink" title="2.6 死锁的检测：资源分配图"></a>2.6 死锁的检测：资源分配图</h4><h4 id="2-7-死锁解除"><a href="#2-7-死锁解除" class="headerlink" title="2.7 死锁解除"></a>2.7 死锁解除</h4><blockquote><p>1）<strong>资源剥夺法：</strong>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。</p><p>但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p><p>2）<strong>撤销进程法：</strong>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和</p><p>撤销进程代价的高低进行。</p><p>3）<strong>进程回退法：</strong>让一（或多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。</p><p>要求系统保持进程的历史信息，设置还原点。</p></blockquote><h4 id="2-8-Linux的4种锁机制"><a href="#2-8-Linux的4种锁机制" class="headerlink" title="2.8 Linux的4种锁机制"></a>2.8 Linux的4种锁机制</h4><h5 id="（1）互斥锁"><a href="#（1）互斥锁" class="headerlink" title="（1）互斥锁"></a>（1）互斥锁</h5><blockquote><p>mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p></blockquote><h5 id="（2）读写锁"><a href="#（2）读写锁" class="headerlink" title="（2）读写锁"></a>（2）读写锁</h5><blockquote><p>rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。<strong>适用于读取数据的频率远远大于写数据的频率的场合。</strong></p></blockquote><h5 id="（3）自旋锁"><a href="#（3）自旋锁" class="headerlink" title="（3）自旋锁"></a>（3）自旋锁</h5><blockquote><p>spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，<strong>在加锁时间短暂的环境下会极大的提高效率</strong>。但如果加锁时间过长，则会非常浪费CPU资源。</p></blockquote><h5 id="（3）RCU"><a href="#（3）RCU" class="headerlink" title="（3）RCU"></a>（3）RCU</h5><blockquote><p>即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。<strong>在有大量读操作，少量写操作的情况下效率非常高。</strong></p></blockquote><h5 id="（5）互斥锁和读写锁的区别："><a href="#（5）互斥锁和读写锁的区别：" class="headerlink" title="（5）互斥锁和读写锁的区别："></a>（5）互斥锁和读写锁的区别：</h5><blockquote><p>1）读写锁区分读者和写者，而互斥锁不区分</p><p>2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p></blockquote><h4 id="2-9-问题"><a href="#2-9-问题" class="headerlink" title="2.9 问题"></a>2.9 问题</h4><h5 id="（1）请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#（1）请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="（1）请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>（1）请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h5><blockquote><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p></blockquote><h5 id="（2）请你说一说多线程的同步，锁的机制"><a href="#（2）请你说一说多线程的同步，锁的机制" class="headerlink" title="（2）请你说一说多线程的同步，锁的机制"></a>（2）请你说一说多线程的同步，锁的机制</h5><blockquote><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行</p></blockquote><h5 id="（3）两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#（3）两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="（3）两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>（3）两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h5><blockquote><p>单核cpu，并且开了抢占可以造成这种情况。</p></blockquote><h5 id="（4）假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？"><a href="#（4）假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？" class="headerlink" title="（4）假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？"></a>（4）假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？</h5><blockquote><p>信号量+PV操作</p></blockquote><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1 内存管理"></a>1 内存管理</h3><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.jpg" alt="内存管理"></p><h4 id="1-1-内存管理的方式"><a href="#1-1-内存管理的方式" class="headerlink" title="1.1 内存管理的方式"></a>1.1 内存管理的方式</h4><h5 id="（1）块式管理："><a href="#（1）块式管理：" class="headerlink" title="（1）块式管理："></a>（1）块式管理：</h5><blockquote><p>把主存分为一大块一大块的，当所需的程序片段不在主存时就分配一块主存空间，把程序片段load入主存，就算所需的程序片段只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50%的内存空间，但是易于管理。</p></blockquote><pre><code>##### （2）页式管理：</code></pre><blockquote><p>把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，这种方法的空间利用率要比块式管理高很多</p></blockquote><h5 id="（3）段式管理："><a href="#（3）段式管理：" class="headerlink" title="（3）段式管理："></a>（3）段式管理：</h5><blockquote><p>把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高得多，但是也有另外一个缺点。一个程序片段可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。</p></blockquote><pre><code>##### （4）段页式管理：</code></pre><blockquote><p>结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页。段页式管理每取一次数据，要访问3次内存</p></blockquote><h4 id="1-2-分页和分段的区别"><a href="#1-2-分页和分段的区别" class="headerlink" title="1.2 分页和分段的区别"></a>1.2 分页和分段的区别</h4><blockquote><ul><li>页是信息的物理单位，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。</li><li>段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进程编辑时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性空间，程序员只需利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li></ul></blockquote><h4 id="1-3-虚拟内存"><a href="#1-3-虚拟内存" class="headerlink" title="1.3 虚拟内存"></a>1.3 虚拟内存</h4><p> 虚拟内存简称虚存，是计算机系统内存管理的一种技术。它是相对于物理内存而言的，可以理解为“假的”内存。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），允许程序员编写并允许比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上实现。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p><p><strong>虚存比实存有以下好处：</strong></p><blockquote><ol><li>扩大地址空间。无论段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大。</li><li>内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</li><li>公平分配内存。采用了虚存之后，每个进程都相当于有太阳大小的虚存空间。</li><li>当进程需要通信时，可采用虚存共享的方式实现。</li></ol></blockquote><p><strong>虚存缺点：</strong></p><blockquote><ol><li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存。</li><li>虚拟地址到物理地址的转换，增加了指令的执行时间</li><li>页面的换入换出需要磁盘I/O，这是很耗时间的。</li><li>如果一页中只有一部分数据，会很浪费内存。</li></ol></blockquote><h4 id="1-4-缺页中断处理"><a href="#1-4-缺页中断处理" class="headerlink" title="1.4 缺页中断处理"></a>1.4 缺页中断处理</h4><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><blockquote><ol><li>保护CPU现场</li><li>分析中断原因</li><li>转入缺页中断处理程序进行处理</li><li>恢复CPU现场，继续执行</li></ol></blockquote><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p><blockquote><ol><li>在指令执行期间产生和处理缺页中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li><li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</li></ol></blockquote><h4 id="1-5-页表寻址"><a href="#1-5-页表寻址" class="headerlink" title="1.5 页表寻址"></a>1.5 页表寻址</h4><p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p><h5 id="（1）Linux最初的两级页表机制："><a href="#（1）Linux最初的两级页表机制：" class="headerlink" title="（1）Linux最初的两级页表机制："></a>（1）Linux最初的两级页表机制：</h5><p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p><p>* PGD(Page Global Directory): 最高10位，全局页目录表索引</p><p>* PTE(Page Table Entry)：中间10位，页表入口索引</p><p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p><h5 id="（2）Linux的三级页表机制："><a href="#（2）Linux的三级页表机制：" class="headerlink" title="（2）Linux的三级页表机制："></a>（2）Linux的三级页表机制：</h5><p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p><p>字段            描述                        位数</p><p>cr3            指向一个PDPT            crs寄存器存储</p><p>PGD        指向PDPT中4个项中的一个    位31~30</p><p>PMD        指向页目录中512项中的一个    位29~21</p><p>PTE            指向页表中512项中的一个    位20~12</p><p>page offset    4KB页中的偏移            位11~0</p><p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p><p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p><h5 id="（3）Linux的四级页表机制："><a href="#（3）Linux的四级页表机制：" class="headerlink" title="（3）Linux的四级页表机制："></a>（3）Linux的四级页表机制：</h5><p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p><p>字段            描述                        位数</p><p>PML4        指向一个PDPT            位47~39</p><p>PGD        指向PDPT中4个项中的一个    位38~30</p><p>PMD        指向页目录中512项中的一个    位29~21</p><p>PTE            指向页表中512项中的一个    位20~12</p><p>page offset    4KB页中的偏移            位11~0</p><p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p><h4 id="1-6-页面置换算法"><a href="#1-6-页面置换算法" class="headerlink" title="1.6 页面置换算法"></a>1.6 页面置换算法</h4><h5 id="（1）最佳置换算法（OPT）"><a href="#（1）最佳置换算法（OPT）" class="headerlink" title="（1）最佳置换算法（OPT）"></a>（1）最佳置换算法（OPT）</h5><blockquote><p>最佳（ Optimal,OPT）置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p></blockquote><h5 id="（2）先进先出（FIFO）页面置换算法"><a href="#（2）先进先出（FIFO）页面置换算法" class="headerlink" title="（2）先进先出（FIFO）页面置换算法"></a>（2）先进先出（FIFO）页面置换算法</h5><blockquote><ul><li>优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面</li><li>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为 Belady异常。</li></ul></blockquote><h5 id="（3）最近最久未使用（LRU）置换算法"><a href="#（3）最近最久未使用（LRU）置换算法" class="headerlink" title="（3）最近最久未使用（LRU）置换算法"></a>（3）最近最久未使用（LRU）置换算法</h5><blockquote><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p></blockquote><h5 id="（4）时钟（-CLOCK）置换算法"><a href="#（4）时钟（-CLOCK）置换算法" class="headerlink" title="（4）时钟（ CLOCK）置换算法"></a>（4）时钟（ CLOCK）置换算法</h5><blockquote><ul><li>LRU算法的性能接近于OPT，但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是 CLOCK算法的变体。因为算法要循环扫描缓冲区，像时钟的针一样转动，所以叫 CLOCK算法</li><li>简单的 CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1：当该页随后再被访问到时，它的使用位也被置为1.对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0：如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1，则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为 CLOCK算法，又称为最近未用（ Not Recently Used,NRU）算法。</li></ul></blockquote><h4 id="1-7-问题-1"><a href="#1-7-问题-1" class="headerlink" title="1.7 问题"></a>1.7 问题</h4><h5 id="（1）mmap基础概念"><a href="#（1）mmap基础概念" class="headerlink" title="（1）mmap基础概念"></a>（1）mmap基础概念</h5><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><p><strong>优点</strong></p><blockquote><p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p><p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p><p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p></blockquote><h5 id="（2）请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#（2）请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="（2）请你回答一下为什么要有page cache，操作系统怎么设计的page cache"></a>（2）请你回答一下为什么要有page cache，操作系统怎么设计的page cache</h5><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><center><font size="7">其他</font></center><h4 id="1-内核"><a href="#1-内核" class="headerlink" title="1. 内核"></a>1. 内核</h4><h4 id="1-1-微内核与宏内核"><a href="#1-1-微内核与宏内核" class="headerlink" title="1.1 微内核与宏内核"></a>1.1 微内核与宏内核</h4><h5 id="1）宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。"><a href="#1）宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。" class="headerlink" title="(1）宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。"></a>(1）宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</h5><blockquote><p>优点：效率高。</p><p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p></blockquote><h5 id="（2）微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。"><a href="#（2）微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。" class="headerlink" title="（2）微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。"></a>（2）微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</h5><blockquote><p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p><p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p></blockquote><h4 id="1-2-用户态与内核态"><a href="#1-2-用户态与内核态" class="headerlink" title="1.2 用户态与内核态"></a>1.2 用户态与内核态</h4><blockquote><ul><li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。</li><li>用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。</li><li>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</li></ul></blockquote><h4 id="1-3-用户态到内核态的转化"><a href="#1-3-用户态到内核态的转化" class="headerlink" title="1.3 用户态到内核态的转化"></a>1.3 用户态到内核态的转化</h4><h5 id="（1）系统调用"><a href="#（1）系统调用" class="headerlink" title="（1）系统调用"></a>（1）系统调用</h5><blockquote><p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p></blockquote><h5 id="（2）异常"><a href="#（2）异常" class="headerlink" title="（2）异常"></a>（2）异常</h5><blockquote><p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p></blockquote><h5 id="（3）外围设备的中断"><a href="#（3）外围设备的中断" class="headerlink" title="（3）外围设备的中断"></a>（3）外围设备的中断</h5><blockquote><p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></blockquote><h5 id="（4）切换过程"><a href="#（4）切换过程" class="headerlink" title="（4）切换过程"></a>（4）切换过程</h5><p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p><blockquote><ol><li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li><li>使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li><li>将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li></ol></blockquote><h5 id="（5）操作系统的中断"><a href="#（5）操作系统的中断" class="headerlink" title="（5）操作系统的中断"></a>（5）操作系统的中断</h5><blockquote><p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。</p><ul><li>一种是由CPU外部引起的，如I/O中断、时钟中断，</li><li>一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），</li><li>最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</li></ul></blockquote><h4 id="1-4-问题"><a href="#1-4-问题" class="headerlink" title="1.4  问题"></a>1.4  问题</h4><h5 id="（1）请你回答一下操作系统为什么要分内核态和用户态"><a href="#（1）请你回答一下操作系统为什么要分内核态和用户态" class="headerlink" title="（1）请你回答一下操作系统为什么要分内核态和用户态"></a>（1）请你回答一下操作系统为什么要分内核态和用户态</h5><p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p><h5 id="（2）系统调用是什么，你用过哪些系统调用"><a href="#（2）系统调用是什么，你用过哪些系统调用" class="headerlink" title="（2）系统调用是什么，你用过哪些系统调用"></a>（2）系统调用是什么，你用过哪些系统调用</h5><p><strong>概念：</strong></p><blockquote><p>在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p><p>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p><p>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p></blockquote><p><strong>系统调用举例：</strong></p><blockquote><p>对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。</p></blockquote><h3 id="2-文件"><a href="#2-文件" class="headerlink" title="2. 文件"></a>2. 文件</h3><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.jpg" alt="文件系统"></p><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1570364021637.jpg" alt="文件系统"></p><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1570364043960.jpg" alt="文件系统"></p><h4 id="2-1-问题"><a href="#2-1-问题" class="headerlink" title="2.1 问题"></a>2.1 问题</h4><h5 id="（1）请问如何修改文件最大句柄数？"><a href="#（1）请问如何修改文件最大句柄数？" class="headerlink" title="（1）请问如何修改文件最大句柄数？"></a>（1）请问如何修改文件最大句柄数？</h5><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。有两种方法：</p><ol><li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值），首先用ulimit -a查询Linux相关的参数，如下所示：</li></ol><pre><code>core file size          (blocks, -c) 0data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 94739max locked memory       (kbytes, -l) 64max memory size         (kbytes, -m) unlimitedopen files                      (-n) 1024pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 94739virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited</code></pre><p>其中，open files就是最大文件句柄数，默认是1024个。</p><p>修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p><ol start="2"><li>对所有进程都有效的方法，修改Linux系统参数</li></ol><p>vi /etc/security/limits.conf 添加</p><pre><code>*　　soft　　nofile　　65536*　　hard　　nofile　　65536</code></pre><p>将最大句柄数改为65536，修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p><h5 id="（2）请你回答一下软链接和硬链接区别"><a href="#（2）请你回答一下软链接和硬链接区别" class="headerlink" title="（2）请你回答一下软链接和硬链接区别"></a>（2）请你回答一下软链接和硬链接区别</h5><blockquote><p>为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p></blockquote><h3 id="2-Linux"><a href="#2-Linux" class="headerlink" title="2. Linux"></a>2. Linux</h3><h4 id="2-1-Linux-的5种IO模型"><a href="#2-1-Linux-的5种IO模型" class="headerlink" title="2.1 Linux 的5种IO模型"></a>2.1 Linux 的5种IO模型</h4><blockquote><ol><li><strong>阻塞IO：</strong>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞IO：</strong>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</li><li><strong>信号驱动IO：</strong>linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li><li><strong>IO复用/多路转接IO：</strong>linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li><li><strong>异步IO：</strong>linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ol></blockquote><h4 id="2-2-Linux中的四种锁"><a href="#2-2-Linux中的四种锁" class="headerlink" title="2.2 Linux中的四种锁"></a>2.2 Linux中的四种锁</h4><h4 id="2-3-Linux中共享内存相关api"><a href="#2-3-Linux中共享内存相关api" class="headerlink" title="2.3 Linux中共享内存相关api"></a>2.3 Linux中共享内存相关api</h4><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。</p><p>1）新建共享内存shmget</p><blockquote><p>int shmget(key_t key,size_t size,int shmflg);</p><p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p><p>size：共享内存大小</p><p>shmflag：创建进程和其他进程的读写权限标识。</p><p>返回值：相应的共享内存标识符，失败返回-1</p></blockquote><p>2）连接共享内存到当前进程的地址空间shmat</p><blockquote><p>void <em>shmat(int shm_id,const void </em>shm_addr,int shmflg);</p><p>shm_id：共享内存标识符</p><p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p><p>shmflg：标志位</p><p>返回值：指向共享内存第一个字节的指针，失败返回-1</p></blockquote><p>3）当前进程分离共享内存shmdt</p><blockquote><p>int shmdt(const void *shmaddr);</p></blockquote><p>4）控制共享内存shmctl</p><blockquote><p>和信号量的semctl函数类似，控制共享内存</p><p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p><p>shm_id：共享内存标识符</p><p>command: 有三个值</p><p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p><p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p><p>IPC_RMID:删除共享内存</p><p>buf：共享内存管理结构体。</p></blockquote><h4 id="2-4-Linux系统中的Timer定时器"><a href="#2-4-Linux系统中的Timer定时器" class="headerlink" title="2.4 Linux系统中的Timer定时器"></a>2.4 Linux系统中的Timer定时器</h4><p><strong>1）低精度时钟</strong></p><p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：</p><blockquote><ol><li>系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</li><li>内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</li><li>设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</li></ol></blockquote><p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p><p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p><p><strong>2）高精度时钟</strong></p><p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p><blockquote><ol><li>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</li><li>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</li><li>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</li><li>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</li></ol></blockquote><p><strong>3）hrtimer的工作原理：</strong></p><blockquote><ul><li>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</li><li>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</li><li>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</li></ul></blockquote><p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p><blockquote><ul><li>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</li><li>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</li><li>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。</li></ul></blockquote><h4 id="2-5-Reactor模型和Proactor模型"><a href="#2-5-Reactor模型和Proactor模型" class="headerlink" title="2.5 Reactor模型和Proactor模型"></a>2.5 Reactor模型和Proactor模型</h4><h5 id="（1）Reactor模型"><a href="#（1）Reactor模型" class="headerlink" title="（1）Reactor模型"></a>（1）Reactor模型</h5><p><strong>概念：</strong></p><blockquote><p>Reactor模式是处理并发I/O比较常见的一种模式，用于<strong>同步I/O</strong>，中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有I/O事件到来或是准备就绪(文件描述符或socket可读、写)，多路复用器返回并将事先注册的相应I/O事件分发到对应的处理器中。<br>　　Reactor是一种事件驱动机制，和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，Reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到Reactor上，如果相应的事件发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。</p></blockquote><p><strong>在Reactor模式中，有5个关键的参与者：</strong></p><blockquote><ul><li><strong>描述符（handle）：</strong>由操作系统提供的资源，用于识别每一个事件，如Socket描述符、文件描述符、信号的值等。在Linux中，它用一个整数来表示。事件可以来自外部，如来自客户端的连接请求、数据等。事件也可以来自内部，如信号、定时器事件。</li><li><strong>同步事件多路分离器（event demultiplexer）：</strong>事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O复用技术实现。在linux系统上一般是select、poll、epol_waitl等系统调用，用来等待一个或多个事件的发生。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。</li><li><strong>事件处理器（event handler）：</strong>I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。这些模板函数描述了和应用程序相关的对某个事件的操作，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般声明为虚函数，以支持用户拓展。</li><li><strong>具体的事件处理器（concrete event handler）：</strong>是事件处理器接口的实现。它实现了应用程序提供的某个服务。每个具体的事件处理器总和一个描述符相关。它使用描述符来识别事件、识别应用程序提供的服务。</li><li><strong>Reactor 管理器（reactor）：</strong>定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模 板函数来处理这个事件。</li></ul></blockquote><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/20150530185135499.jfif" alt="img"></p><p><strong>处理过程：</strong></p><blockquote><p>可以看出，是Reactor管理器并不是应用程序负责等待事件、分离事件和调度事件。Reactor并没有被具体的事件处理器调度，而是管理器调度具体的事件处理器，由事件处理器对发生的事件作出处理，这就是Hollywood原则。应用程序要做的仅仅是实现一个具体的事件处理器，然后把它注册到Reactor管理器中。接下来的工作由管理器来完成：如果有相应的事件发生，Reactor会主动调用具体的事件处理器，由事件处理器对发生的事件作出处理。</p></blockquote><p><strong>应用场景：</strong></p><blockquote><p><strong>场景：</strong>长途客车在路途上，有人上车有人下车，但是乘客总是希望能够在客车上得到休息。<br><strong>传统做法：</strong>每隔一段时间（或每一个站），司机或售票员对每一个乘客询问是否下车。<br><strong>Reactor做法：</strong>汽车是乘客访问的主体（Reactor），乘客上车后，到售票员（acceptor）处登记，之后乘客便可以休息睡觉去了，当到达乘客所要到达的目的地时（指定的事件发生，乘客到了下车地点），售票员将其唤醒即可。</p></blockquote><p><strong>为什么使用Reactor</strong></p><blockquote><ul><li>网络编程为什么要用反应堆？有了I/O复用，有了epoll已经可以使服务器并发几十万连接的同时，维持高TPS了，难道这还不够吗？</li></ul><blockquote><p>答案是，技术层面足够了，但在软件工程层面却是不够的。</p></blockquote><ul><li>程序使用IO复用的难点在哪里呢？</li></ul><blockquote><p>1个请求可能由多次IO处理完成，但相比传统的单线程完整处理请求生命期的方法，IO复用在人的大脑思维中并不自然，因为，程序员编程中，处理请求A的时候，假定A请求必须经过多个IO操作A1-An（两次IO间可能间隔很长时间），每经过一次IO操作，再调用IO复用时，IO复用的调用返回里，非常可能不再有A，而是返回了请求B。即请求A会经常被请求B打断，处理请求B时，又被C打断。这种思维下，编程容易出错。</p></blockquote></blockquote><p><strong>Reactor的几种模式</strong></p><blockquote><ul><li>单线程模式</li></ul><blockquote><p>这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过这种单线程模型不能充分利用多核资源，所以实际使用的不多。</p></blockquote><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/20150530200837585.png" alt="img"></p><ul><li>多线程模式（单Reactor）</li></ul><blockquote><p>该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。</p></blockquote><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/20150530200945280.png" alt="img"></p><ul><li>多线程模式（单Reactor）</li></ul><blockquote><p>比起第二种模型，它是将Reactor分成两部分，mainReactor负责监听并accept新连接，然后将建立的socket通过多路复用器（Acceptor）分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据；业务处理功能，其交给worker线程池完成。通常，subReactor个数上可与CPU个数等同。</p></blockquote><p><img src="/2019/10/06/mian-shi-cao-zuo-xi-tong/20150530201146975.png" alt="img"></p></blockquote><h5 id="（2）Proactor模型"><a href="#（2）Proactor模型" class="headerlink" title="（2）Proactor模型"></a>（2）Proactor模型</h5><p>​        Proactor是和异步I/O相关的。</p><p>​        在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分离器就把这个事件传给事先注册的处理器（事件处理函数或者回调函数），由后者来做实际的读写操作。<br>​        在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。</p><p>​        可以看出两者的区别：Reactor是在事件发生时就通知事先注册的事件（读写由处理函数完成）；Proactor是在事件发生时进行异步I/O（读写由OS完成），待IO完成事件分离器才调度处理器来处理。</p><h5 id="（3）两者区别"><a href="#（3）两者区别" class="headerlink" title="（3）两者区别"></a>（3）两者区别</h5><p><strong>在Reactor（同步）中实现读：</strong></p><blockquote><ul><li>注册读就绪事件和相应的事件处理器</li><li>事件分离器等待事件</li><li>事件到来，激活分离器，分离器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul></blockquote><p><strong>Proactor（异步）中的读：</strong></p><blockquote><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分离器等待操作完成事件</li><li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li><li>事件分离器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li></ul></blockquote><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3 其他"></a>3 其他</h3><h4 id="3-1-请你说一说操作系统中的结构体对齐，字节对齐"><a href="#3-1-请你说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="3.1 请你说一说操作系统中的结构体对齐，字节对齐"></a>3.1 请你说一说操作系统中的结构体对齐，字节对齐</h4><h5 id="（1）原因："><a href="#（1）原因：" class="headerlink" title="（1）原因："></a>（1）原因：</h5><blockquote><p><strong>平台原因（移植原因）：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p><p><strong>性能原因：</strong>数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p></blockquote><h5 id="（2）规则"><a href="#（2）规则" class="headerlink" title="（2）规则"></a>（2）规则</h5><blockquote><p><strong>数据成员对齐规则：</strong>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p><p><strong>结构(或联合)的整体对齐规则：</strong>在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p><p><strong>结构体作为成员：</strong>如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p></blockquote><h5 id="（3）定义结构体对齐"><a href="#（3）定义结构体对齐" class="headerlink" title="（3）定义结构体对齐"></a>（3）定义结构体对齐</h5><blockquote><ul><li>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">#pragma pack(2)struct AA {int a;       //长度4 > 2 按2对齐；偏移量为0；存放位置区间[0,3]char b;  //长度1 < 2 按1对齐；偏移量为4；存放位置区间[4]short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]char d;  //长度1 < 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节};#pragma pack()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="（4）请问什么是大端小端以及如何判断大端小端"><a href="#（4）请问什么是大端小端以及如何判断大端小端" class="headerlink" title="（4）请问什么是大端小端以及如何判断大端小端"></a>（4）请问什么是大端小端以及如何判断大端小端</h5><blockquote><ul><li>大端是指低字节存储在高地址；</li><li>小端存储是指低字节存储在低地址。</li></ul><p>我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从<strong>低地址存储</strong>。</p><pre class="line-numbers language-c++"><code class="language-c++">int fun(){ union test{     int i;     char c; }; test t; t.i=1; //如果是大端，则t.c为0x00,则t.c!=1,返回0，是小端，返回1则为大端 return (t.c==1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="3-2-请你说一说异步编程的事件循环"><a href="#3-2-请你说一说异步编程的事件循环" class="headerlink" title="3.2 请你说一说异步编程的事件循环"></a>3.2 请你说一说异步编程的事件循环</h4><blockquote><p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p></blockquote><h4 id="3-3-windows消息机制知道吗，请说一说"><a href="#3-3-windows消息机制知道吗，请说一说" class="headerlink" title="3.3 windows消息机制知道吗，请说一说"></a>3.3 windows消息机制知道吗，请说一说</h4><blockquote><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p></blockquote><h4 id="3-4-server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#3-4-server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="3.4 server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>3.4 server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h4><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p><h2 id="fork、vfork、exec、wait"><a href="#fork、vfork、exec、wait" class="headerlink" title="fork、vfork、exec、wait"></a>fork、vfork、exec、wait</h2><h3 id="1-fork"><a href="#1-fork" class="headerlink" title="1 fork"></a>1 fork</h3><p>（1）当一个进程调用了fork 以后,系统会创建一个子进程.这个子进程和父进程不同的地方只有他的进程ID 和父进程ID,其他的都是一样.就象符进程克隆(clone)自己一样.</p><p>（2）为了区分父进程和子进程,我们必须跟踪fork 的返回值. 当fork 掉用失败的时候(内存不足或者是用户的最大进程数已到)fork 返回-1,否则fork 的返回值有重要的作用.对于父进程fork 返回子进程的ID,而对于fork 子进程返回0.我们就是根据这个返回值来区分父子进程的.</p><p>（3）一旦子进程被创建,父子进程一起从fork 处继续执行,相互竞争系统的资源.有时候我们希望子进程继续执行,而父进程阻塞直到子进程完成任务.这个时候我们可以调用wait 或者waitpid 系统调用.</p><h3 id="2-vfork"><a href="#2-vfork" class="headerlink" title="2 vfork"></a>2 vfork</h3><p>vfork()会产生一个新的子进程，其子进程会复制父进程的数据与堆栈空间，并继承父进程的用户代码，组代码，环境变量、已打开的文件代码、工作目录和资源限制等。Linux 使用copy-on-write(COW)技术，只有当其中一进程试图修改欲复制的空间时才会做真正的复制动作，由于这些继承的信息是复制而来，并非指相同的内存空间，因此子进程对这些变量的修改和父进程并不会同步。此外，子进程不会继承父进程的文件锁定和未处理的信号。注意，Linux不保证子进程会比父进程先执行或晚执行，因此编写程序时要留意。</p><h3 id="3-wait"><a href="#3-wait" class="headerlink" title="3 wait"></a>3 wait</h3><p>wait()会暂时停止目前进程的执行，直到有信号来到或子进程结束。如果在调用wait()时子进程已经结束，则wait()会立即返回子进程结束状态值。子进程的结束状态值会由参数status 返回，而子进程的进程识别码也会一快返回。</p><h3 id="4-waitpid"><a href="#4-waitpid" class="headerlink" title="4 waitpid"></a>4 waitpid</h3><p>waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。如果在调用wait()时子进程已经结束，则wait()会立即返回子进程结束状态值。子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一快返回。如果不在意结束状态值，则参数status可以设成NULL。</p><h3 id="5-exec"><a href="#5-exec" class="headerlink" title="5 exec"></a>5 exec</h3><p>用<code>fork</code>创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种<code>exec</code>函数以执行另一个程序。当进程调用一种<code>exec</code>函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用<code>exec</code>并不</p><h2 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h2><h3 id="1、ls命令"><a href="#1、ls命令" class="headerlink" title="1、ls命令"></a>1、ls命令</h3><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p><p><strong>常用参数搭配：</strong></p><pre><code>ls -a 列出目录所有文件，包含以.开始的隐藏文件ls -A 列出除.及..的其它文件ls -r 反序排列ls -t 以文件修改时间排序ls -S 以文件大小排序ls -h 以易读大小显示ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</code></pre><p><strong>实例：</strong></p><p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p><pre><code>ls -lhrt</code></pre><p>(2) 按大小反序显示文件详细信息</p><pre><code>ls -lrS</code></pre><p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p><pre><code>ls -l t*</code></pre><p>(4) 列出文件绝对路径（不包含隐藏文件）</p><pre><code>ls | sed &quot;s:^:`pwd`/:&quot;</code></pre><p>(5) 列出文件绝对路径（包含隐藏文件）</p><pre><code>find $pwd -maxdepth 1 | xargs ls -ld</code></pre><h3 id="2、cd-命令"><a href="#2、cd-命令" class="headerlink" title="2、cd 命令"></a>2、cd 命令</h3><p>cd(changeDirectory) 命令语法：</p><pre><code>cd [目录名]</code></pre><p>说明：切换当前目录至 dirName。</p><p><strong>实例：</strong></p><p>（1）进入要目录</p><pre><code>cd /</code></pre><p>（2）进入 “home” 目录</p><pre><code>cd ~</code></pre><p>（3）进入上一次工作路径</p><pre><code>cd -</code></pre><p>（4）把上个命令的参数作为cd参数使用。</p><pre><code>cd !$</code></pre><h3 id="3、pwd-命令"><a href="#3、pwd-命令" class="headerlink" title="3、pwd 命令"></a>3、pwd 命令</h3><p>pwd 命令用于查看当前工作目录路径。</p><p><strong>实例：</strong></p><p>（1）查看当前路径</p><pre><code>pwd</code></pre><p>（2）查看软链接的实际路径</p><pre><code>pwd -P</code></pre><p>4、mkdir 命令</p><p>mkdir 命令用于创建文件夹。</p><p>可用选项：</p><ul><li><strong>-m</strong>: 对新建目录设置存取权限，也可以用 chmod 命令设置;</li><li><strong>-p</strong>: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</li></ul><p><strong>实例：</strong></p><p>（1）当前工作目录下创建名为 t的文件夹</p><pre><code>mkdir t</code></pre><p>（2）在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：</p><pre><code>mkdir -p /tmp/test/t1/t</code></pre><h3 id="5、rm-命令"><a href="#5、rm-命令" class="headerlink" title="5、rm 命令"></a>5、rm 命令</h3><p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p><pre><code>rm [选项] 文件…</code></pre><p><strong>实例：</strong></p><p>（1）删除任何 .log 文件，删除前逐一询问确认：</p><pre><code>rm -i *.log</code></pre><p>（2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p><pre><code>rm -rf test</code></pre><p>（3）删除以 -f 开头的文件</p><pre><code>rm -- -f*</code></pre><h3 id="6、rmdir-命令"><a href="#6、rmdir-命令" class="headerlink" title="6、rmdir 命令"></a>6、rmdir 命令</h3><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p><p><strong>注意</strong>：不能删除非空目录</p><p><strong>实例：</strong></p><p>（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p><pre><code>rmdir -p parent/child/child11</code></pre><h3 id="7、mv-命令"><a href="#7、mv-命令" class="headerlink" title="7、mv 命令"></a>7、mv 命令</h3><p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p><p>当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数 2 指定的目录中。</p><p><strong>实例：</strong></p><p>（1）将文件 test.log 重命名为 test1.txt</p><pre><code>mv test.log test1.txt</code></pre><p>（2）将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中</p><pre><code>mv llog1.txt log2.txt log3.txt /test3</code></pre><p>（3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p><pre><code>mv -i log1.txt log2.txt</code></pre><p>（4）移动当前文件夹下的所有文件到上一级目录</p><pre><code>mv * ../</code></pre><h3 id="8、cp-命令"><a href="#8、cp-命令" class="headerlink" title="8、cp 命令"></a>8、cp 命令</h3><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><p>注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！</p><pre><code>-i 提示-r 复制目录及目录内所有项目-a 复制的文件与原文件时间一样</code></pre><p><strong>实例：</strong></p><p>（1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p><pre><code>cp -ai a.txt test</code></pre><p>（2）为 a.txt 建议一个链接（快捷方式）</p><pre><code>cp -s a.txt link_a.txt</code></pre><h3 id="9、cat-命令"><a href="#9、cat-命令" class="headerlink" title="9、cat 命令"></a>9、cat 命令</h3><p>cat 主要有三大功能：</p><p>1.一次显示整个文件:</p><pre><code>cat filename</code></pre><p>2.从键盘创建一个文件:</p><pre><code>cat &gt; filename</code></pre><p>只能创建新文件，不能编辑已有文件。</p><p>3.将几个文件合并为一个文件:</p><pre><code>cat file1 file2 &gt; file</code></pre><ul><li>-b 对非空输出行号</li><li>-n 输出所有行号</li></ul><p><strong>实例：</strong></p><p>（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p><pre><code>cat -n log2012.log log2013.log</code></pre><p>（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p><pre><code>cat -b log2012.log log2013.log log.log</code></pre><p>（3）使用 here doc 生成新文件</p><pre><code>cat &gt;log.txt &lt;&lt;EOF&gt;Hello&gt;World&gt;PWD=$(pwd)&gt;EOFls -l log.txtcat log.txtHelloWorldPWD=/opt/soft/test</code></pre><p>（4）反向列示</p><pre><code>tac log.txtPWD=/opt/soft/testWorldHello</code></pre><h3 id="10、more-命令"><a href="#10、more-命令" class="headerlink" title="10、more 命令"></a>10、more 命令</h3><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p><p><strong>命令参数：</strong></p><pre><code>+n      从笫 n 行开始显示-n       定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c       从顶部清屏，然后显示-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l        忽略Ctrl+l（换页）字符-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s       把连续的多个空行显示为一行-u       把文件内容中的下画线去掉</code></pre><p><strong>常用操作命令：</strong></p><pre><code>Enter    向下 n 行，需要定义。默认为 1 行Ctrl+F   向下滚动一屏空格键  向下滚动一屏Ctrl+B  返回上一屏=       输出当前行的行号:f     输出文件名和当前行的行号V      调用vi编辑器!命令   调用Shell，并执行命令q       退出more</code></pre><p><strong>实例：</strong></p><p>（1）显示文件中从第3行起的内容</p><pre><code>more +3 text.txt</code></pre><p>（2）在所列出文件目录详细信息，借助管道使每次显示 5 行</p><pre><code>ls -l | more -5</code></pre><p>按空格显示下 5 行。</p><h3 id="11、less-命令"><a href="#11、less-命令" class="headerlink" title="11、less 命令"></a>11、less 命令</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><p><strong>常用命令参数：</strong></p><pre><code>-i  忽略搜索时的大小写-N  显示每行的行号-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-s  显示连续空行为一行/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）-x &lt;数字&gt; 将“tab”键显示为规定的数字空格b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]：   向上翻动一页</code></pre><p><strong>实例：</strong></p><p>（1）ps 查看进程信息并通过 less 分页显示</p><pre><code>ps -aux | less -N</code></pre><p>（2）查看多个文件</p><pre><code>less 1.log 2.log</code></pre><p>可以使用 n 查看下一个，使用 p 查看前一个。</p><h3 id="12、head-命令"><a href="#12、head-命令" class="headerlink" title="12、head 命令"></a>12、head 命令</h3><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p><p><strong>常用参数：</strong></p><pre><code>-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</code></pre><p><strong>实例：</strong></p><p>（1）显示 1.log 文件中前 20 行</p><pre><code>head 1.log -n 20</code></pre><p>（2）显示 1.log 文件前 20 字节</p><pre><code>head -c 20 log2014.log</code></pre><p>（3）显示 t.log最后 10 行</p><pre><code>head -n -10 t.log</code></pre><h3 id="13、tail-命令"><a href="#13、tail-命令" class="headerlink" title="13、tail 命令"></a>13、tail 命令</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><p><strong>常用参数：</strong></p><pre><code>-f 循环读取（常用于查看递增的日志文件）-n&lt;行数&gt; 显示行数（从后向前）</code></pre><p>（1）循环读取逐渐增加的文件内容</p><pre><code>ping 127.0.0.1 &gt; ping.log &amp;</code></pre><p>后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。</p><pre><code>tail -f ping.log</code></pre><p>（查看日志）</p><h3 id="14、which-命令"><a href="#14、which-命令" class="headerlink" title="14、which 命令"></a>14、which 命令</h3><p>在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p><pre><code>which     查看可执行文件的位置。whereis 查看文件的位置。locate  配合数据库查看文件位置。find        实际搜寻硬盘查询文件名称。</code></pre><p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p><strong>常用参数：</strong></p><pre><code>-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</code></pre><p><strong>实例：</strong></p><p>（1）查看 ls 命令是否存在，执行哪个</p><pre><code>which ls</code></pre><p>（2）查看 which</p><pre><code>which which</code></pre><p>（3）查看 cd</p><pre><code>which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）</code></pre><p>查看当前 PATH 配置：</p><pre><code>echo $PATH</code></pre><p>或使用 env 查看所有环境变量及对应值</p><h3 id="15、whereis-命令"><a href="#15、whereis-命令" class="headerlink" title="15、whereis 命令"></a>15、whereis 命令</h3><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。</p><p><strong>常用参数：</strong></p><pre><code>-b   定位可执行文件。-m   定位帮助文件。-s   定位源代码文件。-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</code></pre><p><strong>实例：</strong></p><p>（1）查找 locate 程序相关文件</p><pre><code>whereis locate</code></pre><p>（2）查找 locate 的源码文件</p><pre><code>whereis -s locate</code></pre><p>（3）查找 lcoate 的帮助文件</p><pre><code>whereis -m locate</code></pre><h3 id="16、locate-命令"><a href="#16、locate-命令" class="headerlink" title="16、locate 命令"></a>16、locate 命令</h3><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。</p><p>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找</p><p><strong>常用参数：</strong></p><pre><code>-l num（要显示的行数）-f   将特定的档案系统排除在外，如将proc排除在外-r   使用正则运算式做为寻找条件</code></pre><p><strong>实例：</strong></p><p>（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）</p><pre><code>locate pwd</code></pre><p>（2）搜索 etc 目录下所有以 sh 开头的文件</p><pre><code>locate /etc/sh</code></pre><p>（3）查找 /var 目录下，以 reason 结尾的文件</p><pre><code>locate -r &#39;^/var.*reason$&#39;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</code></pre><h3 id="17、find-命令"><a href="#17、find-命令" class="headerlink" title="17、find 命令"></a>17、find 命令</h3><p>用于在文件树中查找文件，并作出相应的处理。</p><p>命令格式：</p><pre><code>find pathname -options [-print -exec -ok ...]</code></pre><p>命令参数：</p><pre><code>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#39;command&#39; {  } \;，注意{   }和\；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</code></pre><p><strong>命令选项：</strong></p><pre><code>-name 按照文件名查找文件-perm 按文件权限查找文件-user 按文件属主查找文件-group  按照文件所属的组来查找文件。-type  查找某一类型的文件，诸如：   b - 块设备文件   d - 目录   c - 字符设备文件   l - 符号链接文件   p - 管道文件   f - 普通文件-size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小-amin n   查找系统中最后N分钟访问的文件-atime n  查找系统中最后n*24小时访问的文件-cmin n   查找系统中最后N分钟被改变文件状态的文件-ctime n  查找系统中最后n*24小时被改变文件状态的文件-mmin n   查找系统中最后N分钟被改变文件数据的文件-mtime n  查找系统中最后n*24小时被改变文件数据的文件(用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 )-maxdepth n 最大查找目录深度-prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略-newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项</code></pre><p><strong>实例：</strong></p><p>（1）查找 48 小时内修改过的文件</p><pre><code>find -atime -2</code></pre><p>（2）在当前目录查找 以 .log 结尾的文件。 <strong>.</strong> 代表当前目录</p><pre><code>find ./ -name &#39;*.log&#39;</code></pre><p>（3）查找 /opt 目录下 权限为 777 的文件</p><pre><code>find /opt -perm 777</code></pre><p>（4）查找大于 1K 的文件</p><pre><code>find -size +1000c</code></pre><p>查找等于 1000 字符的文件</p><pre><code>find -size 1000c </code></pre><p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。</p><p><strong>实例：</strong></p><p>（5）在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒）</p><pre><code>find . -type f -mtime +10 -exec rm -f {} \;</code></pre><p>（6）当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除</p><pre><code>find . -name &#39;*.log&#39; mtime +5 -ok -exec rm {} \;</code></pre><p>（7）当前目录下查找文件名以 passwd 开头，内容包含 “pkg” 字符的文件</p><pre><code>find . -f -name &#39;passwd*&#39; -exec grep &quot;pkg&quot; {} \;</code></pre><p>（8）用 exec 选项执行 cp 命令</p><pre><code>find . -name &#39;*.log&#39; -exec cp {} test3 \;</code></pre><p>-xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p><p>实例：</p><p>（9）查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型</p><pre><code>find . -type f -print | xargs file</code></pre><p>（10）查找当前目录下所有以 js 结尾的并且其中包含 ‘editor’ 字符的普通文件</p><pre><code>find . -type f -name &quot;*.js&quot; -exec grep -lF &#39;ueditor&#39; {} \;find -type f -name &#39;*.js&#39; | xargs grep -lF &#39;editor&#39;</code></pre><p>（11）利用 xargs 执行 mv 命令</p><pre><code>find . -name &quot;*.log&quot; | xargs -i mv {} test4</code></pre><p>（12）用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行：</p><pre><code>find . -name \*(转义） -type f -print | xargs grep -n &#39;hostnames&#39;</code></pre><p>（13）查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件：</p><pre><code>find . -name &#39;[a-z]*[4-9].log&#39; -print</code></pre><p>（14）在 test 目录查找不在 test4 子目录查找</p><pre><code>find test -path &#39;test/test4&#39; -prune -o -print</code></pre><p>（15）实例1：查找更改时间比文件 log2012.log新但比文件 log2017.log 旧的文件</p><pre><code>find -newer log2012.log ! -newer log2017.log</code></pre><p><strong>使用 depth 选项：</strong></p><p>depth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。</p><p>实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找</p><pre><code>find / -name &quot;CON.FILE&quot; -depth -print</code></pre><h3 id="18、chmod-命令"><a href="#18、chmod-命令" class="headerlink" title="18、chmod 命令"></a>18、chmod 命令</h3><p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p><p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。</p><p>以文件 log2012.log 为例：</p><pre><code>-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</code></pre><p>第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。</p><p>常用参数：</p><pre><code>-c 当发生改变时，报告处理信息-R 处理指定目录以及其子目录下所有文件</code></pre><p>权限范围：</p><pre><code>u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组</code></pre><p>权限代号：</p><pre><code>r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限</code></pre><p>实例：</p><p>（1）增加文件 t.log 所有用户可执行权限</p><pre><code>chmod a+x t.log</code></pre><p>（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p><pre><code>chmod u=r t.log -c</code></pre><p>（3）给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p><pre><code>chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c)</code></pre><p>（4）将 test 目录及其子目录所有文件添加可读权限</p><pre><code>chmod u+r,g+r,o+r -R text/ -c</code></pre><p>19、tar 命令</p><p>用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p><p>弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p><p><strong>常用参数：</strong></p><pre><code>-c 建立新的压缩文件-f 指定压缩文件-r 添加文件到已经压缩文件包中-u 添加改了和现有的文件到压缩包中-x 从压缩包中抽取文件-t 显示压缩文件中的内容-z 支持gzip压缩-j 支持bzip2压缩-Z 支持compress解压文件-v 显示操作过程</code></pre><p>有关 gzip 及 bzip2 压缩:</p><pre><code>gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gzbz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2</code></pre><p><strong>实例：</strong></p><p>（1）将文件全部打包成 tar 包</p><pre><code>tar -cvf log.tar 1.log,2.log 或tar -cvf log.*</code></pre><p>（2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p><pre><code>tar -zcvf /tmp/etc.tar.gz /etc</code></pre><p>（3）查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）</p><pre><code>tar -ztvf /tmp/etc.tar.gz</code></pre><p>（4）要压缩打包 /home, /etc ，但不要 /home/dmtsai</p><pre><code>tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc</code></pre><h3 id="20、chown-命令"><a href="#20、chown-命令" class="headerlink" title="20、chown 命令"></a>20、chown 命令</h3><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p><pre><code>-c 显示更改的部分的信息-R 处理指定目录及子目录</code></pre><p><strong>实例：</strong></p><p>（1）改变拥有者和群组 并显示改变信息</p><pre><code>chown -c mail:mail log2012.log</code></pre><p>（2）改变文件群组</p><pre><code>chown -c :mail t.log</code></pre><p>（3）改变文件夹及子文件目录属主及属组为 mail</p><pre><code>chown -cR mail: test/</code></pre><h3 id="21、df-命令"><a href="#21、df-命令" class="headerlink" title="21、df 命令"></a>21、df 命令</h3><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：</p><pre><code>-a 全部文件系统列表-h 以方便阅读的方式显示信息-i 显示inode信息-k 区块为1024字节-l 只显示本地磁盘-T 列出文件系统类型</code></pre><p><strong>实例：</strong></p><p>（1）显示磁盘使用情况</p><pre><code>df -l</code></pre><p>（2）以易读方式列出所有文件系统及其类型</p><pre><code>df -haT</code></pre><h3 id="22、du-命令"><a href="#22、du-命令" class="headerlink" title="22、du 命令"></a>22、du 命令</h3><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：</p><p>命令格式：</p><pre><code>du [选项] [文件]</code></pre><p><strong>常用参数：</strong></p><pre><code>-a 显示目录中所有文件大小-k 以KB为单位显示文件大小-m 以MB为单位显示文件大小-g 以GB为单位显示文件大小-h 以易读方式显示文件大小-s 仅显示总计-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</code></pre><p><strong>实例：</strong></p><p>（1）以易读方式显示文件夹内及子文件夹大小</p><pre><code>du -h scf/</code></pre><p>（2）以易读方式显示文件夹内所有文件大小</p><pre><code>du -ah scf/</code></pre><p>（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p><pre><code>du -hc test/ scf/</code></pre><p>（4）输出当前目录下各个子目录所使用的空间</p><pre><code>du -hc --max-depth=1 scf</code></pre><h3 id="23、ln-命令"><a href="#23、ln-命令" class="headerlink" title="23、ln 命令"></a>23、ln 命令</h3><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p><p>链接分类：软件链接及硬链接</p><p>软链接：</p><ul><li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li><li>2.软链接可以 跨文件系统 ，硬链接不可以</li><li>3.软链接可以对一个不存在的文件名进行链接</li><li>4.软链接可以对目录进行链接</li></ul><p>硬链接:</p><ul><li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>2.不允许给目录创建硬链接</li><li>3.硬链接只有在同一个文件系统中才能创建</li></ul><p><strong>需要注意：</strong></p><ul><li>第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</li><li>第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</li><li>第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</li></ul><p><strong>常用参数：</strong></p><pre><code>-b 删除，覆盖以前建立的链接-s 软链接（符号链接）-v 显示详细处理过程</code></pre><p><strong>实例：</strong></p><p>（1）给文件创建软链接，并显示操作信息</p><pre><code>ln -sv source.log link.log</code></pre><p>（2）给文件创建硬链接，并显示操作信息</p><pre><code>ln -v source.log link1.log</code></pre><p>（3）给目录创建软链接</p><pre><code>ln -sv /opt/soft/test/test3 /opt/soft/test/test5</code></pre><h3 id="24、date-命令"><a href="#24、date-命令" class="headerlink" title="24、date 命令"></a>24、date 命令</h3><p>显示或设定系统的日期与时间。</p><p>命令参数：</p><pre><code>-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。-u 　显示GMT。%H 小时(00-23)%I 小时(00-12)%M 分钟(以00-59来表示)%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。%S 秒(以本地的惯用法来表示)%a 星期的缩写。%A 星期的完整名称。%d 日期(以01-31来表示)。%D 日期(含年月日)。%m 月份(以01-12来表示)。%y 年份(以00-99来表示)。%Y 年份(以四位数来表示)。</code></pre><p><strong>实例：</strong></p><p>（1）显示下一天</p><pre><code>date +%Y%m%d --date=&quot;+1 day&quot;  //显示下一天的日期</code></pre><p>（2）-d参数使用</p><pre><code>date -d &quot;nov 22&quot;  今年的 11 月 22 日是星期三date -d &#39;2 weeks&#39; 2周后的日期date -d &#39;next monday&#39; (下周一的日期)date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%ddate -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%ddate -d last-month +%Y%m(上个月是几月)date -d next-month +%Y%m(下个月是几月)</code></pre><h3 id="25、cal-命令"><a href="#25、cal-命令" class="headerlink" title="25、cal 命令"></a>25、cal 命令</h3><p>可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份：</p><p>常用参数：</p><pre><code>-3 显示前一月，当前月，后一月三个月的日历-m 显示星期一为第一列-j 显示在当前年第几天-y [year]显示当前年[year]份的日历</code></pre><p><strong>实例：</strong></p><p>（1）显示指定年月日期</p><pre><code>cal 9 2012</code></pre><p>（2）显示2013年每个月日历</p><pre><code>cal -y 2013</code></pre><p>（3）将星期一做为第一列,显示前中后三月</p><pre><code>cal -3m</code></pre><h3 id="26、grep-命令"><a href="#26、grep-命令" class="headerlink" title="26、grep 命令"></a>26、grep 命令</h3><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p><p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>命令格式：</p><pre><code>grep [option] pattern file|dir</code></pre><p>常用参数：</p><pre><code>-A n --after-context显示匹配字符后n行-B n --before-context显示匹配字符前n行-C n --context 显示匹配字符前后n行-c --count 计算符合样式的列数-i 忽略大小写-l 只列出文件内容符合指定的样式的文件名称-f 从文件中读取关键词-n 显示匹配内容的所在文件中行数-R 递归查找文件夹</code></pre><p>grep 的规则表达式:</p><pre><code>^  #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 $  #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 .  #匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。  *  #匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。.*   #一起用代表任意字符。  []   #匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。 [^]  #匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  \(..\)  #标记匹配字符，如&#39;\(love\)&#39;，love被标记为1。   \&lt;      #锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行。\&gt;      #锚定单词的结束，如&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行。x\{m\}  #重复字符x，m次，如：&#39;0\{5\}&#39;匹配包含5个o的行。 x\{m,\}  #重复字符x,至少m次，如：&#39;o\{5,\}&#39;匹配至少有5个o的行。  x\{m,n\}  #重复字符x，至少m次，不多于n次，如：&#39;o\{5,10\}&#39;匹配5--10个o的行。  \w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。  \W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  \b    #单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep。</code></pre><p><strong>实例：</strong></p><p>（1）查找指定进程</p><pre><code>ps -ef | grep svn</code></pre><p>（2）查找指定进程个数</p><pre><code>ps -ef | grep svn -c</code></pre><p>（3）从文件中读取关键词</p><pre><code>cat test1.txt | grep -f key.log</code></pre><p>（4）从文件夹中递归查找以grep开头的行，并只列出文件</p><pre><code>grep -lR &#39;^grep&#39; /tmp</code></pre><p>（5）查找非x开关的行内容</p><pre><code>grep &#39;^[^x]&#39; test.txt</code></pre><p>（6）显示包含 ed 或者 at 字符的内容行</p><pre><code>grep -E &#39;ed|at&#39; test.txt</code></pre><h3 id="27、wc-命令"><a href="#27、wc-命令" class="headerlink" title="27、wc 命令"></a>27、wc 命令</h3><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p><p>命令格式：</p><pre><code>wc [option] file..</code></pre><p><strong>命令参数：</strong></p><pre><code>-c 统计字节数-l 统计行数-m 统计字符数-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</code></pre><p><strong>实例：</strong></p><p>（1）查找文件的 行数 单词数 字节数 文件名</p><pre><code>wc text.txt</code></pre><p>结果：</p><pre><code>7     8     70     test.txt</code></pre><p>（2）统计输出结果的行数</p><pre><code>cat test.txt | wc -l</code></pre><h3 id="28、ps-命令"><a href="#28、ps-命令" class="headerlink" title="28、ps 命令"></a>28、ps 命令</h3><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top</p><p>linux上进程有5种状态:</p><ul><li><ol><li>运行(正在运行或在运行队列中等待)</li></ol></li><li><ol start="2"><li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li></ol></li><li><ol start="3"><li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li></ol></li><li><ol start="4"><li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li></ol></li><li><ol start="5"><li>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</li></ol></li></ul><p>ps 工具标识进程的5种状态码:</p><pre><code>D 不可中断 uninterruptible sleep (usually IO)R 运行 runnable (on run queue)S 中断 sleepingT 停止 traced or stoppedZ 僵死 a defunct (”zombie”) process</code></pre><p><strong>命令参数：</strong></p><pre><code>-A 显示所有进程a 显示所有进程-a 显示同一终端下所有进程c 显示进程真实名称e 显示环境变量f 显示进程间的关系r 显示当前终端运行的进程-aux 显示所有包含其它使用的进程</code></pre><p><strong>实例：</strong></p><p>（1）显示当前所有进程环境变量及进程间关系</p><pre><code>ps -ef</code></pre><p>（2）显示当前所有进程</p><pre><code>ps -A</code></pre><p>（3）与grep联用查找某进程</p><pre><code>ps -aux | grep apache</code></pre><p>（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码</p><pre><code>ps aux | grep &#39;(cron|syslog)&#39;</code></pre><p>29、top 命令</p><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</p><p><strong>常用参数：</strong></p><pre><code>-c 显示完整的进程命令-s 保密模式-p &lt;进程号&gt; 指定进程显示-n &lt;次数&gt;循环显示次数</code></pre><p>实例：</p><p><strong>（1）</strong></p><pre><code>top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombieCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%stMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffersSwap: 32764556k total,        0k used, 32764556k free,  3612636k cachedPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  </code></pre><p>前五行是当前系统情况整体的统计信息区。</p><p><strong>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</strong></p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p><strong>第二行，Tasks — 任务（进程），具体信息说明如下：</strong></p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p><strong>第三行，cpu状态信息，具体属性说明如下：</strong></p><pre><code>5.9%us — 用户空间占用CPU的百分比。3.4% sy — 内核空间占用CPU的百分比。0.0% ni — 改变过优先级的进程占用CPU的百分比90.4% id — 空闲CPU百分比0.0% wa — IO等待占用CPU的百分比0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比0.2% si — 软中断（Software Interrupts）占用CPU的百分比</code></pre><p><strong>备注：</strong>在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p>第四行，内存状态，具体信息如下：</p><pre><code>32949016k total — 物理内存总量（32GB）14411180k used — 使用中的内存总量（14GB）18537836k free — 空闲内存总量（18GB）169884k buffers — 缓存的内存量 （169M）</code></pre><p><strong>第五行，swap交换分区信息，具体信息说明如下：</strong></p><pre><code>32764556k total — 交换区总量（32GB）0k used — 使用的交换区总量（0K）32764556k free — 空闲交换区总量（32GB）3612636k cached — 缓冲的交换区总量（3.6GB）</code></pre><p><strong>第六行，空行。</strong></p><p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</strong></p><pre><code>PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR — 共享内存大小，单位kbS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行）</code></pre><p><strong>top 交互命令</strong></p><pre><code>h 显示top交互命令帮助信息c 切换显示命令名称和完整命令行m 以内存使用率排序P 根据CPU使用百分比大小进行排序T 根据时间/累计时间进行排序W 将当前设置写入~/.toprc文件中o或者O 改变显示项目的顺序</code></pre><h3 id="30、kill-命令"><a href="#30、kill-命令" class="headerlink" title="30、kill 命令"></a>30、kill 命令</h3><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><p><strong>常用参数：</strong></p><pre><code>-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称-a  当处理当前进程时，不限制命令名和进程号的对应关系-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号-s  指定发送信号-u  指定用户</code></pre><p><strong>实例：</strong></p><p>（1）先使用ps查找进程pro1，然后用kill杀掉</p><pre><code>kill -9 $(ps -ef | grep pro1)</code></pre><h3 id="31、free-命令"><a href="#31、free-命令" class="headerlink" title="31、free 命令"></a>31、free 命令</h3><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p><p><strong>命令参数：</strong></p><pre><code>-b 以Byte显示内存使用情况-k 以kb为单位显示内存使用情况-m 以mb为单位显示内存使用情况-g 以gb为单位显示内存使用情况-s&lt;间隔秒数&gt; 持续显示内存-t 显示内存使用总合</code></pre><p><strong>实例：</strong></p><p>（1）显示内存使用情况</p><pre><code>freefree -kfree -m</code></pre><p>（2）以总和的形式显示内存的使用信息</p><pre><code>free -t</code></pre><p>（3）周期性查询内存使用情况</p><pre><code>free -s 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-数据结构</title>
      <link href="/2019/10/06/mian-shi-shu-ju-jie-gou/"/>
      <url>/2019/10/06/mian-shi-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E7%BB%AA%E8%AE%BA.jpg" alt="数据结构"></p><h2 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1570360192307.jpg" alt="数据结构"></p><h3 id="2-1-数组与链表"><a href="#2-1-数组与链表" class="headerlink" title="2.1 数组与链表"></a>2.1 数组与链表</h3><h4 id="（1）数组的特点："><a href="#（1）数组的特点：" class="headerlink" title="（1）数组的特点："></a>（1）数组的特点：</h4><p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p><p><strong>数组的优点：</strong></p><blockquote><ol><li>随机访问性强</li><li>查找速度快</li></ol></blockquote><p><strong>数组的缺点:</strong></p><blockquote><ol><li>插入和删除效率低</li><li>可能浪费内存</li><li>内存空间要求高，必须有足够的连续内存空间。</li><li>数组大小固定，不能动态拓展</li></ol></blockquote><h4 id="（2）链表的特点："><a href="#（2）链表的特点：" class="headerlink" title="（2）链表的特点："></a>（2）链表的特点：</h4><p>链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</p><p><strong>链表的优点:</strong></p><blockquote><ol><li>插入删除速度快</li><li>内存利用率高，不会浪费内存</li><li>大小没有固定，拓展很灵活。</li></ol></blockquote><p><strong>链表的缺点:</strong></p><blockquote><ol><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ol></blockquote><h3 id="2-2-问题"><a href="#2-2-问题" class="headerlink" title="2.2 问题"></a>2.2 问题</h3><h4 id="（1）一个长度为N的整形数组，数组中每个元素的取值范围是-0-n-1-判断该数组否有重复的数，请说一下你的思路并手写代码"><a href="#（1）一个长度为N的整形数组，数组中每个元素的取值范围是-0-n-1-判断该数组否有重复的数，请说一下你的思路并手写代码" class="headerlink" title="（1）一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码"></a>（1）一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</h4><p>把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p><h4 id="（2）请你手写代码，如何合并两个有序链表"><a href="#（2）请你手写代码，如何合并两个有序链表" class="headerlink" title="（2）请你手写代码，如何合并两个有序链表"></a>（2）请你手写代码，如何<strong>合并两个有序链表</strong></h4><h4 id="（3）-手写代码：反转链表"><a href="#（3）-手写代码：反转链表" class="headerlink" title="（3） 手写代码：反转链表"></a>（3） 手写代码：反转链表</h4><h4 id="（4）-判断一个链表是否为回文链表，说出你的思路并手写代码"><a href="#（4）-判断一个链表是否为回文链表，说出你的思路并手写代码" class="headerlink" title="（4） 判断一个链表是否为回文链表，说出你的思路并手写代码"></a>（4） 判断一个链表是否为回文链表，说出你的思路并手写代码</h4><h4 id="（5）什么是单向链表，如何判断两个单向链表是否相交"><a href="#（5）什么是单向链表，如何判断两个单向链表是否相交" class="headerlink" title="（5）什么是单向链表，如何判断两个单向链表是否相交"></a>（5）什么是单向链表，如何判断两个单向链表是否相交</h4><h2 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3. 栈和队列"></a>3. 栈和队列</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1570360235018.jpg" alt="数据结构"></p><h3 id="3-1-请你回答一下栈和堆的区别，以及为什么栈要快"><a href="#3-1-请你回答一下栈和堆的区别，以及为什么栈要快" class="headerlink" title="3.1 请你回答一下栈和堆的区别，以及为什么栈要快"></a>3.1 请你回答一下栈和堆的区别，以及为什么栈要快</h3><h4 id="（1）堆和栈的区别"><a href="#（1）堆和栈的区别" class="headerlink" title="（1）堆和栈的区别"></a>（1）堆和栈的区别</h4><blockquote><p>1）申请方式：</p><p>栈由系统自动分配和管理，堆由程序员手动分配和管理。</p><p>2）效率：</p><p>栈由系统分配，速度快，不会有内存碎片。</p><p>堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。</p><p>3）扩展方向</p><p>栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。</p><p>4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。</p></blockquote><h4 id="（2）栈的效率高的原因"><a href="#（2）栈的效率高的原因" class="headerlink" title="（2）栈的效率高的原因"></a>（2）栈的效率高的原因</h4><blockquote><p>栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；</p><p>而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p></blockquote><h4 id="（3）-小根堆与大根堆"><a href="#（3）-小根堆与大根堆" class="headerlink" title="（3） 小根堆与大根堆"></a>（3） 小根堆与大根堆</h4><p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p><blockquote><p><strong>1）小根堆</strong></p><p>若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p><p><strong>2）大根堆</strong></p><p>若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p></blockquote><h3 id="3-2-问题"><a href="#3-2-问题" class="headerlink" title="3.2 问题"></a>3.2 问题</h3><h4 id="（1）请说一说你理解的stack-overflow，并举个简单例子导致栈溢出"><a href="#（1）请说一说你理解的stack-overflow，并举个简单例子导致栈溢出" class="headerlink" title="（1）请说一说你理解的stack overflow，并举个简单例子导致栈溢出"></a>（1）请说一说你理解的stack overflow，并举个简单例子导致栈溢出</h4><p><strong>栈溢出概念：</strong></p><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p><p><strong>栈溢出的原因：</strong></p><blockquote><ol><li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li><li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li><li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li></ol></blockquote><p><strong>栈溢出例子：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>#include <string.h>int main(int argc, char* argv[]) {    char buf[256];    strcpy(buf,argv[1]);    printf("Input:%s\n",buf);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中的strcpy(buf,argv[1]);这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。</p><h4 id="（2）手写代码：两个栈实现一个队列"><a href="#（2）手写代码：两个栈实现一个队列" class="headerlink" title="（2）手写代码：两个栈实现一个队列"></a>（2）手写代码：两个栈实现一个队列</h4><h2 id="4-树与二叉树"><a href="#4-树与二叉树" class="headerlink" title="4. 树与二叉树"></a>4. 树与二叉树</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1570360260147.jpg" alt="数据结构"></p><h3 id="4-1-平衡二叉树（AVL树）与红黑树"><a href="#4-1-平衡二叉树（AVL树）与红黑树" class="headerlink" title="4.1 平衡二叉树（AVL树）与红黑树"></a>4.1 平衡二叉树（AVL树）与红黑树</h3><blockquote><h5 id="（1）平衡二叉树（AVL树）："><a href="#（1）平衡二叉树（AVL树）：" class="headerlink" title="（1）平衡二叉树（AVL树）："></a>（1）平衡二叉树（AVL树）：</h5><blockquote><p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p></blockquote><h5 id="（2）红黑树："><a href="#（2）红黑树：" class="headerlink" title="（2）红黑树："></a>（2）红黑树：</h5><p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p><p>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。</p><p><strong>性质：</strong></p><blockquote><ul><li>每个节点非红即黑</li><li>根节点是黑的;</li><li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</li></ul></blockquote><p><strong>红黑树的旋转</strong></p><p>旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。</p><blockquote><p><strong>左旋：</strong>对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656212115_1587159E7ADB036880D502D2927B9597" alt="img"></p><p><strong>右旋：</strong>对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子</p><p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656223637_991B891FAD560CB072639E0791F9CBB7" alt="img"></p></blockquote><h5 id="（3）区别："><a href="#（3）区别：" class="headerlink" title="（3）区别："></a>（3）区别：</h5><blockquote><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；</p><p>红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p></blockquote></blockquote><h3 id="4-2-哈夫曼树"><a href="#4-2-哈夫曼树" class="headerlink" title="4.2 哈夫曼树"></a>4.2 哈夫曼树</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><blockquote><p>在含有N个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称为最优二叉树。</p></blockquote><h4 id="（2）构造"><a href="#（2）构造" class="headerlink" title="（2）构造"></a>（2）构造</h4><blockquote><ol><li>哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。</li><li>算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T。</li><li>假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T。</li></ol></blockquote><h4 id="（3）哈夫曼编码"><a href="#（3）哈夫曼编码" class="headerlink" title="（3）哈夫曼编码"></a>（3）哈夫曼编码</h4><blockquote><p>可变长度编码比固定长度编码好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</p></blockquote><h3 id="4-3-B树与B-树"><a href="#4-3-B树与B-树" class="headerlink" title="4.3 B树与B+树"></a>4.3 B树与B+树</h3><p>b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树</p><h4 id="（1）B树"><a href="#（1）B树" class="headerlink" title="（1）B树"></a>（1）B树</h4><p>一个M阶的b树具有如下几个特征：</p><blockquote><p>1）树中每个结点至多有m棵子树（即至多含有m-1个关键字）</p><p>2）若根结点不是终端结点，则至少有两棵子树。</p><p>3）除根结点外的所有非叶结点至少有「m/2]棵子树（即至少含有「m/2]-1个关键字</p><p>4）n个节点有n+1个子树</p><p>5）所有的叶结点都出现在同一层次上，并且不带信息</p></blockquote><h4 id="（2）B树"><a href="#（2）B树" class="headerlink" title="（2）B树"></a>（2）B树</h4><p>B+是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键值的大小顺序存放在同一层的叶节点中。</p><p>一个M阶的b+树具有如下几个特征：</p><blockquote><p>1）每个分支结点最多有m棵子树（子结点）</p><p>2）非叶根结点至少有两棵子树，其他每个分支结点至少有「m/2]棵子树</p><p>3）结点的子树个数与关键字个数相等。</p><p>4）所有叶结点包含全部关键字及指向相应记录的指针，而且叶结点中将关键字按大小顺序排列，并且相邻叶</p><p>结点按大小顺序相互链接起来。</p><p>5）所有分支结点（可看成是索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值</p><p>及指向其子结点的指针</p></blockquote><h4 id="（3）b-树相比于b树的查询优势"><a href="#（3）b-树相比于b树的查询优势" class="headerlink" title="（3）b+树相比于b树的查询优势"></a>（3）b+树相比于b树的查询优势</h4><blockquote><ol><li>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；</li><li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li><li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历</li></ol></blockquote><h3 id="4-4-并查集"><a href="#4-4-并查集" class="headerlink" title="4.4 并查集"></a>4.4 并查集</h3><h4 id="（1）-概念"><a href="#（1）-概念" class="headerlink" title="（1） 概念"></a>（1） 概念</h4><p>并査集是一种简单的集合表示，它支持以下3种操作</p><blockquote><ol><li>Union(S,Root1,Root2)：把集合S中的子集合Root2并入子集合 Root1中。要求Root1和Root2互不相交，否则不执行合并。</li><li>Find(s,x)：查找集合S中单元素x所在的子集合，并返回该子集合的名字。</li><li>Initial(s)：将集合S中每一个元素都初始化为只有一个单元素的子集合。</li></ol></blockquote><p>通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，根结点的下标代表子集合名，根结点的双亲结点为负数。</p><h3 id="4-5-问题"><a href="#4-5-问题" class="headerlink" title="4.5 问题"></a>4.5 问题</h3><h4 id="（1）请你回答一下map底层为什么用红黑树实现"><a href="#（1）请你回答一下map底层为什么用红黑树实现" class="headerlink" title="（1）请你回答一下map底层为什么用红黑树实现"></a>（1）请你回答一下map底层为什么用红黑树实现</h4><p><strong>红黑树较AVL树的优点：</strong></p><blockquote><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；</p><p>红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p></blockquote><h4 id="（2）请你说一说map和unordered-map的底层实现"><a href="#（2）请你说一说map和unordered-map的底层实现" class="headerlink" title="（2）请你说一说map和unordered_map的底层实现"></a>（2）请你说一说map和unordered_map的底层实现</h4><p>map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。</p><h4 id="（3）请你回答一下map和unordered-map优点和缺点"><a href="#（3）请你回答一下map和unordered-map优点和缺点" class="headerlink" title="（3）请你回答一下map和unordered_map优点和缺点"></a>（3）请你回答一下map和unordered_map优点和缺点</h4><p>对于map，其底层是基于红黑树实现的</p><p><strong>优点如下：</strong></p><blockquote><p>1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</p><p>2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</p></blockquote><p><strong>缺点如下：</strong></p><blockquote><p>1）查找、删除、增加等操作平均时间复杂度较慢，与n相关</p></blockquote><p>对于unordered_map来说，其底层是一个哈希表</p><p><strong>优点如下：</strong></p><blockquote><p>查找、删除、添加的速度快，时间复杂度为常数级O(c)</p></blockquote><p><strong>缺点如下：</strong></p><blockquote><p>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</p><p>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</p></blockquote><h4 id="（4）请你回答一下epoll怎么实现的"><a href="#（4）请你回答一下epoll怎么实现的" class="headerlink" title="（4）请你回答一下epoll怎么实现的"></a>（4）请你回答一下epoll怎么实现的</h4><blockquote><p>Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。</p></blockquote><h3 id="4-6-问题"><a href="#4-6-问题" class="headerlink" title="4.6 问题"></a>4.6 问题</h3><h4 id="（1）-请你实现二叉树的层序遍历并输出"><a href="#（1）-请你实现二叉树的层序遍历并输出" class="headerlink" title="（1） 请你实现二叉树的层序遍历并输出"></a>（1） 请你实现二叉树的层序遍历并输出</h4><pre class="line-numbers language-c++"><code class="language-c++">void layerTrace(BTreeNode *T){    if(T== nullptr)return;    BTreeNode *p=T;    queue<BTreeNode*>q;    q.push(p);    while(!q.empty())    {        p=q.front();        q.pop();        cout<<<<p->data;        if(p->left!= nullptr)q.push(p->left);        if(p->right!= nullptr)q.push(p->right);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（2）手写代码：二叉树序列化反序列化"><a href="#（2）手写代码：二叉树序列化反序列化" class="headerlink" title="（2）手写代码：二叉树序列化反序列化"></a>（2）手写代码：二叉树序列化反序列化</h4><blockquote><p>序列化：必须保存一个中序遍历结果，然后外加一个前序或者后序遍历结果反序列化：根据两次遍历生成的结果恢复二叉树，代码如下(前序和中序)：</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">TreeNode* helper(vector<int>pre,int startPre,int endPre,vector<int>in,int startIn,int endIn){    if(startPre>endPre||startIn>endIn)        return nullptr;    TreeNode * root=new TreeNode(pre[startPre]);    for(int i=startIn;i<=endIn;++i){        if(in[i]==pre[startPre]){            root->left=helper(pre,startPre+1,startPre+i-                        startIn,in,startIn,i-1);            root->right=helper(pre,i-        startIn+startPre+1,endPre,in,i+1,endIn);        break;        }    }    return root;}TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin){    TreeNode*root=helper(pre,0,pre.size()-1,vin,0,vin.size()-1);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-图"><a href="#5-图" class="headerlink" title="5. 图"></a>5. 图</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1570360310878.jpg" alt="数据结构"></p><h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6. 查找"></a>6. 查找</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1570360331045.jpg" alt="数据结构"></p><h3 id="6-1-哈希"><a href="#6-1-哈希" class="headerlink" title="6.1 哈希"></a>6.1 哈希</h3><h4 id="1）请你来说一说hash表的实现，包括STL中的哈希桶长度常数"><a href="#1）请你来说一说hash表的实现，包括STL中的哈希桶长度常数" class="headerlink" title="(1）请你来说一说hash表的实现，包括STL中的哈希桶长度常数"></a>(1）请你来说一说hash表的实现，包括STL中的哈希桶长度常数</h4><p>hash表的实现主要包括构造哈希和处理哈希冲突两个方面：</p><p>对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。</p><p>对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。SGL版本使用链地址法，使用一个链表保持相同散列值的元素。</p><p>虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL仍然以质数来设计哈希桶长度，并且将28个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数。</p><h4 id="（2）-请你回答一下hash表如何rehash，以及怎么处理其中保存的资源"><a href="#（2）-请你回答一下hash表如何rehash，以及怎么处理其中保存的资源" class="headerlink" title="（2） 请你回答一下hash表如何rehash，以及怎么处理其中保存的资源"></a>（2） 请你回答一下hash表如何rehash，以及怎么处理其中保存的资源</h4><p>C++的hash表中有一个负载因子loadFactor，当loadFactor&lt;=1时，hash表查找的期望复杂度为O(1). 因此，每次往hash表中添加元素时，我们必须保证是在loadFactor &lt;1的情况下，才能够添加。</p><p>因此，当Hash表中loadFactor==1时，Hash就需要进行rehash。rehash过程中，会模仿C++的vector扩容方式，Hash表中每次发现loadFactor ==1时，就开辟一个原来桶数组的两倍空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。</p><h4 id="（3）请你说一下哈希表的桶个数为什么是质数，合数有何不妥？"><a href="#（3）请你说一下哈希表的桶个数为什么是质数，合数有何不妥？" class="headerlink" title="（3）请你说一下哈希表的桶个数为什么是质数，合数有何不妥？"></a>（3）请你说一下哈希表的桶个数为什么是质数，合数有何不妥？</h4><p>哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。</p><p>算法：</p><p>给定一个数字数组，返回哈夫曼树的头指针</p><pre class="line-numbers language-c++"><code class="language-c++">struct BTreeNode* CreateHuffman(ElemType a[], int n){    int i, j;    struct BTreeNode **b, *q;    b = malloc(n*sizeof(struct BTreeNode));    for (i = 0; i < n; i++){        b[i] = malloc(sizeof(struct BTreeNode));        b[i]->data = a[i];        b[i]->left = b[i]->right = NULL;    }    for (i = 1; i < n; i++){        int k1 = -1, k2;        for (j = 0; j < n; j++){            if (b[j] != NULL && k1 == -1){                k1 = j;                continue;            }            if (b[j] != NULL){                k2 = j;                break;            }        }        for (j = k2; j < n; j++){            if (b[j] != NULL){                if (b[j]->data < b[k1]->data){                    k2 = k1;                    k1 = j;                }else if (b[j]->data < b[k2]->data)                    k2 = j;                }            }            q = malloc(sizeof(struct BTreeNode));            q->data = b[k1]->data + b[k2]->data;            q->left = b[k1];            q->right = b[k2];            b[k1] = q;            b[k2] = NULL;        }        free(b);        return q;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（4）请你说一下解决hash冲突的方法"><a href="#（4）请你说一下解决hash冲突的方法" class="headerlink" title="（4）请你说一下解决hash冲突的方法"></a>（4）请你说一下解决hash冲突的方法</h4><p>当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样的现象称为哈希冲突。目前常用的解决哈希冲突的方法如下：</p><blockquote><ul><li>开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</li><li>再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</li><li>链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</li><li>建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</li></ul></blockquote><h2 id="7-排序"><a href="#7-排序" class="headerlink" title="7. 排序"></a>7. 排序</h2><p><img src="/2019/10/06/mian-shi-shu-ju-jie-gou/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1570360356519.jpg" alt="数据结构"></p><h3 id="7-1-各种排序算法及时间复杂度"><a href="#7-1-各种排序算法及时间复杂度" class="headerlink" title="7.1 各种排序算法及时间复杂度"></a>7.1 各种排序算法及时间复杂度</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E" alt="img"></p><blockquote><p><strong>插入排序：</strong>对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p><p><strong>希尔排序：</strong>先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p><p><strong>归并排序：</strong>该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p><p><strong>冒泡排序：</strong>对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p><p><strong>快速排序：</strong>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p><strong>选择排序：</strong>每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p><p><strong>堆排序：</strong>堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p></blockquote><h3 id="7-2-问题"><a href="#7-2-问题" class="headerlink" title="7.2 问题"></a>7.2 问题</h3><h4 id="（1）请你来手写一下快排的代码"><a href="#（1）请你来手写一下快排的代码" class="headerlink" title="（1）请你来手写一下快排的代码"></a>（1）请你来手写一下快排的代码</h4><pre class="line-numbers language-c++"><code class="language-c++">int once_quick_sort(vector<int> &data, int left, int right){    int key = data[left];    while (left < right)    {        while (left < right && key <= data[right]){            right--;        }        if (left < right){            data[left++] = data[right];        }        while (left < right && key > data[left]){            left++;        }        if (left < right){            data[right--] = data[left];        }    }    data[left] = key;    return left;}int quick_sort(vector<int> & data, int left, int right){    if (left >= right )    {        return 1;    }    int middle = 0;    middle = once_quick_sort(data, left, right);    quick_sort(data, left, middle-1);    quick_sort(data, middle + 1, right);}；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（2）-请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素"><a href="#（2）-请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素" class="headerlink" title="（2） 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素"></a>（2） 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</h4><blockquote><ul><li>首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)</li><li>使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)</li><li>首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数</li><li>利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。</li><li>当有相同元素的时候，首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)</li></ul></blockquote><h4 id="（3）请问海量数据如何去取最大的k个"><a href="#（3）请问海量数据如何去取最大的k个" class="headerlink" title="（3）请问海量数据如何去取最大的k个"></a>（3）请问海量数据如何去取最大的k个</h4><p><strong>1.直接全部排序（只适用于内存够的情况）</strong></p><blockquote><p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p><p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p></blockquote><p><strong>2.快速排序的变形 （只使用于内存够的情况）</strong></p><blockquote><p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p><p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p></blockquote><p><strong>3.最小堆法</strong></p><blockquote><p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p></blockquote><p><strong>4.分治法</strong></p><blockquote><p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p></blockquote><p><strong>5.Hash法</strong></p><blockquote><p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p></blockquote><h2 id="8-动态规划"><a href="#8-动态规划" class="headerlink" title="8. 动态规划"></a>8. 动态规划</h2><h3 id="8-1最长公共子序列"><a href="#8-1最长公共子序列" class="headerlink" title="8.1最长公共子序列"></a>8.1最长公共子序列</h3><h3 id="8-2-求一个字符串最长回文子串"><a href="#8-2-求一个字符串最长回文子串" class="headerlink" title="8.2 求一个字符串最长回文子串"></a>8.2 求一个字符串最长回文子串</h3><h3 id="8-3-查找最长回文子串"><a href="#8-3-查找最长回文子串" class="headerlink" title="8.3 查找最长回文子串"></a>8.3 查找最长回文子串</h3><h2 id="9-高级算法"><a href="#9-高级算法" class="headerlink" title="9. 高级算法"></a>9. 高级算法</h2><h3 id="9-1-加密方法都有哪些"><a href="#9-1-加密方法都有哪些" class="headerlink" title="9.1 加密方法都有哪些"></a>9.1 加密方法都有哪些</h3><p>考察点：密码学</p><p>公司：腾讯</p><p>1、单向加密</p><p>单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：</p><blockquote><ul><li>MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；</li><li>SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值。其变种由SHA192，SHA256，SHA384等；</li><li>CRC-32，主要用于提供校验功能；</li></ul></blockquote><p>算法特征：</p><blockquote><ul><li>输入一样，输出必然相同；</li><li>雪崩效应，输入的微小改变，将会引起结果的巨大变化；</li><li>定长输出，无论原始数据多大，结果大小都是相同的；</li><li>不可逆，无法根据特征码还原原来的数据；</li></ul></blockquote><p>2、对称加密</p><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p><p>特点：</p><blockquote><ul><li>加密方和解密方使用同一个密钥；</li><li>加密解密的速度比较快，适合数据比较长时的使用；</li><li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</li></ul></blockquote><p>优点：</p><blockquote><p>对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</p></blockquote><p>缺点：</p><blockquote><p>对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p></blockquote><p>3、非对称加密</p><p>非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。</p><p>特征：</p><blockquote><ul><li>秘钥对，公钥(public key)和私钥(secret key)</li><li>主要功能：加密和签名</li></ul><blockquote><p>发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。</p><p>发送方用自己的私钥加密，可以实现身份验证（数字签名）。</p></blockquote><ul><li>公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。</li></ul></blockquote><p>常用的非对称加密算法</p><blockquote><ul><li>RSA：由 RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；既可以实现加密，又可以实现签名。</li><li>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。</li><li>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。</li></ul></blockquote><h3 id="9-2-什么是LRU缓存"><a href="#9-2-什么是LRU缓存" class="headerlink" title="9.2 什么是LRU缓存"></a>9.2 什么是LRU缓存</h3><p>LRU缓存即保存最近经常使用的数据的内存空间，这样当再次读取该数据时可直接从缓存中读取提高效率</p><h3 id="9-3-请你说一说洗牌算法"><a href="#9-3-请你说一说洗牌算法" class="headerlink" title="9.3 请你说一说洗牌算法"></a>9.3 请你说一说洗牌算法</h3><p>1、Fisher-Yates Shuffle算法</p><p>最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle，其基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下：</p><blockquote><p>1）初始化原始数组和新数组，原始数组长度为n(已知)。</p><p>2）从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）。</p><p>3）从剩下的k个数中把第p个数取出。</p><p>4）重复步骤2和3直到数字全部取完。</p><p>5）从步骤3取出的数字序列便是一个打乱了的数列。</p></blockquote><p><strong>时间复杂度为O(n*n)，空间复杂度为O(n)。</strong></p><p>2）Knuth-Durstenfeld Shuffle</p><p>Knuth 和 Durstenfeld  在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</p><p>算法步骤为：</p><blockquote><ol><li>建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</li><li>生成一个从 0 到 n - 1 的随机数 x；</li><li>输出 arr 下标为 x 的数值，即为第一个随机数；</li><li>将 arr 的尾元素和下标为 x 的元素互换；</li><li>同2，生成一个从 0 到 n - 2 的随机数 x；</li><li>输出 arr 下标为 x 的数值，为第二个随机数；</li><li>将 arr 的倒数第二个元素和下标为 x 的元素互换；</li><li>……</li><li>如上，直到输出m 个数为止</li></ol></blockquote><p><strong>时间复杂度为O(n)，空间复杂度为O(1)，缺点必须知道数组长度n。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
