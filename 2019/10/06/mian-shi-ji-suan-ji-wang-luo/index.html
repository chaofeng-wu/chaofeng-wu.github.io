<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="面试-计算机网络, 吴超峰的博客">
    <meta name="baidu-site-verification" content="72b9FEAmOi">
    <meta name="google-site-verification" content="72b9FEAmOi">
    <meta name="360-site-verification" content>
    <meta name="description" content="1. 网络模型1.1 OSI七层模型和TCP/IP四层模型
（1）OSI 七层模型

物理层：通过媒介传输比特,确定机械及电气规范,传输单位为bit。
数据链路层：定义了如何让格式化数据以数据帧为单位进行传输，以及如何让控制对物理介质的访问">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>面试-计算机网络 | 吴超峰的博客</title>
    <link rel="icon" type="image/jpeg" href="/logo.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">吴超峰的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">吴超峰的博客</div>
        <div class="logo-desc">
            
            南京大学 | 计算机科学与技术系
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://chaofeng-wu.github.io/" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://chaofeng-wu.github.io/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        面试-计算机网络
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/计算机网络/" target="_blank">
                            <span class="chip bg-color">计算机网络</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/面试/" class="post-category" target="_blank">
                            面试
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-10-06
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    吴超峰
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    54 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="1-网络模型"><a href="#1-网络模型" class="headerlink" title="1. 网络模型"></a>1. 网络模型</h3><h4 id="1-1-OSI七层模型和TCP-IP四层模型"><a href="#1-1-OSI七层模型和TCP-IP四层模型" class="headerlink" title="1.1 OSI七层模型和TCP/IP四层模型"></a>1.1 OSI七层模型和TCP/IP四层模型</h4><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826496.png" alt="img"></p>
<h5 id="（1）OSI-七层模型"><a href="#（1）OSI-七层模型" class="headerlink" title="（1）OSI 七层模型"></a>（1）OSI 七层模型</h5><blockquote>
<ol>
<li><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范,传输单位为bit。</li>
<li><strong>数据链路层：</strong>定义了如何让格式化数据以数据帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。（即 封装成帧、透明传输、差错检测）。（将比特组装成帧和点到点的传递）</li>
<li><strong>网络层：</strong>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet 的发展使得从世界各个站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。即 网络层负责数据包从源到宿的传递和网际互连（主机之间的通信）</li>
<li><strong>传输层：</strong>定义了一些传输数据的协议和端口(www 端口 80 等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天就是通过这种方式传输的）。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。传输层，提供端到端的可靠报文传递和错误恢复（应用进程之间的通信）</li>
<li><strong>会话层：</strong>通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接收会话请求。（设备之间需要相互认识可以是 IP 也可以是 MAC 或者是主机名）。即，会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li><strong>表示层：</strong>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC 程序员与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。即，<strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li><strong>应用层：</strong>是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li>
</ol>
</blockquote>
<h5 id="（2）各层常见协议"><a href="#（2）各层常见协议" class="headerlink" title="（2）各层常见协议"></a>（2）各层常见协议</h5><p><strong>OSI七层协议</strong></p>
<table>
<thead>
<tr>
<th>层</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>IEE802.3、CLOCK、RJ45</td>
</tr>
<tr>
<td>数据链路层</td>
<td>MAC、VLAN、PPP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP、ARP、ICMP</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>会话层</td>
<td>RPC、NFS</td>
</tr>
<tr>
<td>表示层</td>
<td>JPE、 ASII</td>
</tr>
<tr>
<td>应用层</td>
<td>FTP、HTTP、DNS</td>
</tr>
</tbody></table>
<p><strong>TCP/IP四层协议</strong></p>
<table>
<thead>
<tr>
<th>层</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>MAC、VLAN</td>
</tr>
<tr>
<td>网络层</td>
<td>IP、ARP、ICMP</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>应用层</td>
<td>HTTP、DNS、SMTP</td>
</tr>
</tbody></table>
<h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E7%89%A9%E7%90%86%E5%B1%82.jpg" alt="物理层"></p>
<h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.jpg" alt="数据链路层"></p>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E7%BD%91%E7%BB%9C%E5%B1%82.jpg" alt="网络层"></p>
<h4 id="4-1-IP协议"><a href="#4-1-IP协议" class="headerlink" title="4.1 IP协议"></a>4.1 IP协议</h4><h5 id="（1）IP头部格式"><a href="#（1）IP头部格式" class="headerlink" title="（1）IP头部格式"></a>（1）IP头部格式</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/IP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt="IP头部格式"></p>
<h5 id="（2）IP-地址的分类和划分子网"><a href="#（2）IP-地址的分类和划分子网" class="headerlink" title="（2）IP 地址的分类和划分子网"></a>（2）IP 地址的分类和划分子网</h5><p>分类的IP地址，是一两级的IP地址（32位），其格式为：<code>IP地址 =  {&lt;网络号&gt;，&lt;主机号&gt;}</code></p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826712.png" alt="img"></p>
<blockquote>
<p><strong>A类地址</strong>网络号字段占一个字节，只有7位可用（第一位已固定为0），故A类网络有（2^7 - 2）126个（全0表示本网络，全1（即0111 1111 ）即网络号为127保留为本地软件环回测试本主机进程之间的通信）。每一个A类网络中最大主机数为：2^24 - 2 【1：全0的主机号表示本主机；2：全1的主机号表示<strong>本网络内全部主机】。</strong></p>
<p><strong>B类地址</strong>网络号字段有2个字节，前两位固定为10，不存在全0或全1，<strong>然而，实际中128.0.0.0是不指派的。</strong>所以B类地址网络号数：2^14-1=16383，同样的主机数2^16-2 =65534。</p>
<p><strong>C类地址</strong>，前面固定110，同样的实际192.0.0.0是不指派的，2^21-1 = 2097151，主机数2^8-2 =254。</p>
</blockquote>
<p><strong>划分子网：</strong></p>
<blockquote>
<p>子网的划分就是将两级IP增加到三级IP，它是将IP地址的主机号借用作为子网号，这样增加了网络数，同时也减少了主机数。</p>
<p>子网掩码是用来和IP地址进行与运算计算得出子网地址。</p>
<p>如果一个网络不划分子网，那么该网络就使用默认的子网掩码。默认子网掩码中1的位置和IP地址中的网络号对应。划分子网后的子网掩码中1的位置和网络号+子网号的位置对应。</p>
</blockquote>
<h4 id="4-2-IPv4与IPv6的区别"><a href="#4-2-IPv4与IPv6的区别" class="headerlink" title="4.2 IPv4与IPv6的区别"></a>4.2 IPv4与IPv6的区别</h4><blockquote>
<ol>
<li><strong>更大的地址空间：</strong>IPv4中规定IP地址长度为32，即有2^32-1个地址;而IPv6中IP地址的长度为128，即有2^128-1个地址。</li>
<li><strong>更小的路由表：</strong>IPv6的地址分配一开始就遵循聚类(Aggregation)的原则，这使得路由器能在路由表中用一条记录(Entry)表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。</li>
<li><strong>增强的组播支持以及对流的支持：</strong>这使得网络上的多媒体应用有了长足发展的机会，为服务质量(QoS)控制提供了良好的网络平台.</li>
<li><strong>加入了对自动配置的支持：</strong>这是对DHCP协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷.</li>
<li><strong>更高的安全性：</strong>在使用IPv6网络中用户可以对网络层的数据进行加密并对IP报文进行校验,这极大的增强了网络安全</li>
</ol>
</blockquote>
<h4 id="4-3-请你说一说IP地址作用，以及MAC地址作用"><a href="#4-3-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="4.3 请你说一说IP地址作用，以及MAC地址作用"></a>4.3 请你说一说IP地址作用，以及MAC地址作用</h4><blockquote>
<p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
</blockquote>
<h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h3><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/%E4%BC%A0%E8%BE%93%E5%B1%82.jpg" alt="传输层"></p>
<h4 id="5-1-UDP"><a href="#5-1-UDP" class="headerlink" title="5.1 UDP"></a>5.1 UDP</h4><h5 id="（1）UDP头部"><a href="#（1）UDP头部" class="headerlink" title="（1）UDP头部"></a>（1）UDP头部</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/UDP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt="UDP头部格式"></p>
<h5 id="（2）UDP特点"><a href="#（2）UDP特点" class="headerlink" title="（2）UDP特点"></a>（2）UDP特点</h5><blockquote>
<p><strong>UDP</strong> <strong>用户数据报协议</strong>（UserDatagram Protocol）是 OSI 参考模型中一种无连接的传输层协议，提供面向事物的简单不可靠信息传送服务。</p>
<p>传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p>
</blockquote>
<h5 id="（3）应用场景"><a href="#（3）应用场景" class="headerlink" title="（3）应用场景"></a>（3）应用场景</h5><blockquote>
<p>UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题），NFS(网络文件系统)、SNMP(简单网络管理协议)、DNS(主域名称系统)、TFTP(通用文件传输协议)等等。</p>
</blockquote>
<h4 id="5-2-TCP"><a href="#5-2-TCP" class="headerlink" title="5.2 TCP"></a>5.2 TCP</h4><h5 id="（1）TCP头部"><a href="#（1）TCP头部" class="headerlink" title="（1）TCP头部"></a>（1）TCP头部</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/TCP%E5%A4%B4%E9%83%A8.jpg" alt="TCP头部"></p>
<h5 id="（2）TCP特点"><a href="#（2）TCP特点" class="headerlink" title="（2）TCP特点"></a>（2）TCP特点</h5><blockquote>
<p><strong>TCP</strong> <strong>传输控制协议</strong>（TransmissionControl Protocol）是一种面向连接的，可靠的，基于字节流的传输层通信协议。</p>
<p>TCP通过校验和进行差错校验，通过序列号、确认和超时重传机制实现<strong>可靠传输</strong>，通过滑动窗口实现<strong>流量控制</strong>，通过慢开始和拥塞避免、快重传和快恢复实现<strong>拥塞控制</strong>。</p>
</blockquote>
<h5 id="（3）应用场景-1"><a href="#（3）应用场景-1" class="headerlink" title="（3）应用场景"></a>（3）应用场景</h5><blockquote>
<p>一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等。</p>
</blockquote>
<h4 id="5-3-TCP连接管理"><a href="#5-3-TCP连接管理" class="headerlink" title="5.3 TCP连接管理"></a>5.3 TCP连接管理</h4><h5 id="（1）TCP连接建立—-三次握手"><a href="#（1）TCP连接建立—-三次握手" class="headerlink" title="（1）TCP连接建立—-三次握手"></a>（1）TCP连接建立—-三次握手</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard.png" alt="img"></p>
<p><strong>TCP首部的字段：</strong></p>
<blockquote>
<p>确认<strong>ACK</strong>：仅当ACK=1时确认号（ack）才有用，当ACK=0时确认号无效。TCP规定，连接建立后的ACK都置为1。</p>
<p>同步<strong>SYN</strong>：连接建立时用来同步序号。当SYN=1，ACK=0时表明这是一个请求报文段。响应的报文段中SYN=1，ACK=1。SYN=1表明这是一个连接请求或者连接接受阶段。</p>
<p>终止<strong>FIN</strong>：释放一个连接。当FIN=1时表明此报文段的数据已经发送完毕，要求释放运输连接。</p>
</blockquote>
<p><strong>TCP连接建立过程</strong></p>
<blockquote>
<p>（1）第一次握手：建立连接时，客户端A发送SYN包[SYN=1,ACK=0,seq=x]（随机选择一个初始序号seq=x）到服务器B（SYN=1的报文段不携带数据，但消耗掉一个序号），并进入SYN_SENT状态（同步已发送），等待服务器B确认。</p>
<p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN，同时自己也发送一个SYN包，即SYN+ACK包[SYN=1,ACK=1,seq=y,ack=x+1]，此时服务器B进入SYN_RECV状态（同步收到）。</p>
<p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK[ACK=1,seq=x+1,ack=y+1]，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 </p>
</blockquote>
<p>完成三次握手，客户端与服务器开始传送数据。在socket编程中，<strong>客户端执行connect()时，将会触发三次握手</strong>。</p>
<p><strong>为什么需要三次握手呢？</strong></p>
<blockquote>
<p>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p>
<p>主要是为了防止已经失效的连接请求报文段突然又到达了B，因而产生错误。</p>
<p>B认为A要建立连接，所以就向A发送确认报文段建立了连接，但是A没有建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，但是B却一直在等待，造成资源的浪费。</p>
</blockquote>
<p><strong>为什么不需要四次握手呢？</strong></p>
<blockquote>
<p>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：</p>
<ol>
<li>客户端发送syn0给服务器</li>
<li>服务器收到syn0，回复ack(syn0+1)</li>
<li>服务器发送syn1</li>
<li>客户端收到syn1，回复ack(syn1+1</li>
</ol>
<p>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
</blockquote>
<h5 id="（2）TCP断开—-四次挥手"><a href="#（2）TCP断开—-四次挥手" class="headerlink" title="（2）TCP断开—-四次挥手"></a>（2）TCP断开—-四次挥手</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826584.png" alt="img"></p>
<p>客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。TCP要保证在所有可能的情况下使得所有的数据都能够被投递，当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态 ，这能够保证所有的数据都被传输。</p>
<p><strong>TCP断开过程</strong></p>
<blockquote>
<p>（1）首先A B端的TCP进程都处于established状态， 当A的应用程序传送完报文段，就会去主动关闭连接。A会停止发送报文段（但是还会接收），并向B发送[FIN = 1,seq=u]（u等于前面已经发送过的数据的最后一个字节加一）数据，之后进入FIN-WAIT-1状态。</p>
<p>（2）B接收到A发送的请求之后，会通知应用进程，A已经不再发送数据，同时B会向A发送ACK确认数据[ACK=1,seq=v,ack=u+1 ]，B进入CLOSE-WAIT状态（关闭等待），A接收到B发送的数据之后，A进入FIN-WAIT-2状态；此时A到B方的连接已经关闭了（即半连接状态）。</p>
<p>（3）当B的应用进程发现自己也没有数据需要传送，B应用进程就会发出被动关闭的请求，B此时向A发送[FIN=1,ACK=1,seq=w,ack=u+1]数据，并且进入LAST-ACK状态（最后确认）。</p>
<p>（4）A接收到B发送的数据之后，向B发送ACK确认数据[ACK =1,seq=u+1,ack=w+1]，进入TIME-WAIT状态，等待2MSL（Maximum Segment Lifetime，报文最大生存时间）之后正常关闭连接进入CLOSED状态；B接收到A发送的确认之后进入CLOSED状态。B到A方的连接关闭！至此，TCP连接才真正全部关闭！</p>
</blockquote>
<p><strong>time_wait 状态存在2MSL的原因</strong></p>
<blockquote>
<ol>
<li>保证最后一次握手报文能到B，能进行超时重传。</li>
<li>2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</li>
</ol>
</blockquote>
<p><strong>为什么需要四次挥手呢？</strong></p>
<blockquote>
<p>1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。</p>
<p>2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。</p>
<p>3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。</p>
<p>4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。</p>
</blockquote>
<h4 id="5-4-TCP-可靠传输"><a href="#5-4-TCP-可靠传输" class="headerlink" title="5.4 TCP 可靠传输"></a>5.4 TCP 可靠传输</h4><p>TCP通过<strong>序列号、确认和超时重传机制</strong>实现可靠传输</p>
<blockquote>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
</blockquote>
<h4 id="5-5-TCP-流量控制"><a href="#5-5-TCP-流量控制" class="headerlink" title="5.5 TCP 流量控制"></a>5.5 TCP 流量控制</h4><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826620.png" alt="img"></p>
<p>TCP 通过<strong>滑动窗口实现</strong>流量控制</p>
<blockquote>
<p>在通信过程中，按收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这就是接收窗口rwnd，即调整TCP报文段首部中的”窗口”字段值，来限制发送方向网络注入报文的速率。同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，称为拥塞窗口cwnd，其大小与网络的带宽和时延密切相关。发送窗口的实际大小是取rwnd和cwnd中的最小值。</p>
<p>流量控制就是让发送方发送速率不要太快，让接收方来得及接收。这是<strong>点对点</strong>的通信量的控制。</p>
<p>滑动窗口协议，是TCP使用的一种流量控制方法。发送方的发送窗口不能超过接收方给出的接受窗口的大小。</p>
</blockquote>
<h4 id="5-6-TCP-拥塞控制"><a href="#5-6-TCP-拥塞控制" class="headerlink" title="5.6 TCP 拥塞控制"></a>5.6 TCP 拥塞控制</h4><p>​        发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p>
<pre><code>     发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</code></pre><p>  <strong>（1）慢开始和拥塞避免</strong></p>
<p>​      发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p>
<p>​        发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<p>​        <strong>慢开始算法</strong>：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后（一个传输轮次），把拥塞窗口增加一倍。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826659.png" alt="img"></p>
<p>​    为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。慢开始门限ssthresh的用法如下：</p>
<p>​        当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
<p>​        当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>​        当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p>​    <strong>拥塞避免算法</strong>：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>​        无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826688.png" alt="img"></p>
<p>​    <strong>（2）快重传和快恢复</strong></p>
<p>​    <strong>快重传：</strong>算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827065.png" alt="img"></p>
<p>​    快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p><strong>快恢复算法</strong>，其过程有以下两个要点：</p>
<p>​      （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
<p>​       （2） 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827203.png" alt="img"></p>
<h4 id="5-7-问题"><a href="#5-7-问题" class="headerlink" title="5.7 问题"></a>5.7 问题</h4><h5 id="（1）请你说一说TCP状态转移"><a href="#（1）请你说一说TCP状态转移" class="headerlink" title="（1）请你说一说TCP状态转移"></a>（1）请你说一说TCP状态转移</h5><p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/311436_1552471666772_F4FEF3EED170579049D40CE58E343EE4.png" alt="img"></p>
<h5 id="（2）请你说说TCP-IP数据链路层的交互过程"><a href="#（2）请你说说TCP-IP数据链路层的交互过程" class="headerlink" title="（2）请你说说TCP/IP数据链路层的交互过程"></a>（2）请你说说TCP/IP数据链路层的交互过程</h5><blockquote>
<p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器。</p>
</blockquote>
<h5 id="（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"></a>（3）请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h5><blockquote>
<p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
</blockquote>
<h5 id="（4）TCP和UDP的区别和各自适用的场景"><a href="#（4）TCP和UDP的区别和各自适用的场景" class="headerlink" title="（4）TCP和UDP的区别和各自适用的场景"></a>（4）TCP和UDP的区别和各自适用的场景</h5><p><strong>TCP和UDP区别</strong></p>
<blockquote>
<p>1） 连接</p>
<ul>
<li>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</li>
<li>UDP无连接。</li>
</ul>
<p>2） 服务对象</p>
<ul>
<li>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</li>
<li>UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
</ul>
<p>3） 可靠性</p>
<ul>
<li>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</li>
<li>UDP是尽最大努力交付，不保证可靠交付。</li>
</ul>
<p>4）拥塞控制，流量控制</p>
<ul>
<li>TCP有拥塞控制和流量控制保证数据传输的安全性。</li>
<li>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
</ul>
<p>5） 报文长度</p>
<ul>
<li>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</li>
<li>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
</ul>
<p>6)   首部开销</p>
<ul>
<li>TCP首部开销大，首部20个字节。</li>
<li>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
</ul>
</blockquote>
<p><strong>应用场景</strong></p>
<blockquote>
<p>特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
</blockquote>
<h5 id="（5）粘包问题"><a href="#（5）粘包问题" class="headerlink" title="（5）粘包问题"></a>（5）粘包问题</h5><p><strong>出现的原因</strong></p>
<blockquote>
<ol>
<li>发送端需要等缓冲区满才发送出去，造成粘包</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ol>
</blockquote>
<p>具体点：</p>
<blockquote>
<p>（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</p>
<p>（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p>
<p>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p>
</blockquote>
<p><strong>避免粘包</strong></p>
<blockquote>
<p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开</p>
</blockquote>
<h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h3><h4 id="6-1-HTTP协议"><a href="#6-1-HTTP协议" class="headerlink" title="6.1 HTTP协议"></a>6.1 HTTP协议</h4><h5 id="（1）HTTP协议过程"><a href="#（1）HTTP协议过程" class="headerlink" title="（1）HTTP协议过程"></a>（1）HTTP协议过程</h5><p><strong>HTTP</strong> <strong>超文本传输协议</strong>（HyperText Transfer Protocol）是互联网上应用最为广泛的一种协议。</p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827090.png" alt="img"></p>
<p>​    HTTP协议永远都是客户端发起请求，服务器回送响应。HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求没有对应关系。一次HTTP操作称为一个事务，其工作过程可分为四步：</p>
<p>​    1）首先客户机与服务器需要建立连接（建立的是TCP连接，不是HTTP连接，因为HTTP是无连接的）。（只要单击某个超级链接，HTTP的工作开始）具体来说如下：</p>
<p>​    ① 地址解析</p>
<p>​         如客户端浏览器请求这个页面：<a href="http://localhost:8080/simple.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a>l</p>
<p>​         从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p>
<p>​         协议名：http</p>
<p>​         主机名：localhost.com</p>
<p>​         端口：8080</p>
<p>​         对象路径：/index.htm</p>
<p>​         在这一步，需要域名解析系统DNS解析域名 localhost.com 得到主机的IP地址。</p>
<p>​    域名解析的过程：首先搜索浏览器自身的DNS缓存，如果自身的缓存中有对应的条目，而且没有过期，则解析到此结束；如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存；如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件看看这里面有没有该域名对应的IP地址，如果有则解析成功；如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器发起域名解析请求。</p>
<p>​    ② 封装HTTP请求数据包</p>
<p>​      把以上部分结合本机自己的信息，封装成一个HTTP请求数据包。</p>
<p>​    报文的组成：</p>
<p>​    （1）开始行：在请求报文中叫请求行（包括方法、请求资源的URL、HTTP版本），在响应报文中叫状态行（HTTP版本、状态码、状态码的简单短语）。</p>
<p>​    其中http版本有：</p>
<p>​    <strong>http 0.9</strong>：HTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。</p>
<p>​    <strong>http 1.0</strong>：HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。</p>
<p>​    <strong>http 1.1</strong> ：HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。（和1.0 的主要区别就是是否是持久连接，1.0一个tcp连接只传输一个Web对象；1.1默认使用持久连接，当然也可以配置成使用非持久连接）</p>
<p>​    <strong>http 2.0</strong>：HTTP 2.0是下一代 HTTP 协议，目前应用还非常少。</p>
<p>​    HTTP 2.0最大的特点: 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段这些核心概念没变，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。同时还可以让服务器将响应主动“推送”到客户端缓存中，以此来避免往返的延迟。</p>
<p>​    HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p>
<p>​    （2）首部行，说明浏览器，服务器或者报文主体的一些信息。</p>
<p>​    （3）实体主体，一般不使用。</p>
<p>​    ③ 封装成TCP包，建立TCP连接（HTTP请求报文作为三次握手的第三个报文的数据发送给服务器）。</p>
<p>​    2）TCP连接建立后，客户机发送一个http请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<p>​    3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<p>​    4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p>
<p>​    如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<h5 id="（2）二进制协议-VS-文本协议"><a href="#（2）二进制协议-VS-文本协议" class="headerlink" title="（2）二进制协议 VS 文本协议"></a>（2）二进制协议 VS 文本协议</h5><p>  二进制协议一般消息头固定和消息体变长 ，每个字段固定了含义 ，其特点如下：</p>
<blockquote>
<ol>
<li>解析效率超高，几乎没有解析代价（优点）；</li>
<li>没有冗余字段，体积小（优点）；</li>
<li>可读性差，难于调试（缺点）；</li>
<li>扩展性不好 ，如果要扩展字段，旧版协议就不兼容了（缺点）；</li>
</ol>
</blockquote>
<p>文本协议（一般是由一串ACSII字符组成的数据）：</p>
<blockquote>
<ol>
<li>可读性好，便于调试；</li>
<li>扩展性也好，方便兼容旧协议；</li>
<li>解析效率一般，需要进行字符串比对；</li>
<li>存在冗余字段，体积大；</li>
</ol>
</blockquote>
<p><strong>http 2.0之前的是文本协议，2.0采用的二进制协议。</strong></p>
<h5 id="（3）HTTP-1-1-协议中的八种请求方法"><a href="#（3）HTTP-1-1-协议中的八种请求方法" class="headerlink" title="（3）HTTP/1.1 协议中的八种请求方法"></a>（3）HTTP/1.1 协议中的八种请求方法</h5><p>   GET和POST是HTTP协议中的两种发送请求的方法，而HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP。GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>数据位置</td>
<td>参数通过URL传递</td>
<td>放在Request body中</td>
</tr>
<tr>
<td>缓存</td>
<td>请求可被主动缓存</td>
<td>请求不会被缓存（除非主动设置）</td>
</tr>
<tr>
<td>数据长度</td>
<td>GET方式提交的数据最多只能是1024字节</td>
<td>无限制</td>
</tr>
<tr>
<td>可见性/安全性</td>
<td>数据在 URL 中对所有人都是可见的</td>
<td>数据不会显示在 URL 中</td>
</tr>
<tr>
<td>数据类型</td>
<td>只允许 ASCII 字符</td>
<td>没有限制，也允许二进制数据</td>
</tr>
<tr>
<td>数据包的个数</td>
<td>GET产生一个TCP数据包（浏览器会把http header和data一并发送出去 ）</td>
<td>POST产生两个TCP数据包（浏览器先发送header，服务器响应，浏览器再发送data ）</td>
</tr>
</tbody></table>
<p><strong>其他方法</strong></p>
<blockquote>
<ol>
<li><strong>PUT：</strong>向指定资源位置上传其最新内容。</li>
<li><strong>DELETE：</strong>请求服务器删除 request-url所标识的资源。</li>
<li><em><em>OPTIONS ： </em></em>返回服务器针对特定资源所支持的HTTP请求方法。</li>
<li><strong>HEAD：</strong>向服务器索要与get请求相一致的响应，但是响应体将不会被返回。</li>
<li><strong>TRACE：</strong>回显服务器收到的请求，主要用于测试和诊断。</li>
<li><strong>CONNECT：</strong>预留给能够将连接改为管道方式的代理服务器。</li>
</ol>
</blockquote>
<h5 id="（4）HTTP返回码"><a href="#（4）HTTP返回码" class="headerlink" title="（4）HTTP返回码"></a>（4）HTTP返回码</h5><p> <strong>1xx——通知信息</strong>，如请求收到了或正在处理。</p>
<p> <strong>2xx——成功</strong>，成功被服务器接收、理解、并接受。</p>
<blockquote>
<p>​    200  服务器成功返回网页</p>
</blockquote>
<blockquote>
<p>​    201 请求成功并且服务器创建了新的资源。</p>
</blockquote>
<blockquote>
<p>​    202 服务器已接受请求，但尚未处理</p>
</blockquote>
<p> <strong>3xx——重定向</strong>，客户端需要采取进一步的操作才能完成请求。</p>
<blockquote>
<p>​    301状态码：被请求的资源已永久移动到新位置，服务器返回此响应时会自动将请求者转到新位置。</p>
</blockquote>
<blockquote>
<p>​    302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
</blockquote>
<blockquote>
<p>​    304自从上次请求后，请求的网页未修改过。</p>
</blockquote>
<p><strong>4xx——客户端错误</strong>，请求有语法错误或请求无法实现。</p>
<blockquote>
<p>​    401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>
</blockquote>
<blockquote>
<p>​    403状态码：服务器已经理解请求，但是拒绝执行它。</p>
</blockquote>
<blockquote>
<p>​    404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。</p>
</blockquote>
<p><strong>5xx——服务器端错误</strong>，服务器未能实现合法的请求。</p>
<blockquote>
<p>​    500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</p>
</blockquote>
<blockquote>
<p>​    503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复。</p>
</blockquote>
<h5 id="（5）HTTP-特点"><a href="#（5）HTTP-特点" class="headerlink" title="（5）HTTP 特点"></a>（5）HTTP 特点</h5><blockquote>
<p>1、简单快速：</p>
<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：</p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3、无连接：</p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4、无状态：</p>
<p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>5、支持B/S及C/S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
</blockquote>
<h5 id="（6）HTTP1-0和HTTP1-1的一些区别"><a href="#（6）HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="（6）HTTP1.0和HTTP1.1的一些区别"></a>（6）HTTP1.0和HTTP1.1的一些区别</h5><blockquote>
<p>（1）长连接</p>
<p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，一定程度上弥补了HTTP 1.0每次请求都要创建连接的缺点。</p>
<p>（2）错误通知的管理</p>
<p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p>（3）带宽优化及网络连接的使用</p>
<p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p>（4）Host头处理在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
<p>（5）缓存处理</p>
<p>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
</blockquote>
<h5 id="（7）-HTTP2-0-和-HTTP1-X-相比的新特性"><a href="#（7）-HTTP2-0-和-HTTP1-X-相比的新特性" class="headerlink" title="（7） HTTP2.0 和 HTTP1.X 相比的新特性"></a>（7） HTTP2.0 和 HTTP1.X 相比的新特性</h5><p>​        HTTP 2.0最大的特点: 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段这些核心概念没变，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。</p>
<blockquote>
<p><strong>（1）新的二进制格式</strong>（Binary Format）</p>
</blockquote>
<blockquote>
<p>​    而之所以叫2.0，是在于新增的二进制分帧层。HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p>
</blockquote>
<blockquote>
<p><strong>（2）多路复用</strong>（MultiPlexing）</p>
</blockquote>
<blockquote>
<p>​    即连接共享，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
</blockquote>
<blockquote>
<p><strong>（3）header压缩</strong></p>
</blockquote>
<blockquote>
<p>​    HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
</blockquote>
<blockquote>
<p><strong>（4）服务端推送</strong>（server push）</p>
</blockquote>
<blockquote>
<p>​    同时还可以让服务器将响应主动“推送”到客户端缓存中，以此来避免往返的延迟。</p>
</blockquote>
<h4 id="6-2-HTTPS协议"><a href="#6-2-HTTPS协议" class="headerlink" title="6.2 HTTPS协议"></a>6.2 HTTPS协议</h4><h5 id="（1）过程"><a href="#（1）过程" class="headerlink" title="（1）过程"></a>（1）过程</h5><p> https简单的说就是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，为了安全传输敏感数据，在http的基础上添加了一个安全传输层，对所有的数据都加密后再进行传输，客户端和服务器端收到加密数据后按照之前约定好的秘钥解密。</p>
<p>​    https要使客户端与服务器端的通信过程得到安全保证，必须使用对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密，从而解决了客户端与服务器端之间的通信安全问题。</p>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366826891.png" alt="img"></p>
<p>​    （1）客户端先向服务器发出加密通信的请求（协议版本、random1、加密方法、压缩方法）。</p>
<p>​    （2）服务器收到请求,然后响应（协议版本、random2、加密方法、服务器证书）。</p>
<p>​    （3）客户端收到证书之后会首先会进行验证，如果没有验证通过，就会显示不安全的提示。验证通过之后，客户端会生成一个随机数 pre-master secret，然后使用证书中的公钥进行加密，然后传递给服务器端。</p>
<p>​    （4）服务器收到使用公钥加密的内容，在服务器端使用私钥解密（https中公钥和私钥是互为加密解密的。公钥是大家都知道的，你发送的数据是用公钥加密的，如果公钥能够解密的话，https也就不具备安全性了）之后获得随机数pre-master secret，然后根据radom1、radom2、pre-master secret通过一定的算法得出session Key和MAC算法秘钥，作为后面交互过程中使用对称秘钥。同时客户端也会使用radom1、radom2、pre-master secret，和同样的算法生成session Key和MAC算法的秘钥。</p>
<p>​    （5）然后在后续的交互中就使用session Key和MAC算法的秘钥对传输的内容进行加密和解密。</p>
<h5 id="（2）抓包的数据安全性"><a href="#（2）抓包的数据安全性" class="headerlink" title="（2）抓包的数据安全性"></a>（2）抓包的数据安全性</h5><p>​        https抓包的原理就是抓包程序将服务器返回的证书截获，然后给客户端返回一个它自己的证书，客户端发送的数据抓包程序用自己的证书解密，然后再用截获的证书加密，再发给服务器，所以抓包程序看到的是明文。</p>
<h4 id="6-4-问题"><a href="#6-4-问题" class="headerlink" title="6.4 问题"></a>6.4 问题</h4><h5 id="（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>（1）请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h5><p>HTTP协议和HTTPS协议区别如下：</p>
<blockquote>
<p>（1）HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>（2）HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p>
<p>（3）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>（4）HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
</blockquote>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/clipboard-1570366827253.png" alt="img"></p>
<p>HTTPS优点：</p>
<blockquote>
<ul>
<li>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</li>
<li>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</li>
</ul>
</blockquote>
<p>HTTPS缺点：</p>
<blockquote>
<ul>
<li>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</li>
<li>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</li>
</ul>
</blockquote>
<h5 id="（2）cookie-和-session-的区别和联系"><a href="#（2）cookie-和-session-的区别和联系" class="headerlink" title="（2）cookie 和 session 的区别和联系"></a>（2）cookie 和 session 的区别和联系</h5><p> 理论上一个用户的所有请求操作都应该属于同一个会话，Web应用程序是使用HTTP协议进行传输数据的，HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接，这就意味着服务器无法从连接上跟踪会话，为了弥补HTTP协议无状态的不足，引入了cookie机制进行会话跟踪。</p>
<p>​    客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</p>
<p><strong>区别：</strong></p>
<blockquote>
<ol>
<li>cookie在客户端记录信息确定用户身份，session在服务器端记录信息确定用户身份。</li>
<li>Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。</li>
<li>Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</li>
</ol>
</blockquote>
<p>​    <strong>联系：</strong></p>
<blockquote>
<ol>
<li>cookie和session都是用来跟踪浏览器用户身份的会话方式。</li>
<li>session 的运行依赖 session id，而 session id 是存在 cookie 中的，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）。</li>
<li>Session是保存在服务器端的，每个用户都会产生一个Session。如果并发访问的用户非常多，会产生非常多的Session，消耗大量的内存。 而Cookie保存在客户端，不占用服务器资源。如果并发浏览的用户非常多，Cookie是很好的选择。</li>
</ol>
</blockquote>
<h5 id="（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>（3）搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h5><p>浏览器中输入URL，浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<p>1、DNS协议，http协议，https协议属于应用层</p>
<p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<p>2、TCP/UDP属于传输层</p>
<p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<p>3、IP协议，ARP协议属于网络层</p>
<p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。<br>4、数据链路层</p>
<p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。<br>5、物理层</p>
<p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
<h5 id="（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"><a href="#（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）" class="headerlink" title="（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"></a>（4）请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）</h5><blockquote>
<p>服务端：socket-bind-listen-accept</p>
<p>客户端：socket-connect</p>
</blockquote>
<h5 id="（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>（5）请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h5><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p>
<h5 id="（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数"><a href="#（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数"></a>（6）请你来说一下socket编程中服务器端和客户端主要用到哪些函数</h5><p><strong>基于TCP的socket：</strong></p>
<blockquote>
<p><strong>服务器端程序：</strong></p>
<ul>
<li>创建一个socket，用函数socket()</li>
<li>绑定IP地址、端口等信息到socket上，用函数bind()</li>
<li>设置允许的最大连接数，用函数listen()</li>
<li>接收客户端上来的连接，用函数accept()</li>
<li>收发数据，用函数send()和recv()，或者read()和write()</li>
<li>关闭网络连接</li>
</ul>
<p><strong>客户端程序：</strong></p>
<ul>
<li>创建一个socket，用函数socket()</li>
<li>设置要连接的对方的IP地址和端口等属性</li>
<li>连接服务器，用函数connect()</li>
<li>收发数据，用函数send()和recv()，或read()和write()</li>
<li>关闭网络连接</li>
</ul>
</blockquote>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/308571_1552654678444_69CF8398BCC9F204991E623723D022E7.png" alt="img"></p>
<p><strong>基于UDP的socket：</strong></p>
<blockquote>
<p><strong>服务器端流程</strong></p>
<ul>
<li>建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</li>
<li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</li>
<li>绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</li>
<li>接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</li>
<li>向客户端发送数据，使用sendto()函数向服务器主机发送数据。</li>
<li>关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li>
</ul>
<p><strong>客户端流程</strong></p>
<ul>
<li>建立套接字文件描述符，socket()。</li>
<li>设置服务器地址和端口，struct sockaddr。</li>
<li>向服务器发送数据，sendto()。</li>
<li>接收服务器的数据，recvfrom()。</li>
<li>关闭套接字，close()。</li>
</ul>
</blockquote>
<p><img src="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C.png" alt="img"></p>
<h5 id="（7）请你来说一下数字证书是什么，里面都包含那些内容"><a href="#（7）请你来说一下数字证书是什么，里面都包含那些内容" class="headerlink" title="（7）请你来说一下数字证书是什么，里面都包含那些内容"></a>（7）请你来说一下数字证书是什么，里面都包含那些内容</h5><p><strong>1）概念：</strong></p>
<p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p>
<p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p>
<p><strong>2）数字证书颁发过程：</strong></p>
<p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p>
<p><strong>3）内容：</strong></p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<blockquote>
<ul>
<li>证书的版本信息；</li>
<li>证书的序列号，每个证书都有一个唯一的证书序列号；</li>
<li>证书所使用的签名算法；</li>
<li>证书的发行机构名称，命名规则一般采用X.500格式；</li>
<li>证书的有效期，通用的证书一般采用UTC时间格式；</li>
<li>证书所有人的名称，命名规则一般采用X.500格式；</li>
<li>证书所有人的公开密钥；</li>
<li>证书发行者对证书的签名。</li>
</ul>
</blockquote>
<h5 id="（8）请你讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#（8）请你讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="（8）请你讲述一下Socket编程的send() recv() accept() socket()函数？"></a>（8）请你讲述一下Socket编程的send() recv() accept() socket()函数？</h5><p>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p>
<p>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p>
<h5 id="（9）请你说一下http协议会话结束标志怎么截出来？"><a href="#（9）请你说一下http协议会话结束标志怎么截出来？" class="headerlink" title="（9）请你说一下http协议会话结束标志怎么截出来？"></a>（9）请你说一下http协议会话结束标志怎么截出来？</h5><p>看tcp连接是否有断开的四部挥手阶段。</p>
<h5 id="（10）请你来介绍一下udp的connect函数"><a href="#（10）请你来介绍一下udp的connect函数" class="headerlink" title="（10）请你来介绍一下udp的connect函数"></a>（10）请你来介绍一下udp的connect函数</h5><p>除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p>
<p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p>
<p>其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p>
<p>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</p>
<p>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</p>
<p>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</p>
<p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p>
<p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p>
<h5 id="（11）请你说一下阻塞，非阻塞，同步，异步"><a href="#（11）请你说一下阻塞，非阻塞，同步，异步" class="headerlink" title="（11）请你说一下阻塞，非阻塞，同步，异步"></a>（11）请你说一下阻塞，非阻塞，同步，异步</h5><blockquote>
<p><strong>阻塞和非阻塞：</strong>调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p>
<p><strong>同步和异步：</strong>调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步。</p>
</blockquote>
<h5 id="（12）Ping和TraceRoute实现原理"><a href="#（12）Ping和TraceRoute实现原理" class="headerlink" title="（12）Ping和TraceRoute实现原理"></a>（12）Ping和TraceRoute实现原理</h5><blockquote>
<ol>
<li>Ping是通过发送ICMP报文回显请求实现。<br>ICMP是（Internet Control Message Protocol）Internet控制报文协议,用于在IP主机、路由器之间传递控制消息。</li>
<li>Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。</li>
</ol>
<ul>
<li>首先，tracert送出一个TTL是1的IP 数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将TTL减1。此时，TTL变为0，所以该路由器会将此数据包丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），tracert 收到这个消息后，便知道这个路由器存在于这个路径上，接着tracert 再送出另一个TTL是2 的数据包，发现第2 个路由器…… tracert 每次将送出的数据包的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个数据包 抵达目的地。当数据包到达目的地后，该主机则不会送回ICMP time exceeded消息，一旦到达目的地，由于tracert通过UDP数据包向不常见端口(30000以上)发送数据包，因此会收到「ICMP port unreachable」消息，故可判断到达目的地。</li>
<li>tracert 有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的*号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Tracert给TTL记数器加1，继续进行。</li>
</ul>
</blockquote>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《面试-计算机网络》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/10/06/mian-shi-ji-suan-ji-wang-luo/" property="cc:attributionName"
               rel="cc:attributionURL">
                吴超峰
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '923d90ea3101fe2914db',
        clientSecret: '7847824396cf1d7c4eefc2a8e22ef56e6698372c',
        repo: 'chaofeng-wu.github.io',
        owner: 'chaofeng-wu',
        admin: "chaofeng-wu",
        id: '2019/10/06/mian-shi-ji-suan-ji-wang-luo/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/10/06/mian-shi-shu-ju-ku/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="面试-数据库">
                        
                        <span class="card-title">面试-数据库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、基本概念1.主键、外键、超键、候选键
超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
候选键：是最小超键，即没有冗余元素的超键。
主键：数
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-10-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/面试/" class="post-category" target="_blank">
                                    面试
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/数据库/" target="_blank">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/10/06/mian-shi-c/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="面试-C++">
                        
                        <span class="card-title">面试-C++</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 编译和链接1.1 编译和链接1.1.1 请你来说一下一个C++源文件从文本到可执行文件经历的过程？
对于C++源文件，从文本到可执行文件一般需要四个过程：

预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-10-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/面试/" class="post-category" target="_blank">
                                    面试
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/" target="_blank">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 吴超峰的博客<br />'
            + '作者: 吴超峰<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019 chaofengwu. All Rights Reserved.

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">106.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/chaofeng-wu" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>







    <a href="https://user.qzone.qq.com/1339784341" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 10, 6, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    
    <script type="text/javascript" src="/libs/others/snow.js"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>

</html>